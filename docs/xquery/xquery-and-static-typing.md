---
title: XQuery и Static ввода | Документы Microsoft
ms.custom: ''
ms.date: 03/17/2017
ms.prod: sql
ms.prod_service: sql
ms.component: xquery
ms.reviewer: ''
ms.suite: sql
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: language-reference
applies_to:
- SQL Server
dev_langs:
- XML
helpviewer_keywords:
- XQuery, static typing
- static typing
- checking static types
- inference [XQuery]
ms.assetid: d599c791-200d-46f8-b758-97e761a1a5c0
caps.latest.revision: 38
author: rothja
ms.author: jroth
manager: craigg
ms.openlocfilehash: 03958536a329b59a15ceade13cac1598d97dd346
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="xquery-and-static-typing"></a>XQuery и статическая типизация
[!INCLUDE[tsql-appliesto-ss2012-xxxx-xxxx-xxx-md](../includes/tsql-appliesto-ss2012-xxxx-xxxx-xxx-md.md)]

  В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] XQuery является языком со статической типизацией. Это означает, что при компиляции запросов, если выражение возвращает значение, тип или количество элементов которого неприемлемы для указанной функции или оператора, будет выдана ошибка преобразования типов. В дополнение к этому статическая проверка типов может также обнаружить несоответствие типа выражения пути в типизированном документе XML. Компилятор XQuery сначала применяет фазу нормализации, во время которой добавляются неявные операции (например атомизация), а затем производит статический вывод и статическую проверку типов.  
  
## <a name="static-type-inference"></a>Статический вывод типов  
 Во время операции вывода статического типа определяется тип возвращаемого значения выражения. Для этого берутся статические типы входных параметров и статическая семантика операции и выводится статический тип результата. Например статический тип выражения «1 + 2.3» определяется следующим образом.  
  
-   Статический тип 1 — **xs: Integer** и имеет статический тип 2.3 **xs: decimal**. В зависимости от динамической семантики, статическая семантика **+** операция преобразует целочисленное значение в десятичное и затем возвращает десятичное число. Выведенным статическим типом будет **xs: decimal**.  
  
 Для нетипизированных экземпляров XML имеются специальные типы, обозначающие, что данные нетипизированы. Эти сведения используются при статической проверке типов и для неявного приведения некоторых типов.  
  
 Для типизированных данных входной тип выводится из коллекции XML-схем, ограничивающей экземпляр типа данных XML. Например, если схема допускает только наличие элементов типа **xs: Integer**, результат выражения пути, использующего этот элемент будет ноль или более элементов типа **xs: Integer**. В настоящее время выражается с помощью выражения, такие как `element(age,xs:integer)*` где символ звездочки (\*) определяет количество элементов результирующего типа. В этом примере результатом выражения в ноль или более элементов с именем «age» и типом **xs: Integer**. Остальные мощности: ровно 1 и выражаются с использованием только имени типа ноль или один, что выражается указанием вопросительного знака (**?**) и 1 и более, что выражается указанием плюса (**+**) .  
  
 Иногда вывод статического типа может определить, что выражение всегда возвращает пустую последовательность. Например, если выражение пути типизированного типа данных XML ищет \<имя > элемент внутри \<клиента > (/ customer/name) элемента, но схема не допускает \<имя > внутри \<клиента >, статический вывод типа будет построена, результат будет пустым. Это будет использоваться для выявления неправильных запросов и будет считаться статическую ошибку, если выражение было () или **данных (())**.  
  
 Подробное описание правил вывода содержится в формальной семантике спецификации XQuery. Корпорация Майкрософт только незначительно изменила их для работы с типизированными экземплярами типа данных XML. Наиболее важное отличие от стандарта заключается в том, что неявный узел документа знает тип данных экземпляра XML. Поэтому выражение пути в форме «/age» на основе этих сведений будет точно типизировано.  
  
 С помощью [разрешения и шаблоны приложения SQL Server Profiler](../tools/sql-server-profiler/sql-server-profiler-templates-and-permissions.md), вы увидите статические типы, возвращаемые при компиляции запросов. Чтобы просмотреть их, трассировка должна включать событие XQuery Static Type в категории событий TSQL.  
  
## <a name="static-type-checking"></a>Статическая проверка типов  
 Статическая проверка типов гарантирует, что на стадии выполнения операции будут переданы только те значения, которые имеют соответствующие типы данных. Поскольку эти типы на стадии выполнения не надо проверять, потенциальные ошибки могут быть обнаружены на ранней стадии компиляции,  что позволяет повысить производительность. Однако статическая типизация требует точности формулировок при написании запроса.  
  
 Ниже приведены все применимые типы:  
  
-   типы, явно допустимые для функции или операции;  
  
-   подтипы явно допустимых типов.  
  
 Подтипы определяются на основе правил создания подтипов XML-схемы при наследовании по ограничению или по расширению. Например, тип S является подтипом типа T, если все значения, которые имеет тип S, являются также экземплярами типа T.   
  
 Кроме того, в соответствии с иерархией типов XML-схемы, все целочисленные значения являются также и десятичными. Но при этом не все десятичные значения являются целочисленными. Иными словами, целочисленное является подтипом десятичного, но не наоборот. Например **+** принимает только значения определенных типов, например числовых типов **xs: Integer**, **xs: decimal**, **xs: число с плавающей запятой**, и **xs: double**. Если значения других типов, таких как **xs: String**, будут переданы, операция выдает ошибку типа. Это называется строгой типизацией. Значения других типов, например атомарного типа, применяемого для обозначения нетипизированного XML, могут быть неявно преобразованы в значение типа, поддерживаемого для данной операции. Это называется слабой типизацией.  
  
 Если требуется неявное преобразование, статическая проверка типов гарантирует, что операции будут переданы только значения допустимых типов с верным количеством элементов. «Строка» + 1, он распознает, что статическим типом значения «строка» является **xs: String**. Так как это не тип недопустим для **+** возникает ошибка типа операции.  
  
 При сложении результатов произвольного выражения E1 и произвольного выражения E2 (E1 + E2) статический вывод типов сначала определяет статические типы E1 и E2, а затем сверяет их с типами, допустимыми для данной операции. Например, если статический тип E1 может быть либо **xs: String** или **xs: Integer**, проверка статического типа выдает ошибку типа, даже если некоторые значения во время выполнения могут оказаться целочисленными. Это может произойти, если статический тип E1 **xs: Integer\***. Поскольку **+** операция принимает только одно целочисленное значение и E1 может вернуть 0 или более 1, статическая проверка типов выдаст ошибку.  
  
 Как говорилось ранее, вывод типов часто определяет тип более свободно, чем известно о передаваемом типе данных пользователю. В таких случаях пользователь должен переписать запрос. Некоторые наиболее распространенные причины этого:  
  
-   Тип выводит более общий тип: супертип или объединение типов. Если тип является атомарным, для обозначения действительного статического типа необходимо применить выражение явного приведения или функцию конструктора. Например, если выведенный тип выражения E1 может быть **xs: String** или **xs: Integer** и добавление требует **xs: Integer**, следует писать `xs:integer(E1) + E2` вместо `E1+E2`. Это выражение может завершиться ошибкой во время выполнения при обнаружении строковое значение, не может быть приведен к **xs: Integer**. но зато теперь выражение будет проходить статическую проверку типов. Такое выражение сопоставляется с пустой последовательностью.  
  
-   Тип выводит количество элементов большее, чем в действительности содержат данные. Это часто происходит из-за **xml** тип данных может содержать более одного элемента верхнего уровня и коллекции XML-схем не ограничено. Чтобы ограничить статический тип и гарантировать, что передается не более одного значения, следует применять позиционный предикат `[1]`. Например, чтобы добавить 1 к значению атрибута `c` элемента `b` под элементом верхнего уровня, необходимо выполнить `write (/a/b/@c)[1]+1`. Также ключевое слово DOCUMENT может использоваться с коллекцией XML-схем.  
  
-   Некоторые операции приводят к потере типа данных во время вывода. Например, если не удается определить тип узла, он становится **anyType**. Это не неявное приведение типа к любому другому типу. Эти преобразования наиболее заметно появляются во время перемещения с помощью родительской оси. Если выражение приводит к ошибке статической типизации, избегайте таких операций и перепишите запрос.  
  
## <a name="type-checking-of-union-types"></a>Контроль типов объединенных типов   
 Работать с объединенными типами нужно особенно внимательно из-за проверки типов. Следующие примеры поясняют две из возможных проблем.  
  
### <a name="example-function-over-union-type"></a>Пример: Функция с объединенным типом  
 Взгляните на следующее определение элемента <`r`> объединенного типа:  
  
```  
<xs:element name="r">  
<xs:simpleType>  
   <xs:union memberTypes="xs:int xs:float xs:double"/>  
</xs:simpleType>  
</xs:element>  
```  
  
 В контексте XQuery, функция «среднее» `fn:avg (//r)` возвращает статическую ошибку, потому что компилятор XQuery не может сложить значения разных типов (**xs: int**, **xs: float** или **xs: двойные**) для <`r`> элементов в аргументе **fn:avg()**. Чтобы решить эту проблему, перепишите вызов функции как `fn:avg(for $r in //r return $r cast as xs:double ?)`.  
  
### <a name="example-operator-over-union-type"></a>Пример: Оператора с объединенным типом  
 Оператор сложения ('+') требует использования точных типов операндов. Таким образом, выражение `(//r)[1] + 1` возвращает статическую ошибку, которая имеет вышеуказанное определение типа элемента <`r`>. Единственное решение — переписать его как `(//r)[1] cast as xs:int? +1`, где «?» обозначает появление 0 или 1. В [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] требуется указывать «cast as» с «?», так как любое приведение может вызвать пустую последовательность в результате ошибок во время выполнения.  
  
## <a name="see-also"></a>См. также  
 [Справочник по языку XQuery (SQL Server)](../xquery/xquery-language-reference-sql-server.md)  
  
  
