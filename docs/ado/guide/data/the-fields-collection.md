---
title: "Коллекция полей | Документы Microsoft"
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: guide
ms.technology:
- drivers
ms.custom: 
ms.date: 01/19/2017
ms.reviewer: 
ms.suite: sql
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- Field object [ADO], fields collection
- Fields collection [ADO]
ms.assetid: 574cf36e-e5f5-403b-983c-749ef93c108f
caps.latest.revision: 12
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: On Demand
ms.translationtype: MT
ms.sourcegitcommit: f7e6274d77a9cdd4de6cbcaef559ca99f77b3608
ms.openlocfilehash: 2c5d81985322b03892d17875959086078defd819
ms.contentlocale: ru-ru
ms.lasthandoff: 09/09/2017

---
# <a name="the-fields-collection"></a>Коллекция полей
**Поля** коллекция является одной из встроенных коллекций ADO. Коллекция — это упорядоченный набор элементов, которые могут ссылаться как единое целое. Дополнительные сведения о коллекциях ADO см. в разделе [объектная модель ADO](../../../ado/guide/data/ado-objects-and-collections.md).  
  
 **Поля** коллекция содержит **поле** объекта для каждого поля (столбца) в **записей**. Как и все коллекции ADO, имеет **число** и **элемент** свойства, а также **Append** и **обновления** методы. Он также имеет **CancelUpdate**, **удаление**, **Resync**, и **обновление** методы, которые недоступны в других коллекциях ADO.  
  
## <a name="examining-the-fields-collection"></a>Изучение коллекции полей  
 Рассмотрим **поля** коллекции образца **записей** представленные в этом разделе. Образец **записей** является производным от инструкции SQL  
  
```  
SELECT ProductID, ProductName, UnitPrice FROM Products WHERE CategoryID = 7  
```  
  
 Таким образом, который необходимо найти **полям набора записей** коллекция содержит три поля.  
  
```  
'BeginWalkFields  
    Dim objFields As ADODB.Fields  
    Dim intLoop As Integer  
  
    objRs.Open strSQL, strConnStr, adOpenForwardOnly, adLockReadOnly, adCmdText  
  
    Set objFields = objRs.Fields  
  
    For intLoop = 0 To (objFields.Count - 1)  
        Debug.Print objFields.Item(intLoop).Name  
    Next  
'EndWalkFields  
```  
  
 Этот код определяет число **поле** объекты в **поля** коллекции с помощью **число** свойства и выполняется цикл по коллекции, возвращение значения **имя** свойства каждого **поле** объекта. Можно использовать другие **поле** свойства для получения сведений о поле. Дополнительные сведения о запросах к **поле**, в разделе [объект поля](../../../ado/guide/data/the-field-object.md).  
  
## <a name="counting-columns"></a>Подсчет столбцов  
 Как и следует ожидать, **число** свойство возвращает фактическое число **поле** объекты в **поля** коллекции. Поскольку нумерация для членов коллекции начинается с нуля, всегда следует создавать циклы, начиная с нуля элемента и заканчивая значение **число** свойство минус 1. Если используется Microsoft Visual Basic для перебора элементов коллекции без проверки в **число** свойства, используйте **For Each... Далее** команды.  
  
 Если **число** свойство имеет значение 0, нет ни одного объекта в коллекции.  
  
## <a name="getting-to-the-field"></a>Приступая к полю  
 С помощью любой коллекции ADO **элемент** свойство является свойством по умолчанию коллекции. Он возвращает отдельные **поле** объекта, указанного по имени или индексу, переданы в него. Таким образом, следующие инструкции эквивалентны для образца **записей**:  
  
```  
objField = objRecordset.Fields.Item("ProductID")  
objField = objRecordset.Fields("ProductID")  
objField = objRecordset.Fields.Item(0)  
objField = objRecordset.Fields(0)  
```  
  
 Если эти методы являются эквивалентными, который лучше? Смотря как. Использование индекса для получения **поле** из коллекции является быстрее, так как он обращается к **поле** непосредственно, без необходимости выполнять поиск строки. С другой стороны, порядок **поля** в коллекции должен быть известен, и если порядок изменения, ссылку на **поля** индексе будет везде, где оно происходит изменение. Несмотря на то что немного медленнее, используя имя **поле** является более гибкой, так как он не зависящим от порядка служб **поля** в коллекции.  
  
## <a name="using-the-refresh-method"></a>С помощью метода обновления  
 В отличие от некоторых других ADO коллекций, с помощью **обновление** метод **поля** сбора не имеет видимого эффекта. Чтобы получить изменения из базовой структуры базы данных, необходимо использовать **Requery** метода, или если **записей** объект не поддерживает закладки, **MoveFirst**метод, который вызывает команду, чтобы снова выполнять к поставщику.  
  
## <a name="adding-fields-to-a-recordset"></a>Добавление полей в наборе записей  
 **Append** метод используется для добавления полей к **записей**.  
  
 Можно использовать **Append** метод используется для **записей** программным путем без открытия соединения с источником данных. Ошибка во время выполнения возникает, если **Append** метод будет вызван на **поля** коллекции открытого **записей** или на **набора записей** где **ActiveConnection** свойства. Поля можно добавить только к **записей** , не открыт и еще не был подключен к источнику данных. Тем не менее чтобы задать значения для вновь добавленных **поля**, **записей** необходимо открыть.  
  
 Разработчики часто требуется место для временно сохранять некоторые данные, или некоторые данные должны работать, как если бы они поступали от сервера, может участвовать в привязке данных в пользовательском интерфейсе. ADO (вместе с [службы курсора для OLE DB Microsoft](../../../ado/guide/appendixes/microsoft-cursor-service-for-ole-db-ado-service-component.md)) позволяет разработчикам создавать пустой **записей** объекта, указав сведения о столбцах и вызов **откройте**. В следующем примере три новые поля добавляются в новую **записей** объекта. Затем **набора записей** открыт, два добавляются новые записи и **записей** сохраняется в файл. (Дополнительные сведения о **записей** сохраняемости, в разделе [обновление и сохранение данных](../../../ado/guide/data/updating-and-persisting-data.md).)  
  
```  
'BeginFabricate  
    Dim objRs As ADODB.Recordset  
    Set objRs = New ADODB.Recordset  
  
    With objRs.Fields  
        .Append "StudentID", adChar, 11, adFldUpdatable  
        .Append "FullName", adVarChar, 50, adFldUpdatable  
        .Append "PhoneNmbr", adVarChar, 20, adFldUpdatable  
    End With  
  
    With objRs  
        .Open  
  
        .AddNew  
        .Fields(0) = "123-45-6789"  
        .Fields(1) = "John Doe"  
        .Fields(2) = "(425) 555-5555"  
        .Update  
  
        .AddNew  
        .Fields(0) = "123-45-6780"  
        .Fields(1) = "Jane Doe"  
        .Fields(2) = "(615) 555-1212"  
        .Update  
    End With  
  
    objRs.Save App.Path & "FabriTest.adtg", adPersistADTG  
  
    objRs.Close  
'EndFabricate  
```  
  
 Использование **добавления полей** метод отличается от **записей** объекта и **записи** объекта. Дополнительные сведения о **запись** см. в разделе [записей и потоки](../../../ado/guide/data/records-and-streams.md).  
  
## <a name="see-also"></a>См. также:  
 [Fabricating иерархические наборы записей](../../../ado/guide/data/fabricating-hierarchical-recordsets.md)

