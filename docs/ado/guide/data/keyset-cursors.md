---
title: Управляемые набором ключей курсоры | Документы Microsoft
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.suite: sql
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- Keyset cursors [ADO]
- cursors [ADO], Keyset
ms.assetid: 14b51b17-6fd9-4146-af45-ca4b0fe6d48a
caps.latest.revision: 5
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 94df9cb54dcdb98b6f0932e63d0935b0350eb868
ms.sourcegitcommit: 62826c291db93c9017ae219f75c3cfeb8140bf06
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2018
ms.locfileid: "35271933"
---
# <a name="keyset-cursors"></a>Управляемые набором ключей курсоры
Курсор keyset предоставляет функциональные возможности между статический и динамический курсор в его способности обнаруживать изменения. Как статический курсор он не всегда обнаруживает изменения в членство и порядок результирующего набора. Как динамический курсор обнаруживать изменения значений строк в результирующем наборе.  
  
 Управляемые набором ключей курсоры управляются с помощью набора уникальных идентификаторов (ключи) — ключей. Ключи создаются из набора столбцов, который уникально идентифицирует строки результирующего набора. Ключей — это набор ключевых значений всех строк, возвращаемых оператором запроса.  
  
 С набором ключей курсоры ключ строится и сохраняются для каждой строки в курсор и хранится на клиентском компьютере или на сервере. При доступе к каждой строке, хранимого ключа используется для получения текущего значения данных из источника данных. В курсоре результирующий набор членства заморожен при набор ключей полностью заполнен. После этого добавления или обновления, которые влияют на членство не являются частью результирующего набора до его повторного открытия.  
  
 Изменения данных (сделать либо владельцем набора ключей или другие процессы) видимы, как пользователь прокручивает результирующего набора. Операции вставки, сделанные вне курсора (другие процессы) видимы только в том случае, если курсор закрыт и открыт повторно. Операции вставки, сделанных в курсор видимы в конце результирующего набора.  
  
 Когда курсор, управляемый набором ключей пытается извлечь строку, которая была удалена, строка отображается как «дыры» в результирующем наборе. Ключ для строк, существует в наборе ключей, но больше не существует строка в результирующем наборе. Если обновляются значения ключа в строку, строка считается удалению, а затем вставлены, поэтому такие строки также отображаются как отверстия в результирующем наборе. Хотя курсоры всегда может обнаружить строки, удаленные другим процессам, его можно удалить ключи для строк, которые она удаляет себя. Управляемые набором ключей курсоры, которые не удается обнаружить свои собственные операции удаления, поскольку свидетельство было удалено.  
  
 Обновление ключевого столбца действует аналогично удалению старого ключа последующей вставкой нового ключа. Новое значение ключа не отображается, если обновление не было выполнено через курсор. Если обновление было выполнено через курсор, новое значение ключа отображается в конце результирующего набора.  
  
 Нет вариантов на курсоры, вызывается стандартный курсоры. В стандартных курсоре фиксированных во время открытия курсора, но изменения, внесенные владельцем курсора членство строк в результирующем наборе и порядок строк и отображаются зафиксированные изменения, внесенные другими процессами. Если изменение disqualifies строку для членства или влияет на порядок строки, строки не исчезают или перемещать, если курсор закрыт и открыт повторно. Вставляемые данные не отображаются, но изменения в существующие данные отображаются как строки, выбранные.  
  
 Курсоры трудно правильно использовать, так как чувствительность к изменениям данных зависит от многих различных случаях, как описано выше. Тем не менее если приложение не отвечает за одновременных обновлений, можно программным образом обрабатывать неверные ключи и необходимо непосредственный доступ к определенные строки с ключом, управляемые набором ключей курсора может решить проблему. Используйте **adOpenKeyset CursorTypeEnum** для указания, что вы хотите использовать курсоры в ADO.  
  
## <a name="see-also"></a>См. также  
 [Однопроходные курсоры](../../../ado/guide/data/forward-only-cursors.md)   
 [Статические курсоры](../../../ado/guide/data/static-cursors.md)   
 [Динамические курсоры](../../../ado/guide/data/dynamic-cursors.md)
