---
title: Проблемы производительности драйвера для настольных баз данных | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- ODBC desktop database drivers [ODBC], performance
- desktop database drivers [ODBC], performance
- Jet-based ODBC drivers [ODBC], performance
ms.assetid: 1a4c4b7e-9744-411f-9b6e-06dfdad92cf7
caps.latest.revision: 6
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 73261681421546dcec4cd37d73b1cdf55968038e
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="desktop-database-driver-performance-issues"></a>Проблемы производительности драйвера для настольных баз данных
Чтобы обеспечить совместимость с существующими приложениями ANSI, типы данных SQL_WCHAR, SQL_WVARCHAR и SQL_WLONGVARCHAR предоставляется как SQL_CHAR, SQL_VARCHAR и SQL_LONGVARCHAR Microsoft Access 4.0 или более источников данных. Источники данных не возвращают CHAR РАСШИРЕННЫХ типов данных, но данные по-прежнему должны отправляться Jet в форме широкий Char. Важно понимать, что преобразование будет выполнено при передаче SQL_C_CHAR параметра или результата привязанного столбца с типом данных SQL_CHAR в приложении ANSI.  
  
 Это преобразование может быть особенно неэффективно с точки зрения памяти, если тип SQL_C_CHAR, привязанный к параметру типа LONGVARCHAR. Поскольку ядра Jet 4.0 не удалось потока данных параметра LONGTEXT, буфер преобразования ЮНИКОДА должен быть выделен, будет двойной размер буфера SQL_C_CHAR ANSI. Приложение может выполнить преобразование Юникод и привязать параметр в качестве типа SQL_C_WCHAR представляет собой наиболее эффективный механизм. Если параметр помечен как данные времени выполнения, то данные передаются в нескольких вызовах SQLPutData longtext буфер данных увеличивается. Один из способов избежать затрат на увеличение этого буфера «Поместить данные» является предоставление длины через SQL_DATA_AT_EXEC_LEN(x), где *x* ожидаемая длина байтов. Это будет инициализировать размер внутреннего буфера PutData для *x* байт.  
  
> [!NOTE]  
>  Наиболее эффективный способ вставки или обновления данных большой длины может выполняться с помощью **SQLBulkOperations()** или **SQLSetPos()** и задание длинных данных в значение SQL_DATA_AT_EXEC. (EXEC_LEN игнорируется в данном случае). Данные может передаваться в виде фрагментов, вызвав **SQLPutData** несколько раз, который фактически данные будут добавляться в таблицу.  
  
 При обновлении приложения с помощью базы данных Jet 3.5 через Microsoft драйверов ODBC базы данных до версии 4.0, может возникнуть некоторое снижение производительности и увеличения размера рабочего множества. Это, поскольку при наличии версии 3. *x* открыть базу данных с помощью нового драйвера версии 4.0, он загружает Jet 4.0. При открытии базы данных Jet 4.0 и видит, что базы данных равно 3. *x* версии, он загружает драйвер устанавливаемый ISAM, эквивалентно загрузке ядро Jet 3.5. Чтобы удалить снижение производительности и размер, Jet 3. *x* следует сжатие базы данных в формат базы данных Jet 4.0. Это устранить загрузке два ядра Jet и свести к минимуму код пути к данным.  
  
 Кроме того ядро Jet 4.0 — это механизм Юникода. Все строки хранения и управления данными в Юникоде. Приложение ANSI при доступе к Jet 3. *x* базы данных с помощью ядра Jet 4.0, данные преобразуются из ANSI в Юникод и обратно в ANSI. Если база данных обновляется до формата версии 4.0, строки преобразуются в Юникод, удаление одного уровня преобразование строк, а также к минимуму код пути к данным через только одно ядро Jet.
