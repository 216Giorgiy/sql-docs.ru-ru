---
title: ВЫБЕРИТЕ - команда SQL | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- select [ODBC]
ms.assetid: 2149c3ca-3a71-446d-8d53-3d056e2f301a
caps.latest.revision: 7
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 69b3d6bd8330ff5a1ba85ba1da1a7b6f3a3cc26a
ms.sourcegitcommit: 2ddc0bfb3ce2f2b160e3638f1c2c237a898263f4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="select---sql-command"></a>ВЫБЕРИТЕ - команда SQL
Извлекает данные из одной или нескольких таблиц.  
  
 Драйвер ODBC для Visual FoxPro поддерживает собственный синтаксис языка Visual FoxPro для этой команды. Относящиеся к драйверу сведения см. в разделе **примечания драйвер**.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SELECT [ALL | DISTINCT]  
   [Alias.] Select_Item [AS Column_Name]  
   [, [Alias.] Select_Item [AS Column_Name] ...]   
FROM [DatabaseName!]Table [Local_Alias]  
   [, [DatabaseName!]Table [Local_Alias] ...]   
[WHERE JoinCondition [AND JoinCondition  
…]  
   [AND | OR FilterCondition [AND | OR FilterCondition ...]]]  
[GROUP BY GroupColumn [, GroupColumn ...]]  
[HAVING FilterCondition]  
[UNION [ALL] SELECTCommand]  
[ORDER BY Order_Item [ASC | DESC] [, Order_Item [ASC | DESC] ...]]  
```  
  
## <a name="arguments"></a>Аргументы  
  
> [!NOTE]  
>  Объект *вложенный запрос*, в следующих аргументах, является выбор в инструкцию SELECT и должен быть заключен в круглые скобки. Может иметь более двух вложенных запросов на том же уровне (не вложенные) в предложении WHERE. (См. Этот раздел аргументов). Вложенные запросы могут содержать несколько условий соединения.  
  
 [Все &#124; DISTINCT]   [*Псевдоним*.] *Select_Item* [AS *Column_Name*] [, [*псевдоним*.] *Select_Item* [AS *Column_Name*]...]  
 Предложение SELECT задает поля, констант и выражений, которые отображаются в результатах запроса.  
  
 По умолчанию все отображаются все строки в результатах запроса.  
  
 Ключевое слово DISTINCT удаляет дубликаты строк из результатов запроса.  
  
> [!NOTE]  
>  Можно использовать ключевое слово DISTINCT только один раз в предложении SELECT.  
  
 *Псевдоним*. Определяет сопоставления имен элементов. Каждый элемент, указанный с *Select_Item* формирует по одному столбцу результатов запроса. Если два или более элементов имеют то же имя, включать псевдоним таблицы и точку перед именем элемента, чтобы предотвратить дублирование столбцов.  
  
 *Select_Item* указывает элемент для включения в результаты запроса. Элемент может быть одним из следующих:  
  
-   Имя поля из таблицы в предложении FROM.  
  
-   Константа, указывающая, что то же постоянное значение будет отображаться в каждую строку в результатах запроса.  
  
-   Выражение, которое может быть имя определяемой пользователем функции.  
  
 **Определяемые пользователем функции с помощью SELECT**  
  
 Хотя использование определяемых пользователем функций в предложении SELECT имеет очевидные преимущества, необходимо учитывать следующие ограничения:  
  
-   Скорость операций, выполняемых с помощью SELECT могут быть ограничены по частоте, с которой выполняются такие функции, определяемой пользователем. Большого объема операций с определяемой пользователем функции можно реализовать лучше с помощью API и определяемые пользователем функции, написанные на C или языка ассемблера.  
  
-   Единственный надежный способ передачи значений определяемые пользователем функции, вызываемые из SELECT предусмотрено список аргументов, переданных в функцию при ее вызове.  
  
-   Даже в том случае, если поэкспериментировать и определить предположительно запрещенных манипуляции, работает правильно, в версии FoxPro, нет никакой гарантии, которые она будет продолжать работать в более поздних версиях.  
  
 Помимо эти ограничения определяемые пользователем функции являются допустимыми в предложении SELECT. Однако следует помните, что использование SELECT может снизить производительность.  
  
 Следующие функции, поля, можно использовать в элементе выбора, поле или выражение, включающее поля:  
  
-   AVG (*Select_Item*) — вычисляет среднее значение столбца числовых данных.  
  
-   COUNT (*Select_Item*) — подсчитывает количество элементов, выберите в столбце. Функция Count(*) подсчитывает число строк в выходных данных запроса.  
  
-   MIN (*Select_Item*) — определяет наименьшее значение *Select_Item* в столбце.  
  
-   MAX (*Select_Item*) — определяет наибольшее значение *Select_Item* в столбце.  
  
-   SUM (*Select_Item*) — суммирует столбец числовых данных.  
  
 Не удается вложить функции полями.  
  
 AS *Column_Name*  
 Указывает заголовок столбца в выходных данных запроса. Это полезно, когда *Select_Item* выражения или поля содержит функции и вы хотите дать понятное имя столбца. *Column_Name* может быть выражением, но не может содержать символы (например, пробелы), которые не разрешены в именах полей таблицы.  
  
 ИЗ [*DatabaseName*!] *Таблицы* [*Local_Alias*] [, [*DatabaseName*!] *Таблицы* [*Local_Alias*]...]  
 Список таблиц, содержащих данные из запроса. Если таблицы не открыт, Visual FoxPro отображает **откройте** диалоговым окном, можно указать расположение файла. После его открытия таблицы остается открытым после завершения запроса.  
  
 *Имя базы данных*! Указывает имя базы данных, отличный от указанного в источнике данных. Необходимо включить имя базы данных, содержащую таблицу, если база данных не указана с источником данных. Включить в разделители восклицательный знак (!), имя базы данных и имя таблицы.  
  
 *Local_Alias* имя временной таблицы, указанной в *таблицы*. Если указан локальный псевдоним, необходимо использовать локальный псевдоним вместо имени таблицы в инструкции SELECT. Локальный псевдоним не влияет на среду Visual FoxPro.  
  
 ГДЕ *условия JoinCondition* [AND *условия JoinCondition* ...]    [AND &#124; или *FilterCondition* [AND &#124; или *FilterCondition* ...]]  
 Сообщает Visual FoxPro для включения записи в результатах запроса. ГДЕ необходим для получения данных из нескольких таблиц.  
  
 *Условия JoinCondition* определяет поля, связывающие таблицы в предложении FROM. При включении нескольких таблиц в запросе необходимо указать условие соединения для каждой таблицы после первого.  
  
> [!IMPORTANT]  
>  При создании условия соединения, необходимо учесть следующее:  
  
-   Если указать две таблицы в запросе и задают условие соединения, каждая запись в первой таблице соединяется с каждой записи во второй таблице при условии, что условий фильтра. Такой запрос может привести к результатам длительное время.  
  
-   Будьте осторожны при соединении таблиц с пустыми полями, поскольку Visual FoxPro соответствует пустые поля. Например, если соединение таблицы CUSTOMER. ZIP-архив и выставления счета. ZIP-архив, и если клиент содержит 100 пустой почтовых индексов, а счета 400 пустой почтовых индексов, результат запроса содержит 40 000 дополнительных записей, возникающие в результате пустые поля. Используйте **(пустой)** функции, чтобы исключить пустые записи из выходных данных запроса.  
  
-   Необходимо использовать оператор AND для подключения несколько условий соединения. Каждое условие соединения имеет следующий вид:  
  
     *Сравнение FieldName2 FieldName1*  
  
     *FieldName1* имя поля из одной таблицы *FieldName2* имя поля из другой таблицы и *сравнения* является одним из операторов, описанные в следующей таблице.  
  
|Оператор|Сравнение|  
|--------------|----------------|  
|=|Равно|  
|==|Точно равно|  
|LIKE|SQL, ТАКИХ КАК|  
|<>, !=, #|Не равно|  
|>|Больше|  
|>=|Больше или равно|  
|<|Меньше чем|  
|<=|Меньше или равно|  
  
 При использовании оператора = со строками, она действует по-разному, в зависимости от параметра SET ANSI. После SET ANSI имеет значение OFF, Visual FoxPro обрабатывает сравнения строк в определенном знакомы пользователям Xbase. Если SET ANSI имеет значение ON, Visual FoxPro соответствует стандартам ANSI для сравнения строк. В разделе [SET ANSI](../../odbc/microsoft/set-ansi-command.md) и [ЗАДАТЬ ТОЧНОЕ](../../odbc/microsoft/set-exact-command.md) Дополнительные сведения о том, как Visual FoxPro выполняет сравнение строк.  
  
 *FilterCondition* указывает критерии, которые должны удовлетворять записи, которые будут включены в результаты запроса. Можно включить столько условий в запросе фильтрации, сколько требуется, подключив их с AND или оператор OR. Оператор NOT можно использовать и для отмены значения логического выражения, или можно использовать **(пустой)** для проверки пустого поля. *FilterCondition* можно использовать любой из форм в следующих примерах:  
  
 **Пример 1** *FieldName2 FieldName1 сравнения*  
  
 `customer.cust_id = orders.cust_id`  
  
 **Пример 2** *выражения сравнения FieldName*  
  
 `payments.amount >= 1000`  
  
 **Пример 3** *сравнения FieldName* все (*вложенный запрос*)  
  
 `company < ALL ;`  
  
 `(SELECT company FROM customer WHERE country = "USA")`  
  
 Когда условие фильтра включает все, это поле должно удовлетворять условиям сравнения для всех значений, созданных вложенный запрос перед ее записью включается в результаты запроса.  
  
 **Пример 4** *сравнения FieldName* ANY &#124; SOME (*вложенный запрос*)  
  
 `company < ANY ;`  
  
 `(SELECT company FROM customer WHERE country = "USA")`  
  
 Когда условие фильтра включает НЕКОТОРЫЕ или все, это поле должно удовлетворять условиям сравнения для по крайней мере одно из значений, сформированных вложенным запросом.  
  
 Следующий пример проверяет, находятся ли значения в поле в указанный диапазон значений:  
  
 **Пример 5** *FieldName* [NOT] BETWEEN *Start_Range* AND *End_Range*  
  
 `customer.postalcode BETWEEN 90000 AND 99999`  
  
 Следующий пример проверяет, является ли хотя бы одна строка соответствует критериям во вложенном запросе. Если условие фильтра содержит EXISTS, условие фильтра равно True (. T.) пока вложенный запрос не станет пустой набор.  
  
 **Пример 6** [NOT] СУЩЕСТВУЕТ (*вложенный запрос*)  
  
 `EXISTS ;`  
  
 `(SELECT * FROM orders WHERE customer.postalcode =`  
  
 `orders.postalcode)`  
  
 **Пример 7** *FieldName* [NOT] IN *Value_Set*  
  
 `customer.postalcode NOT IN ("98052","98072","98034")`  
  
 Если условие фильтра содержит IN, объектов поле должно содержать одно из значений перед ее записью включается в результаты запроса.  
  
 **Пример 8** *FieldName* [NOT] IN (*вложенный запрос*)  
  
 `customer.cust_id IN ;`  
  
 `(SELECT orders.cust_id FROM orders WHERE orders.city="Seattle")`  
  
 Здесь поле должно содержать одно из значений, возвращенных вложенным запросом, перед ее записью включается в результаты запроса.  
  
 **Пример 9** *FieldName* [NOT] LIKE *cExpression*  
  
 `customer.country NOT LIKE "USA"`  
  
 Выполняет поиск данное условие фильтра для каждого поля, которое соответствует *cExpression*. Знак процента (%) и символы подчеркивания (_) можно использовать как часть *cExpression*. Символ подчеркивания представляет неизвестный символ в строке.  
  
 Предложение GROUP BY *GroupColumn* [, *GroupColumn* ...]  
 Группы строк в запросе на основе значений в один или несколько столбцов. *GroupColumn* может принимать одно из следующих действий:  
  
-   Имя поля обычной таблицы.  
  
-   Поле, которое содержит поле функцию SQL.  
  
-   Числовое выражение, указывающее положение столбца в таблице результатов. (Крайний слева столбец имеет номер 1.)  
  
 НАЛИЧИЕ *FilterCondition*  
 Указывает условие фильтра, которому должно соответствовать групп для включения в результаты запроса. HAVING, следует использовать с предложением GROUP BY и может содержать столько условий фильтрации, сколько требуется, соединенных AND или оператор OR. Также можно использовать не для того, чтобы изменить значения логического выражения.  
  
 *FilterCondition* не может содержать вложенный запрос.  
  
 Предложение HAVING без предложения GROUP BY ведет себя как предложение WHERE. Локальный псевдонимы и функции, поля можно использовать в предложении HAVING. Используется предложение WHERE для повышения производительности, если функции не поле содержит вашего предложения HAVING.  
  
 [[Все] ОБЪЕДИНЕНИЕ *SELECTCommand*]  
 Объединяет окончательные результаты, выберите один с окончательные результаты, выберите другое. По умолчанию UNION проверяет объединенные результаты и позволяет удалить повторяющиеся строки. Используйте круглые скобки для объединения нескольких ОБЪЕДИНЕНИЯ предложений.  
  
 ВСЕ запрещает исключая повторяющиеся строки из комбинированного результата UNION.  
  
 Предложения UNION следуют следующим правилам.  
  
-   UNION нельзя использовать для объединения вложенных запросов.  
  
-   Обе команды SELECT должен иметь одинаковое число столбцов в свои выходные данные запроса.  
  
-   Каждый столбец в результатах запроса, выберите один должен иметь один и тот же тип данных и ширина соответствующего столбца в другой инструкции SELECT.  
  
-   Только окончательный ВЫБЕРИТЕ может включать предложение ORDER BY, который должен ссылаться на выходные столбцы, по номеру. Если предложение ORDER BY, она влияет на полный результат.  
  
 Можно также использовать предложения UNION для моделирования внешнего соединения.  
  
 При соединении двух таблиц в запросе только записи с совпадающими значениями в полях присоединяемый включаются в выходные данные. Если записи в родительской таблице нет соответствующей записи в дочерней таблице, запись в родительской таблице не включена в выходных данных. Внешнее соединение позволяет включить все записи в родительской таблице в выходных данных вместе с совпадающих записей в дочерней таблице. Чтобы создать внешнее соединение в Visual FoxPro, необходимо использовать вложенные команды SELECT, как показано в следующем примере:  
  
```  
SELECT customer.company, orders.order_id, orders.emp_id ;  
FROM customer, orders ;  
WHERE customer.cust_id = orders.cust_id ;  
UNION ;  
SELECT customer.company, 0, 0 ;  
FROM customer ;  
WHERE customer.cust_id NOT IN ;  
(SELECT orders.cust_id FROM orders)  
```  
  
> [!NOTE]  
>  Убедитесь, что включены пространство, которое находится непосредственно перед каждой точкой с запятой. В противном случае возникает ошибка.  
  
 В части команды перед предложения UNION выбирает записи из обеих таблиц, иметь совпадающие значения. Компаний клиентов, у которых нет связанного счета не включаются. Раздел команды после предложения UNION Выбор записей в таблице клиентов, которые не имеют совпадающих записей в таблице orders.  
  
 О второй сегмент команды Обратите внимание на следующее:  
  
-   Инструкция SELECT в круглых скобках обрабатывается первым. Эта инструкция создает выделение всех номеров клиента в таблице orders.  
  
-   Предложение WHERE находит все числа клиентов в таблице customer, которых нет в таблице orders. Так как в первой части команды указано всех компаний, которые имели номер клиента в таблице orders, всех компаний в таблице customer теперь включены в результаты запроса.  
  
-   Так как структуры таблиц, включенных в ОБЪЕДИНЕНИИ должны быть идентичными, существует два заполнителей во второй инструкции SELECT для представления *orders.order_id* и *orders.emp_id* из первой инструкции SELECT инструкция.  
  
    > [!NOTE]  
    >  Заполнители должен быть того же типа как поля, которые они представляют. Если поле имеет тип date, должен быть заполнитель {/ /}. Если поле является полем символ, заполнитель должна быть пустой строкой (»»).  
  
 УПОРЯДОЧИТЬ по *Order_Item* [ASC &#124; DESC] [, *Order_Item* [ASC &#124; DESC]...]  
 Сортировка результатов запроса на основе данных в одном или нескольких столбцах. Каждый *Order_Item* должен соответствовать столбцу в результатах запроса и может принимать одно из следующих действий:  
  
-   Поле в таблице FROM, который также является элемент select в предложении SELECT основной (не во вложенном запросе).  
  
-   Числовое выражение, указывающее положение столбца в таблице результатов. (Крайний слева столбец имеет номер 1.)  
  
 ASC задает порядок по возрастанию для результатов запроса, в соответствии с порядок элементов или элементы и значение по умолчанию для ORDER BY.  
  
 DESC указывает по убыванию для результатов запроса.  
  
 Результаты запроса отображаются неупорядоченных, если заказ не указан вместе с ORDER BY.  
  
## <a name="remarks"></a>Замечания  
 SELECT является команду SQL, который встроен в компонент Visual FoxPro, как и любые другие команды Visual FoxPro. При использовании ВЫБЕРИТЕ, чтобы представлять запрос, Visual FoxPro интерпретирует запрос и получает указанные данные из таблиц. Можно создать запрос SELECT из в окне командной строки или программы Visual FoxPro (как и любые другие команды Visual FoxPro).  
  
> [!NOTE]  
>  ВЫБЕРИТЕ не влияют на текущее условие фильтра, указанный с УСТАНОВИТЬ фильтр.  
  
## <a name="driver-remarks"></a>Драйвер примечания  
 Когда приложение отправляет инструкция ODBC SQL SELECT с источником данных, драйвер ODBC для Visual FoxPro преобразует команды в Visual FoxPro ВЫБЕРИТЕ команду без преобразования, если команда содержит escape-последовательность ODBC. Элементы, заключенные в escape-последовательности ODBC преобразуются в синтаксисе Visual FoxPro. Дополнительные сведения об использовании ODBC escape-последовательности см. в разделе [функции даты и времени](../../odbc/microsoft/time-and-date-functions-visual-foxpro-odbc-driver.md) и в *Справочник по программированию ODBC Microsoft*, в разделе [Escape-последовательности ODBC](../../odbc/reference/develop-app/escape-sequences-in-odbc.md) .  
  
## <a name="see-also"></a>См. также  
 [СОЗДАНИЕ ТАБЛИЦЫ - SQL](../../odbc/microsoft/create-table-sql-command.md)   
 [INSERT - SQL](../../odbc/microsoft/insert-sql-command.md)   
 [SET ANSI](../../odbc/microsoft/set-ansi-command.md)   
 [ТОЧНЫЙ НАБОР](../../odbc/microsoft/set-exact-command.md)
