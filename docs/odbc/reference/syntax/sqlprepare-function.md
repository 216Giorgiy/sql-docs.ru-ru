---
title: "Функция SQLPrepare | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- drivers
ms.tgt_pltfrm: 
ms.topic: article
apiname:
- SQLPrepare
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLPrepare
helpviewer_keywords:
- SQLPrepare function [ODBC]
ms.assetid: 332e1b4b-b0ed-4e7a-aa4d-4f35f4f4476b
caps.latest.revision: 23
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.translationtype: MT
ms.sourcegitcommit: f7e6274d77a9cdd4de6cbcaef559ca99f77b3608
ms.openlocfilehash: 2bdb9a85c14f3636286ea9ca97ea173c9c2b65a4
ms.contentlocale: ru-ru
ms.lasthandoff: 09/09/2017

---
# <a name="sqlprepare-function"></a>Функция SQLPrepare
**Соответствия**  
 Появился в версии: Полное соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLPrepare** готовит строку SQL для выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLPrepare(  
     SQLHSTMT      StatementHandle,  
     SQLCHAR *     StatementText,  
     SQLINTEGER    TextLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *StatementText*  
 [Вход] Строка текста SQL.  
  
 *TextLength*  
 [Вход] Длина **StatementText* в символах.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLPrepare** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_ HANDLE_STMT и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLPrepare** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменено|Атрибут указанного оператора недопустимый из-за условий работы реализации, поэтому был временно заменены примерно такое же значение. (**SQLGetStmtAttr** может вызываться для определения временно подставляемого значения.) Заменяющее значение допустимо для *StatementHandle* до закрытия курсора. Атрибуты инструкции, которые могут быть изменены представляют собой: SQL_ATTR_CONCURRENCY SQL_ATTR_CURSOR_TYPE атрибута SQL_ATTR_KEYSET_SIZE значения SQL_ATTR_MAX_LENGTH SQL_ATTR_MAX_ROWS SQL_ATTR_QUERY_TIMEOUT SQL_ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|21S01|Список вставляемых значений не соответствует списку столбцов|\**StatementText* содержится **вставить** инструкции и число значений для вставки не совпали степень производной таблицы.|  
|21S02|Структура полученной таблицы не соответствуют списку столбцов|\**StatementText* содержится **CREATE VIEW** инструкции и количество указанных имен не имеет тот же угол производную таблицу, определенных в спецификации запроса.|  
|22018|Недопустимое символьное значение для спецификации приведения|**StatementText* содержали инструкцию SQL, в котором содержится литералом или параметром, а значение было несовместимо с типом данных столбца связанные таблицы.|  
|22019|Недопустимый escape-символ|Аргумент *StatementText* содержится **как** предиката с **ESCAPE** в **ГДЕ** предложение, а длина escape Следующий символ **ESCAPE-** было не равно 1.|  
|22025|Недопустимая escape-последовательность|Аргумент *StatementText* содержится «**как** *значение шаблона* **ESCAPE** *escape-символ*» в **ГДЕ** предложение, а символ после escape-символ в значение шаблона было не «%» и «_».|  
|24000|Недопустимое состояние курсора|(DM) курсор был открыт на *StatementHandle*, и **SQLFetch** или **SQLFetchScroll** бы была вызвана.<br /><br /> Курсор был открыт на *StatementHandle*, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|34000|Недопустимое имя курсора|\**StatementText* содержится позиционированные **удаление** или выполнение нацеленных **обновление**, и не был открыт курсор, указанный в подготавливаемой инструкции.|  
|3D000|Недопустимое имя каталога|Имя каталога, указанное в *StatementText* недопустим.|  
|3F000|Недействительное имя схемы|Имя схемы, указанной в *StatementText* недопустим.|  
|42000|Синтаксическая ошибка или нарушение доступа|\**StatementText* содержали инструкцию SQL, не доступный для подготовки или содержит синтаксическую ошибку.<br /><br /> **StatementText* содержит инструкцию, для которого пользователь не имеет необходимых привилегий.|  
|42S01|Базовая таблица или представление уже существует|\**StatementText* содержится **CREATE TABLE** или **CREATE VIEW** инструкции и имя таблицы или представления с указанным именем уже существует.|  
|42S02|Базовая таблица или представление не найдены|\**StatementText* содержится **DROP TABLE** или **DROP VIEW** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **ALTER TABLE** инструкции и указанного имени таблицы не существует.<br /><br /> \**StatementText* содержится **CREATE VIEW** инструкции и имя таблицы или представления, имя, определенное в спецификации запроса не существует.<br /><br /> \**StatementText* содержится **CREATE INDEX** инструкции и указанного имени таблицы не существует.<br /><br /> \**StatementText* содержится **GRANT** или **ОТОЗВАТЬ** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **ВЫБЕРИТЕ** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **удаление**, **вставить**, или **обновление** инструкции и указанного имени таблицы не существует.<br /><br /> \**StatementText* содержится **CREATE TABLE** инструкции и таблицы, указанной в ограничении (ссылка на таблицу отличный от созданном) не существует.|  
|42S11|Индекс уже существует|\**StatementText* содержится **CREATE INDEX** инструкции и индекс с указанным именем уже существует.|  
|42S12|Индекс не найден|\**StatementText* содержится **DROP INDEX** инструкции и индекс с указанным именем не существует.|  
|42S21|Столбец уже существует|\**StatementText* содержится **ALTER TABLE** инструкции и столбец, указанный в **добавить** предложения не является уникальным или идентифицирует существующего столбца в базовой таблице.|  
|42S22|Столбец не найден|\**StatementText* содержится **CREATE INDEX** инструкции и один или несколько столбцов, имена, указанные в списке столбцов не существует.<br /><br /> \**StatementText* содержится **GRANT** или **ОТОЗВАТЬ** оператор и с определенным названием столбца не существует.<br /><br /> \**StatementText* содержится **ВЫБЕРИТЕ**, **удаление**, **вставить**, или **обновление** инструкции и указанного столбца Имя не существует.<br /><br /> \**StatementText* содержится **CREATE TABLE** инструкции и столбец, указанный в ограничении (ссылка на таблицу отличный от созданном) не существует.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в * \*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*, и затем вызова функции еще раз на *StatementHandle*.<br /><br /> Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY009|Недопустимое использование пустого указателя|(DM) *StatementText* является пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом асинхронной функция **SQLPrepare** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ЭТОТ ПАРАМЕТР ДОСТУПЕН. До получения данных для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для * StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) аргумент *TextLength* было меньше или равно 0, но не равно SQL_NTS.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Для типа курсора, определенного недопустимый параметр параллелизма.<br /><br /> Атрибут инструкции SQL_ATTR_USE_BOOKMARKS было задано значение SQL_UB_VARIABLE, а атрибут инструкции SQL_ATTR_CURSOR_TYPE был задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания истекло до источник данных вернул результирующий набор. Время ожидания задается с помощью **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
  
## <a name="comments"></a>Комментарии  
 Приложение вызывает **SQLPrepare** для отправки в источник данных для подготовки инструкции SQL. Дополнительные сведения о выполнении подготовленной см. в разделе [подготовленных](../../../odbc/reference/develop-app/prepared-execution-odbc.md). Приложение может включать один или несколько маркеров параметров в инструкции SQL. Чтобы включить маркер параметра, приложение внедряет знак вопроса (?) в строки SQL в соответствующей позиции. Сведения о параметрах см. в разделе [параметров инструкции](../../../odbc/reference/develop-app/statement-parameters.md).  
  
> [!NOTE]  
>  Если приложение использует **SQLPrepare** для подготовки и **SQLExecute** для отправки **ЗАФИКСИРОВАТЬ** или **ОТКАТА** инструкции, он не будет взаимодействие между СУБД. Чтобы зафиксировать или откатить транзакцию, вызвать **SQLEndTran**.  
  
 Драйвер можно изменить инструкцию, чтобы использовать форму SQL, используемая источником данных и затем отправить его на источник данных для подготовки. В частности драйвер изменяет escape-последовательности, используемое для определения синтаксиса SQL для некоторых компонентов. (Описание грамматику SQL инструкции см. [Escape-последовательностей в ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md) и [грамматику SQL приложение C:](../../../odbc/reference/appendixes/appendix-c-sql-grammar.md).) Для драйвера дескриптор инструкции аналогична идентификатор инструкции во внедренном коде SQL. Если источник данных поддерживает оператор идентификаторы, драйвер может отправлять идентификатор инструкции и значения параметров источника данных.  
  
 После подготовки инструкции приложение использует дескриптор инструкции для ссылки на инструкции в последующих вызовах функции. Подготовленной инструкции, связанные с дескриптором инструкции могут выполняться повторно путем вызова **SQLExecute** пока приложение освобождает инструкцию с помощью вызова **SQLFreeStmt** с параметром SQL_DROP или пока дескриптора инструкции используется при обращении к **SQLPrepare**, **SQLExecDirect**, или одна из функций каталога (**SQLColumns**, ** SQLTables**и так далее). Как только приложение подготавливает инструкцию, оно может запросить сведения о формате результирующего набора. Для некоторых реализаций, вызвав **SQLDescribeCol** или **SQLDescribeParam** после **SQLPrepare** может не быть столь же эффективна, как и вызов функции после **SQLExecute** или **SQLExecDirect**.  
  
 Некоторые драйверы не может возвращать синтаксических ошибок или нарушений прав доступа, когда приложение вызывает **SQLPrepare**. Драйвер можно обрабатывать ошибки синтаксиса и нарушение прав доступа только ошибки синтаксиса или синтаксических ошибок ни нарушения прав доступа. Таким образом, приложения должен быть способен обрабатывать эти условия, при последующих вызовах функции, связанные с такими как **SQLNumResultCols**, **SQLDescribeCol**, **SQLColAttribute**, и **SQLExecute**.  
  
 В зависимости от возможностей драйвера и источника данных сведения о параметрах (например, типы данных) могут проверяться при подготовке инструкции (если все параметры были привязаны) или при его выполнении (если все параметры не были привязаны). Для максимальной совместимости приложение должно разорвать связи всех параметров, которые применялись к старой инструкции SQL перед подготовкой новой инструкции SQL в одной инструкции. Это позволяет избежать ошибок, из-за старые сведения о параметрах, применяемых к новой инструкции.  
  
> [!IMPORTANT]  
>  Фиксация транзакции, либо путем явного вызова **SQLEndTran** или при работе в режиме автоматической фиксации, могут привести к источнику данных для удаления планов доступ для всех инструкций в соединении. Дополнительные сведения см. в разделе типы информации SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR в [SQLGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md) и [влияние транзакций на курсоры и подготовленных инструкций](../../../odbc/reference/develop-app/effect-of-transactions-on-cursors-and-prepared-statements.md).  
  
## <a name="code-example"></a>Пример кода  
 В разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выделение дескриптора инструкции|[Функция SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)|  
|Привязка к столбцу в результирующем наборе буфера|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Привязка буфер к параметру|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнения подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Возвращает число строк, затронутых инструкцией|[Функция SQLRowCount](../../../odbc/reference/syntax/sqlrowcount-function.md)|  
|Имя курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
