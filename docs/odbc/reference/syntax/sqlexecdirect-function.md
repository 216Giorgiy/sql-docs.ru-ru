---
title: "SQLExecDirect, функция | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- drivers
ms.tgt_pltfrm: 
ms.topic: article
apiname:
- SQLExecDirect
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLExecDirect
helpviewer_keywords:
- SQLExecDirect function [ODBC]
ms.assetid: 985fcee1-f204-425c-bdd1-deb0e7d7bbd9
caps.latest.revision: 26
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: On Demand
ms.translationtype: MT
ms.sourcegitcommit: f7e6274d77a9cdd4de6cbcaef559ca99f77b3608
ms.openlocfilehash: fdf6183eda2b66263a8ff27664d046640b94ea95
ms.contentlocale: ru-ru
ms.lasthandoff: 09/09/2017

---
# <a name="sqlexecdirect-function"></a>SQLExecDirect, функция
**Соответствия**  
 Появился в версии: Полное соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLExecDirect** выполняет отлаживаемую инструкцию, используя текущие значения переменных маркера параметра в том случае, если существует параметров в инструкции. **SQLExecDirect** является самым быстрым способом передачи инструкции SQL для однократного выполнения.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLExecDirect(  
     SQLHSTMT     StatementHandle,  
     SQLCHAR *    StatementText,  
     SQLINTEGER   TextLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *StatementText*  
 [Вход] Выполнение инструкции SQL.  
  
 *TextLength*  
 [Вход] Длина **StatementText* в символах.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, SQL_ERROR, значение SQL_NO_DATA, SQL_INVALID_HANDLE или SQL_PARAM_DATA_AVAILABLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLExecDirect** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* значение sql_handle_stmt и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLExecDirect** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01001|Конфликт операции с курсором|\**StatementText* автономной позиционированные обновления или удаления инструкции, и ни одной строки или более одной строки были обновлены или удалены. (Дополнительные сведения об обновлениях для более чем одной строке см. в описании SQL_ATTR_SIMULATE_CURSOR *атрибута* в **SQLSetStmtAttr**.)<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01003|Функция set не поддерживает значение NULL|Аргумент *StatementText* содержится функцию set (такие как **AVG**, **MAX**, **MIN**и так далее), но не **COUNT ** функции и значения были устранены до применения функции аргумент NULL. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Строка справа усечение данных|Строка или двоичные данные, возвращаемые для ввода вывода или выходной параметр привело к усечению непустых символьных или двоичных данных от NULL. Если он был строковое значение, было усечено справа. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01006|Привилегия не отменена|\**StatementText* содержится **ОТОЗВАТЬ** инструкции и пользователь не предоставлено указанной прав. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01007|Не предоставлено право доступа|*\*StatementText* было **GRANT** инструкции и пользователь не может предоставляться указанного прав доступа.|  
|01S02|Значение параметра изменено|Атрибут указанного оператора недопустимый из-за условий работы реализации, поэтому был временно заменены примерно такое же значение. (**SQLGetStmtAttr** может вызываться для определения временно подставляемого значения.) Заменяющее значение допустимо для *StatementHandle* до закрытия курсора, после чего атрибут инструкции восстанавливает прежнее значение. Перечислены атрибуты инструкции, которые могут быть изменены.<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S07|Частичное усечение|Данные возвращаются для ввода вывода или выходной параметр был усечен таким образом, что дробная часть числовой тип данных был усечен или усеченные дробной части числа компонент тип данных времени, отметка времени или интервала времени.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07002|Неправильное поле COUNT|Число параметров, указанных в **SQLBindParameter** меньше, чем число параметров в инструкции SQL, содержащейся в \* *StatementText*.<br /><br /> **SQLBindParameter** был вызван с *ParameterValuePtr* значение является пустым указателем, *StrLen_or_IndPtr* не присвоено значение SQL_NULL_DATA или значение SQL_DATA_AT_EXEC, а * InputOutputType* не заданы для SQL_PARAM_OUTPUT, поэтому указанное число параметров в **SQLBindParameter** превышает число параметров в инструкции SQL, содержащейся в **StatementText*.|  
|07006|Нарушение атрибута ограниченного типа данных|Значение определяется *ValueType* аргумент в **SQLBindParameter** для связанных параметров не удалось преобразовать в тип данных, определяемый *ParameterType*аргумент в **SQLBindParameter**.<br /><br /> Возвращаемое значение данных для параметра, привязанный как SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT не удалось преобразовать в тип данных, определяемый *ValueType* аргумент в **SQLBindParameter**.<br /><br /> (Если не удается преобразовать значения данных для одной или нескольких строк, но один или несколько строк, возвращенных успешно, эта функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07007|Нарушение значение параметра @restricted|Тип параметра SQL_PARAM_INPUT_OUTPUT_STREAM используется только для параметра, который отправляет и получает данные в частях. Входной буфер связанного недопустимо для данного типа параметра.<br /><br /> Эта ошибка возникает, когда тип параметра является SQL_PARAM_INPUT_OUTPUT и когда \* *StrLen_or_IndPtr* указано в **SQLBindParameter** не равен SQL_NULL_DATA, SQL_DEFAULT_ PARAM, SQL_LEN_DATA_AT_EXEC(len) или значению SQL_DATA_AT_EXEC.|  
|07S01|Недопустимое использование параметра по умолчанию|Задайте значение параметра с **SQLBindParameter**был SQL_DEFAULT_PARAM и соответствующего параметра отсутствует значение по умолчанию.|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|21S01|Список вставляемых значений не соответствует списку столбцов|\**StatementText* содержится **вставить** инструкции и число значений для вставки не совпали степень производной таблицы.|  
|21S02|Структура полученной таблицы не соответствуют списку столбцов|\**StatementText* содержится **CREATE VIEW** инструкции, а также список столбцов с неполными (количество столбцов, указанных для просмотра *идентификатор столбца* аргументы SQL Инструкция) содержит несколько имен, чем количество столбцов в производную таблицу, определяемую *спецификация запроса* аргумент инструкции SQL.|  
|22001|Строковые данные, усечение справа|Назначение символьное или двоичное значение в столбец завершилась усечение непустых символьные данные или двоичных данных от null.|  
|22002|Индикатор обязательным, но не указано|Значение NULL, данные были привязаны к выходному параметру которого *StrLen_or_IndPtr* задается **SQLBindParameter** является пустым указателем.|  
|22003|Численное значение вне допустимого диапазона|**StatementText* содержали инструкцию SQL, содержащий привязанные числовой параметр или литерал, и значение вызвало целиком (в отличие от доли) часть номера будут усечены при назначении столбцу связанные таблицы.<br /><br /> Возвращает числовое значение (как числовое или строковое) для одного или нескольких параметров ввода вывода или вывода могло привести целиком (в отличие от доли) часть усекаемое число.|  
|22007|Формат недопустимые даты и времени|**StatementText* содержатся инструкции SQL, содержащего даты, времени или структура отметки времени как связанных параметров и параметра было, соответственно, неверной даты, времени или отметки времени.<br /><br /> Ввода вывода или выходного параметра был привязан к даты, времени или структура отметки времени C, а значение возвращаемого параметра было, соответственно, неверной даты, времени или отметки времени. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|22008|Переполнение поля DateTime|**StatementText* автономной инструкции SQL, содержащего выражение даты и времени, что при, привело к созданию даты, времени или отметке времени структуру, в которой был недопустимым.<br /><br /> Вычисленное выражение даты и времени для ввода вывода или завершился даты, времени или структура отметки времени C, недопустимый выходной параметр.|  
|22012|Деление на ноль|**StatementText* содержали инструкцию SQL, который содержал арифметического выражения, вызвавшего деления на ноль.<br /><br /> Арифметическое выражение вычисляется для ввода вывода или выходной параметр завершился деления на ноль.|  
|22015|Переполнение поля интервала|*\*StatementText* содержится параметром точных числовых или интервал, при преобразовании в тип данных SQL интервал, привело к потере значащих цифр.<br /><br /> *\*StatementText* содержится параметром интервала с более чем одним полем, преобразованный в числовой тип данных в столбце, которых нет представления в числовой тип данных.<br /><br /> *\*StatementText* содержатся данные параметра, назначенные в пределах типа SQL, а возникла не представление значения типа C, в течение интервала, тип SQL.<br /><br /> Назначение ввода вывода или выходной параметр, который был точное числовое значение или интервал SQL типа в тип интервала C, привело к потере значащих цифр.<br /><br /> После ввода вывода или выходного параметра было назначено к структуре интервала C, возникла не представление данных в структуре данных интервала.|  
|22018|Недопустимое символьное значение для спецификации приведения|*\*StatementText* содержится тип C, был точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.<br /><br /> Если возвращена ввода вывода или выходным параметром, тип SQL был точное или Приблизительное числовое, datetime или тип интервала; Тип C была SQL_C_CHAR; и значение в столбце не является допустимым литералом связанного типа SQL.|  
|22019|Недопустимый escape-символ|\**StatementText* содержали инструкцию SQL, который содержится **как** предиката с **ESCAPE** в **ГДЕ** предложение, а длина escape Следующий символ **ESCAPE-** было не равно 1.|  
|22025|Недопустимая escape-последовательность|\**StatementText* содержали инструкцию SQL, который содержится «**как** *значение шаблона* **ESCAPE** *escape-символ*» в **ГДЕ** предложения и escape-символ в значение шаблона следующий символ не является одним из «%» или «_».|  
|23000|Нарушение ограничения целостности|**StatementText* содержали инструкцию SQL, в котором содержится имя параметра или литерал. Значение параметра было NULL для столбца, определенные как NOT NULL в столбце связанные таблицы, было задано повторяющееся значение для столбца, ограниченного должен содержать только уникальные значения или другое ограничение целостности было нарушено.|  
|24000|Недопустимое состояние курсора|Курсор был установлен на *StatementHandle* по **SQLFetch** или **SQLFetchScroll**. Если эта ошибка возвращается диспетчером драйверов **SQLFetch** или **SQLFetchScroll** не вернула значение SQL_NO_DATA и возвращается с помощью драйвера, если **SQLFetch** или **SQLFetchScroll** вернула значение SQL_NO_DATA.<br /><br /> Курсор был открыт, но не расположены в *StatementHandle*.<br /><br /> **StatementText* автономной позиционированные обновления или удаления инструкции и курсор был установлен перед началом результирующего набора, или в конце результирующего набора.|  
|34000|Недопустимое имя курсора|**StatementText* автономной позиционированные обновления или удаления инструкции и не был открыт курсор, указанный ссылкой, выполняемой инструкции.|  
|3D000|Недопустимое имя каталога|Имя каталога, указанное в *StatementText* недопустим.|  
|3F000|Недействительное имя схемы|Имя схемы, указанной в *StatementText* недопустим.|  
|40001|Сбой сериализации|Транзакции выполнен откат из-за взаимоблокировку ресурсов в другой транзакции.|  
|40003|Неизвестный завершение операторов|Сбой подключения во время выполнения этой функции и не удается определить состояние транзакции.|  
|42000|Синтаксическая ошибка или нарушение доступа|\**StatementText* содержали инструкцию SQL, не доступный для подготовки или содержит синтаксическую ошибку.<br /><br /> Пользователь не имеет разрешения на выполнение инструкции SQL, содержащейся в **StatementText*.|  
|42S01|Базовая таблица или представление уже существует|\**StatementText* содержится **CREATE TABLE** или **CREATE VIEW** инструкции и имя таблицы или представления с указанным именем уже существует.|  
|42S02|Базовая таблица или представление не найдены|\**StatementText* содержится **DROP TABLE** или **DROP VIEW** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **ALTER TABLE** инструкции и указанного имени таблицы не существует.<br /><br /> \**StatementText* содержится **CREATE VIEW** инструкции и имя таблицы или представления, имя, определенное в спецификации запроса не существует.<br /><br /> \**StatementText* содержится **CREATE INDEX** инструкции и указанного имени таблицы не существует.<br /><br /> \**StatementText* содержится **GRANT** или **ОТОЗВАТЬ** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **ВЫБЕРИТЕ** инструкции и указанными именем таблицы или представления, имя не существует.<br /><br /> \**StatementText* содержится **удаление**, **вставить**, или **обновление** инструкции и указанного имени таблицы не существует.<br /><br /> \**StatementText* содержится **CREATE TABLE** инструкции и таблицы, указанной в ограничении (ссылка на таблицу отличный от созданном) не существует.<br /><br /> \**StatementText* содержится **CREATE SCHEMA** инструкции и указанными именем таблицы или представления, имя не существует.|  
|42S11|Индекс уже существует|\**StatementText* содержится **CREATE INDEX** инструкции и индекс с указанным именем уже существует.<br /><br /> \**StatementText* содержится **CREATE SCHEMA** инструкции и индекс с указанным именем уже существует.|  
|42S12|Индекс не найден|\**StatementText* содержится **DROP INDEX** инструкции и индекс с указанным именем не существует.|  
|42S21|Столбец уже существует|\**StatementText* содержится **ALTER TABLE** инструкции и столбец, указанный в **добавить** предложения не является уникальным или идентифицирует существующего столбца в базовой таблице.|  
|42S22|Столбец не найден|\**StatementText* содержится **CREATE INDEX** инструкции и один или несколько столбцов, имена, указанные в списке столбцов не существует.<br /><br /> \**StatementText* содержится **GRANT** или **ОТОЗВАТЬ** оператор и с определенным названием столбца не существует.<br /><br /> \**StatementText* содержится **ВЫБЕРИТЕ**, **удаление**, **вставить**, или **обновление** инструкции и указанного столбца Имя не существует.<br /><br /> \**StatementText* содержится **CREATE TABLE** инструкции и столбец, указанный в ограничении (ссылка на таблицу отличный от созданном) не существует.<br /><br /> \**StatementText* содержится **CREATE SCHEMA** оператор и с определенным названием столбца не существует.|  
|44000|Нарушение параметра WITH CHECK OPTION|Аргумент *StatementText* содержится **вставить** с просматриваемого таблиц выполняется инструкция или таблицу, полученное из просматриваемого таблицы, который был создан путем указания **WITH CHECK OPTION**, таким образом, что одна или несколько строк влияет **вставить** инструкция будет в новой таблице просматриваемого.<br /><br /> Аргумент *StatementText* содержится **обновление** с просматриваемого таблиц выполняется инструкция или таблицу, полученное из просматриваемого таблицы, который был создан путем указания **WITH CHECK OPTION**, таким образом, что одна или несколько строк влияет **обновление** инструкция будет в новой таблице просматриваемого.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в * \*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY009|Недопустимое использование пустого указателя|(DM) **StatementText* является пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом асинхронной функция **SQLExecDirect** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ЭТОТ ПАРАМЕТР ДОСТУПЕН. До получения данных для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для * StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) аргумент *TextLength* было меньше или равно 0, но не равно SQL_NTS.<br /><br /> Задайте значение параметра с **SQLBindParameter**, является пустым указателем, а значение параметра длины не 0, SQL_NULL_DATA, значение SQL_DATA_AT_EXEC, SQL_DEFAULT_PARAM, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Задайте значение параметра с **SQLBindParameter**, не является пустым указателем; был тип данных C SQL_C_BINARY и SQL_C_CHAR; и значение параметра длины был, но меньше 0 не SQL_NTS, SQL_NULL_DATA, значение SQL_DATA_AT_EXEC, SQL_DEFAULT_ ПАРАМЕТР, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Длина значения параметра ограничивается **SQLBindParameter** был задан в значение SQL_DATA_AT_EXEC, тип SQL был SQL_LONGVARCHAR, SQL_LONGVARBINARY, или тип данных long, определяемые источником данных; и информацию о SQL_NEED_LONG_DATA_LEN Введите в **SQLGetInfo** была «Y».|  
|HY105|Недопустимый тип параметра|Значение, указанное для аргумента *InputOutputType* в **SQLBindParameter** было SQL_PARAM_OUTPUT, а параметр было входного параметра.|  
|HY109|Недопустимое положение курсора|\**StatementText* автономной позиционированные обновления или удаления инструкции и курсор был установлен (по **SQLSetPos** или **SQLFetchScroll**) на строку, которая была удалена или не может быть извлечь.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Сочетание текущих настроек атрибуты инструкции SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживается драйвером или источником данных.<br /><br /> Атрибут инструкции SQL_ATTR_USE_BOOKMARKS было задано значение SQL_UB_VARIABLE, а атрибут инструкции SQL_ATTR_CURSOR_TYPE был задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло раньше, чем источник данных вернул результирующий набор. Время ожидания задается с помощью **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
  
## <a name="comments"></a>Комментарии  
 Приложение вызывает **SQLExecDirect** для отправки инструкций SQL к источнику данных. Дополнительные сведения о прямое выполнение, в разделе [прямое выполнение](../../../odbc/reference/develop-app/direct-execution-odbc.md). Драйвер изменяет инструкцию с использованием формы SQL, используемая источником данных, а затем отправляет его в источник данных. В частности драйвер изменяет escape-последовательности, используемые для определения некоторых функций в SQL. Синтаксис escape-последовательностей см. в разделе [Escape-последовательности ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).  
  
 Приложение может включать один или несколько маркеров параметров в инструкции SQL. Чтобы включить маркер параметра, приложения внедряет знак вопроса (?) в инструкции SQL в соответствующей позиции. Сведения о параметрах см. в разделе [параметров инструкции](../../../odbc/reference/develop-app/statement-parameters.md).  
  
 Если инструкция SQL является **ВЫБЕРИТЕ** инструкции и если приложение вызвало **SQLSetCursorName** чтобы связать курсор с оператором, затем драйвер использует заданный курсор. В противном случае драйвер создает имя курсора.  
  
 Если источник данных находится в режиме ручной фиксации (при необходимости запуска явной транзакции), и транзакция уже не было инициировано, драйвер запускает транзакцию, прежде чем он отправляет инструкции SQL. Дополнительные сведения см. в разделе [режим ручной фиксации](../../../odbc/reference/develop-app/manual-commit-mode.md).  
  
 Если приложение использует **SQLExecDirect** для отправки **ЗАФИКСИРОВАТЬ** или **ОТКАТА** инструкции, он не будет взаимодействия между СУБД. Для фиксации или отката транзакции, приложение вызывает **SQLEndTran**.  
  
 Если **SQLExecDirect** обнаруживают параметр данных во время выполнения, он возвращает значение SQL_NEED_DATA. Приложение отправляет данные с помощью **SQLParamData** и **SQLPutData**. В разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md), [SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md), и [отправки длинных данных](../../../odbc/reference/develop-app/sending-long-data.md).  
  
 Если **SQLExecDirect** выполняет поисковое обновление, вставка или инструкции delete, не влияет на все строки в источнике данных, вызов **SQLExecDirect** не вернет значение SQL_NO_DATA.  
  
 Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, а инструкция SQL содержит по крайней мере один маркер параметра, **SQLExecDirect** выполнит инструкцию SQL один раз для каждого набора значений параметров из массивы, на который указывает *ParameterValuePointer* аргумента в вызове **SQLBindParameter**. Дополнительные сведения см. в разделе [массивы значений параметров](../../../odbc/reference/develop-app/arrays-of-parameter-values.md).  
  
 Если включены закладки и выполняется запрос, не поддерживает закладки, драйвер должен пытаться coerce среде на ту, которая поддерживает закладки, изменив значение атрибута и возвращение SQLSTATE 01S02 (значение параметра изменено). Если атрибут не может быть изменен, драйвер должен возвращать SQLSTATE HY024 (недопустимое значение атрибута).  
  
> [!NOTE]  
>  При использовании пула подключений, приложение не должно выполнить инструкции SQL, изменяющие базу данных или в контексте базы данных, такие как **используйте** *базы данных* инструкции в SQL Server, который изменяет каталог, используемый источником данных.  
  
## <a name="code-example"></a>Пример кода  
 В разделе [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md), [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md), и [образца программы ODBC](../../../odbc/reference/sample-odbc-program.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфера|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение операции фиксации или отката|[Функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md)|  
|Выполнения подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Извлечение нескольких строк данных|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Выборка блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возвращает имя курсора|[Функция SQLGetCursorName](../../../odbc/reference/syntax/sqlgetcursorname-function.md)|  
|Извлечение всех или части столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращает следующий параметр для отправки данных|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Подготовка инструкции для выполнения|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
|Отправка данных параметра во время выполнения|[Функция SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Имя курсора|[Функция SQLSetCursorName](../../../odbc/reference/syntax/sqlsetcursorname-function.md)|  
|С помощью атрибута инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)

