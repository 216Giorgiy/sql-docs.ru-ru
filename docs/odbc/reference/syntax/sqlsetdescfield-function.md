---
title: "Функция SQLSetDescField | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: odbc
ms.reviewer: 
ms.suite: sql
ms.technology: drivers
ms.tgt_pltfrm: 
ms.topic: article
apiname: SQLSetDescField
apilocation: sqlsrv32.dll
apitype: dllExport
f1_keywords: SQLSetDescField
helpviewer_keywords: SQLSetDescField function [ODBC]
ms.assetid: 8c544388-fe9d-4f94-a0ac-fa0b9c9c88a5
caps.latest.revision: "28"
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: Inactive
ms.openlocfilehash: 3e6a0ee843ce2b78ebc611fee30a5ee8e16fc7e1
ms.sourcegitcommit: cc71f1027884462c359effb898390c8d97eaa414
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="sqlsetdescfield-function"></a>Функция SQLSetDescField
**Соответствия**  
 Появился в версии: ODBC 3.0 нормативных требований: ISO-92  
  
 **Сводка**  
 **SQLSetDescField** задает значение одного поля записи дескриптора.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLSetDescField(  
     SQLHDESC      DescriptorHandle,  
     SQLSMALLINT   RecNumber,  
     SQLSMALLINT   FieldIdentifier,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    BufferLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *DescriptorHandle*  
 [Вход] Дескриптор.  
  
 *RecNumber*  
 [Вход] Указывает дескриптор записи, содержащий поле, которое пытается установить приложение. Дескриптор записи нумеруются от 0, записи номером 0 является записи закладки. *RecNumber* аргумент учитывается для поля заголовка.  
  
 *FieldIdentifier*  
 [Вход] Указывает поле, значение которого требуется задать дескриптора. Дополнительные сведения см. в разделе «*FieldIdentifier* аргумент» в разделе «Примечания».  
  
 *ValuePtr*  
 [Вход] Указатель на буфер, содержащий данные дескриптора или является целым числом. Тип данных зависит от значения *FieldIdentifier*. Если *ValuePtr* — это целочисленное значение может рассматриваться как 8 байт (SQLLEN), 4 байта (SQLINTEGER) или 2 байта (SQLSMALLINT), в зависимости от значения *FieldIdentifier* аргумент.  
  
 *BufferLength*  
 [Вход] Если *FieldIdentifier* представляет собой поле, определенных для ODBC и *ValuePtr* указывает на строку символов или двоичных буфера, данный аргумент должен иметь длину **ValuePtr*. Для символьных строковых данных этот аргумент должен содержать число байтов в строку.  
  
 Если *FieldIdentifier* представляет собой поле, определенных для ODBC и *ValuePtr* является целым числом, *BufferLength* учитывается.  
  
 Если *FieldIdentifier* является полем, определяемым драйвером, приложение сможет определить природу поля для диспетчера драйверов, задав *BufferLength* аргумент. *BufferLength* может иметь следующие значения:  
  
-   Если *ValuePtr* является указателем на строку символов, затем *BufferLength* длина строки или SQL_NTS.  
  
-   Если *ValuePtr* — это указатель на двоичные буфер, то приложение помещает результат SQL_LEN_BINARY_ATTR (*длина*) макрос в *BufferLength*. В этом случае отрицательное значение в *BufferLength*.  
  
-   Если *ValuePtr* — это указатель на значение, отличное от строки символов или двоичная строка затем *BufferLength* должно иметь значение SQL_IS_POINTER.  
  
-   Если *ValuePtr* содержит значение фиксированной длины, то *BufferLength* — SQL_IS_INTEGER, SQL_IS_UINTEGER, SQL_IS_SMALLINT или SQL_IS_USMALLINT, соответствующим образом.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSetDescField** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_HANDLE_DESC и *обработки* из *DescriptorHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLSetDescField** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменено|Драйвер не поддерживает значение, указанное в  *\*ValuePtr* (если *ValuePtr* был указателем) или значение в *ValuePtr* (если *ValuePtr*  был целочисленное значение), или  *\*ValuePtr* недопустим из-за условий работы реализации, поэтому драйвер заменены примерно такое же значение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07009|Недопустимый индекс дескриптора|*FieldIdentifier* аргумент был поле записи, *RecNumber* аргумент было равно 0 и *DescriptorHandle* аргумент называют дескриптор IPD.<br /><br /> *RecNumber* аргумент был меньше 0 и *DescriptorHandle* аргумент называют Отменить или APD.<br /><br /> *RecNumber* аргумент был больше, чем максимальное количество столбцов или параметров, которые источник данных может поддерживать, и *DescriptorHandle* аргумент называют APD или Отменить.<br /><br /> (DM) *FieldIdentifier* аргумент был SQL_DESC_COUNT, и  *\*ValuePtr* аргумент был меньше 0.<br /><br /> *RecNumber* аргумент, равное 0 и *DescriptorHandle* аргумент называют неявным образом выделенный APD. (Эта ошибка не возникает дескриптор явно выделенного приложения, так как неизвестно, является ли дескриптор явно выделенного приложения APD или Отменить до выполнения времени.)|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22001|Строка справа усечение данных|*FieldIdentifier* аргумент был SQL_DESC_NAME и *BufferLength* аргумент имеет значение больше, чем SQL_MAX_IDENTIFIER_LEN.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY010|Ошибка последовательности функций|(DM) *DescriptorHandle* была связана с *StatementHandle* для которой асинхронного выполнения функции, (не это один) был вызван и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* с помощью которого *DescriptorHandle* был связанные и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.<br /><br /> (DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *DescriptorHandle*. Выполняется при этом асинхронной функция **SQLSetDescField** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для одного из дескрипторов инструкций, связанных с *DescriptorHandle* и возвращается SQL_PARAM_DATA_AVAILABLE. До получения данных для всех параметров потоковой вызове этой функции.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY016|Не удается изменить дескриптор строки реализации|*DescriptorHandle* аргумент был связан с IRD и *FieldIdentifier* аргумент не SQL_DESC_ARRAY_STATUS_PTR или SQL_DESC_ROWS_PROCESSED_PTR.|  
|HY021|Неправильные сведения о дескрипторе|Поля SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE не образуют допустимый тип ODBC SQL или допустимым типом специфические для драйвера SQL (для реализации) или является допустимым типом ODBC C (для APDs или ARDs).<br /><br /> Сведения о дескрипторе проверяется в ходе проверки согласованности не согласован. (В разделе «Проверка согласованности» в **SQLSetDescRec**.)|  
|HY090|Недопустимая длина строки или буфера|(DM)  *\*ValuePtr* представляет собой строку символов и *BufferLength* был меньше нуля и не может быть равно SQL_NTS.<br /><br /> (DM) был драйвер ODBC 2*.x* драйвера, дескриптор был Отменить *ColumnNumber* аргумент было задано значение 0 и значения, указанного в аргументе *BufferLength* был не равно 4.|  
|HY091|Недопустимый идентификатор поля дескриптора|Значение, указанное для *FieldIdentifier* аргумент не поля, определяемые ODBC и не значение определяемого реализацией.<br /><br /> *FieldIdentifier* недопустимый аргумент для *DescriptorHandle* аргумент.<br /><br /> *FieldIdentifier* аргумент был поля только для чтения, определенных для ODBC.|  
|HY092|Недопустимый атрибут идентификатор или параметра|Значение в  *\*ValuePtr* не подходит для *FieldIdentifier* аргумент.<br /><br /> *FieldIdentifier* аргумент был SQL_DESC_UNNAMED, и *ValuePtr* был SQL_NAMED.|  
|HY105|Недопустимый тип параметра|(DM) Недопустимое значение, заданное для поля SQL_DESC_PARAMETER_TYPE. (Дополнительные сведения см. в разделе «*InputOutputType* аргумент» раздела **SQLBindParameter**.)|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [новые возможности ODBC 3.8](../../../odbc/reference/what-s-new-in-odbc-3-8.md).|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *DescriptorHandle* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение может вызвать **SQLSetDescField** для задания любого поля дескриптора, одно за раз. Один вызов **SQLSetDescField** задает одного поля в одном дескрипторе. Эту функцию можно вызывается для задания любого поля в любой тип дескриптора, при условии, что поле может быть установлено. (См. таблицу ниже в этом разделе).  
  
> [!NOTE]  
>  Если вызов **SQLSetDescField** завершается ошибкой, то содержимое указанной записи дескриптора *RecNumber* аргумент не определены.  
  
 Другие функции могут вызываться для задания нескольких поля дескриптора, с помощью одного вызова функции. **SQLSetDescRec** функция задает различные поля, влияющих на тип данных и буфер привязан к столбца или параметра (SQL_DESC_TYPE, SQL_DESC_DATETIME_INTERVAL_CODE, SQL_DESC_OCTET_LENGTH, SQL_DESC_PRECISION, SQL_ DESC_SCALE, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR поля). **SQLBindCol** или **SQLBindParameter** можно использовать, чтобы сделать полную спецификацию для привязки столбца или параметра. Эти функции устанавливают определенной группы поля дескриптора с один вызов функции.  
  
 **SQLSetDescField** можно вызвать, чтобы изменить привязки буферов путем добавления смещения для привязки указателей (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR). Это изменяет буферы привязки без вызова **SQLBindCol** или **SQLBindParameter**, что позволяет приложению изменять SQL_DESC_DATA_PTR без изменения других полей, таких как SQL_DESC_DATA_ ТИП.  
  
 Если приложение вызывает **SQLSetDescField** для установки всех полей, кроме SQL_DESC_COUNT и отложенных полей SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR выберите запись станет свободной.  
  
 Поля заголовка дескриптора задаются путем вызова **SQLSetDescField** с соответствующими *FieldIdentifier*. Многие поля заголовков являются атрибуты инструкции, поэтому их можно также задать с помощью вызова **SQLSetStmtAttr**. Это позволяет приложениям задать поле дескриптора без предварительного получения дескриптора. Когда **SQLSetDescField** вызывается, чтобы задать поле заголовка, *RecNumber* аргумент учитывается.  
  
 Объект *RecNumber* 0 используется для задания поля закладки.  
  
> [!NOTE]  
>  Атрибут инструкции SQL_ATTR_USE_BOOKMARKS должен всегда быть установлен перед вызовом **SQLSetDescField** поля закладки можно установить. Хотя это не обязательно, настоятельно рекомендуется.  
  
## <a name="sequence-of-setting-descriptor-fields"></a>Последовательность значений поля дескриптора  
 При задании поля дескриптора, вызвав **SQLSetDescField**, приложения должны соответствовать определенной последовательности:  
  
1.  Приложение, сначала необходимо задать поле SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE или SQL_DESC_DATETIME_INTERVAL_CODE.  
  
2.  После одного из этих полей задана, приложение может задать атрибут типа данных, и драйвер задает тип данных поля атрибутов соответствующие значения по умолчанию для типа данных. Автоматическая установка значений по умолчанию из полей типа атрибута гарантирует, что дескриптор будет готов к использованию сразу же приложение указанный тип данных. Если приложение явно задает атрибут типа данных, он переопределяет атрибут по умолчанию.  
  
3.  После задано одно из полей, перечисленные на шаге 1, и были заданы атрибуты типа данных, приложение может задать SQL_DESC_DATA_PTR. По этой причине, появляется проверку согласованности поля дескриптора. Если приложение изменяет тип данных или атрибутов после задания свойства поля SQL_DESC_DATA_PTR, драйвер задает SQL_DESC_DATA_PTR является пустым указателем, Отмена привязки значения записи. Это вызывает принудительное завершение надлежащих шагов в последовательности, годным записи дескриптора.  
  
## <a name="initialization-of-descriptor-fields"></a>Инициализация поля дескриптора  
 При выделении дескриптор полей дескриптора можно инициализировать значения по умолчанию, инициализироваться без значения по умолчанию или быть не определено для типа дескриптора. В следующих таблицах содержатся инициализации каждого поля для каждого типа дескриптора с «D», указывающее, что поле инициализируется со значением по умолчанию и «ND», указывающее, что поле инициализируется без значения по умолчанию. Если показано число, значение по умолчанию поля — это число. Таблицы также указывать, является ли поле чтения и записи (чтение/запись) или только для чтения (R).  
  
 Поля IRD имеют значение по умолчанию, только после инструкции подготовки, или выполнения и IRD был заполнен, не в том случае, если выделить дескриптор инструкции или дескриптора. Пока заполнив IRD, любая попытка получить доступ к полю IRD возвратит ошибку.  
  
 Некоторые поля дескриптора определены для одного или нескольких, но не все из дескриптора типов (ARDs и IRDs и APDs и реализации). Поле не определено для типа дескриптора, не требуется каким-либо функции, использующие этот дескриптор.  
  
 Поля, которые может осуществляться **SQLGetDescField** обязательно не может быть задано **SQLSetDescField**. Поля, которые можно установить с **SQLSetDescField** , перечислены в следующих таблицах.  
  
 В следующей таблице описывается инициализация поля заголовка.  
  
|Имя поля заголовка|Тип|Чтение-запись|Default|  
|-----------------------|----------|----------|-------------|  
|SQL_DESC_ALLOC_TYPE|SQLSMALLINT|ОТМЕНИТЬ: R APD: R IRD: R IPD: R|Отменить: SQL_DESC_ALLOC_AUTO для неявных или SQL_DESC_ALLOC_USER для явного<br /><br /> APD: SQL_DESC_ALLOC_AUTO для неявных или SQL_DESC_ALLOC_USER для явного<br /><br /> IRD: SQL_DESC_ALLOC_AUTO<br /><br /> IPD: SQL_DESC_ALLOC_AUTO|  
|SQL_DESC_ARRAY_SIZE|SQLULEN|Отменить: Чтения или APD: IRD для чтения и записи: неиспользуемые IPD: неиспользуемые|Отменить: APD [1]: [1] IRD: неиспользуемые IPD: неиспользуемые|  
|SQL_DESC_ARRAY_STATUS_PTR|SQLUSMALLINT *|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: IPD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|Отменить: Null ptr APD: Null ptr IRD: Null ptr IPD: Null ptr|  
|SQL_DESC_BIND_OFFSET_PTR|SQLLEN *|Отменить: Чтения или APD: IRD для чтения и записи: неиспользуемые IPD: неиспользуемые|Отменить: Null ptr APD: Null ptr IRD: неиспользуемые IPD: неиспользуемые|  
|SQL_DESC_BIND_TYPE|SQLINTEGER|Отменить: Чтения или APD: IRD для чтения и записи: неиспользуемые IPD: неиспользуемые|ОТМЕНИТЬ: SQL_BIND_BY_COLUMN<br /><br /> APD: SQL_BIND_BY_COLUMN<br /><br /> IRD: неиспользуемые<br /><br /> IPD: неиспользуемые|  
SQL_DESC_COUNT|SQLSMALLINT|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: 0 APD: 0 IRD: D IPD: 0|  
|SQL_DESC_ROWS_PROCESSED_PTR|SQLULEN *|Отменить: Неиспользуемые APD: неиспользуемые IRD: IPD для чтения и записи: для чтения и записи|Отменить: Неиспользуемые APD: неиспользуемые IRD: Null ptr IPD: Null ptr|  
  
 [1] Эти поля определены только в том случае, когда IPD заполняется автоматически с помощью драйвера. В противном случае они определены. Если приложение пытается установить эти поля SQLSTATE HY091 (недопустимый идентификатор поля дескриптора) будет возвращено.  
  
 Инициализация поля записи определяется, как показано в следующей таблице.  
  
|Имя поля записи|Тип|Чтение-запись|Default|  
|-----------------------|----------|----------|-------------|  
|SQL_DESC_AUTO_UNIQUE_VALUE|SQLINTEGER|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_BASE_COLUMN_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_BASE_TABLE_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_CASE_SENSITIVE|SQLINTEGER|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_CATALOG_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_CONCISE_TYPE|SQLSMALLINT|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: ПО УМОЛЧАНИЮ APD SQL_C_: IRD SQL_C_ ПО УМОЛЧАНИЮ: D IPD: ND|  
|SQL_DESC_DATA_PTR|УКАЗАТЕЛЬ SQLPOINTER|Отменить: Чтения или APD: IRD для чтения и записи: неиспользуемые IPD: неиспользуемые|Отменить: Null ptr APD: Null ptr IRD: неиспользуемые IPD: неиспользуемые [2]|  
|SQL_DESC_DATETIME_INTERVAL_CODE|SQLSMALLINT|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
|SQL_DESC_DATETIME_INTERVAL_PRECISION|SQLINTEGER|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
SQL_DESC_DISPLAY_SIZE|SQLLEN|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_FIXED_PREC_SCALE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_INDICATOR_PTR|SQLLEN *|Отменить: Чтения или APD: IRD для чтения и записи: неиспользуемые IPD: неиспользуемые|Отменить: Null ptr APD: Null ptr IRD: неиспользуемые IPD: неиспользуемые|  
|SQL_DESC_LABEL|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_LENGTH|SQLULEN|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
|SQL_DESC_LITERAL_PREFIX|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_LITERAL_SUFFIX|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_LOCAL_TYPE_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: для чтения и записи|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
|SQL_DESC_NULLABLE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
|SQL_DESC_NUM_PREC_RADIX|SQLINTEGER|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
SQL_DESC_OCTET_LENGTH|SQLLEN|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
|SQL_DESC_OCTET_LENGTH_PTR|SQLLEN *|Отменить: Чтения или APD: IRD для чтения и записи: неиспользуемые IPD: неиспользуемые|Отменить: Null ptr APD: Null ptr IRD: неиспользуемые IPD: неиспользуемые|  
|SQL_DESC_PARAMETER_TYPE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: неиспользуемые IPD: для чтения и записи|Отменить: Неиспользуемые APD: неиспользуемые IRD: неиспользуемые IPD: D = SQL_PARAM_INPUT|  
|SQL_DESC_PRECISION|SQLSMALLINT|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
|SQL_DESC_ROWVER|SQLSMALLINT|Отменить: неиспользуемые<br /><br /> APD: неиспользуемые<br /><br /> IRD: R<br /><br /> IPD: R|Отменить: неиспользуемые<br /><br /> APD: неиспользуемые<br /><br /> IRD: ND<br /><br /> IPD: ND|  
|SQL_DESC_SCALE|SQLSMALLINT|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
|SQL_DESC_SCHEMA_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_SEARCHABLE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_TABLE_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
|SQL_DESC_TYPE|SQLSMALLINT|ОТМЕНИТЬ: ДЛЯ ЧТЕНИЯ И ЗАПИСИ APD: IRD ДЛЯ ЧТЕНИЯ И ЗАПИСИ: R IPD: ДЛЯ ЧТЕНИЯ И ЗАПИСИ|ОТМЕНИТЬ: SQL_C_DEFAULT APD: SQL_C_DEFAULT IRD: D IPD: ND|  
SQL_DESC_TYPE_NAME|SQLCHAR *|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_UNNAMED|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: для чтения и записи|ОТМЕНИТЬ: APD ND: ND IRD: D IPD: ND|  
|SQL_DESC_UNSIGNED|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: R|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: D [1]|  
|SQL_DESC_UPDATABLE|SQLSMALLINT|Отменить: Неиспользуемые APD: неиспользуемые IRD: R IPD: неиспользуемые|Отменить: Неиспользуемые APD: неиспользуемые IRD: D IPD: неиспользуемые|  
  
 [1] Эти поля определены только в том случае, когда IPD заполняется автоматически с помощью драйвера. В противном случае они определены. Если приложение пытается установить эти поля SQLSTATE HY091 (недопустимый идентификатор поля дескриптора) будет возвращено.  
  
 [2] в IPD может быть задан параметр sql_desc_data_ptr, чтобы принудительно выполнить проверку согласованности. В последующем вызове для **SQLGetDescField** или **SQLGetDescRec**, драйвер не должен возвращать значение, которое было присвоено значение SQL_DESC_DATA_PTR.  
  
## <a name="fieldidentifier-argument"></a>Аргумент FieldIdentifier  
 *FieldIdentifier* аргумент указывает, требуется задать поля дескриптора. Дескриптор содержит *заголовка дескриптора* состоящий из поля заголовка, описанные в следующем разделе, «Заголовок поля» и одно или несколько *записям дескриптора* состоящий из поля записи описывается в разделе, в следующем разделе «Поля заголовка».  
  
## <a name="header-fields"></a>Поля заголовка  
 Каждый дескриптор имеет заголовок, состоящий из следующих полей:  
  
 **SQL_DESC_ALLOC_TYPE [All]**  
 Это поле заголовка SQLSMALLINT только для чтения указывает ли дескриптор был выделен автоматически драйвером, или явно приложением. Приложение можно получить, но не изменять это поле. В поле задано SQL_DESC_ALLOC_AUTO драйвером, если дескриптор был автоматически выделяется драйвером. Он имеет значение SQL_DESC_ALLOC_USER драйвером, если дескриптор был явно выделяется для приложения.  
  
 **SQL_DESC_ARRAY_SIZE [дескрипторы приложения]**  
 В ARDs это поле заголовка SQLULEN указывает количество строк в наборе строк. Число строк, возвращаемых при вызове **SQLFetch** или **SQLFetchScroll** или должна быть выполнена с помощью вызова **SQLBulkOperations** или **SQLSetPos** .  
  
 В APDs это поле заголовка SQLULEN указывает число значений для каждого параметра.  
  
 По умолчанию значение этого поля равно 1. Если SQL_DESC_ARRAY_SIZE больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR в APD или Отменить точки к массивам. Количество элементов в каждом массиве равно значению этого поля.  
  
 Также можно задать путем вызова этого поля в Отменить **SQLSetStmtAttr** с помощью атрибута SQL_ATTR_ROW_ARRAY_SIZE. Это поле в дескрипторе параметра приложения также можно задать путем вызова **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAMSET_SIZE.  
  
 **SQL_DESC_ARRAY_STATUS_PTR [All]**  
 Для каждого дескриптора типа, этот SQLUSMALLINT * заголовок указывается массив полей SQLUSMALLINT значений. Следующие имена этих массивов: строк массив состояний (IRD), массив состояний параметров (IPD), массива операций строк (Отменить) и массив параметров операции (APD).  
  
 В IRD, это поле заголовка указывает массив состояния строк, содержащий значения состояния после вызова **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, или **SQLSetPos**. Массив имеет столько же элементов как строк в наборе строк. Приложение должно выделить память для массива SQLUSMALLINTs и выберите в этом поле, чтобы он указывал на массив. Поле по умолчанию имеет значение является пустым указателем. Драйвер будет заполнить массив, если не задано поле SQL_DESC_ARRAY_STATUS_PTR указателем null, в этом случае нет значений состояния создаются и массива не заполняется.  
  
> [!CAUTION]  
>  Если приложение задает элементы массива строк состояния, на который указывает поле SQL_DESC_ARRAY_STATUS_PTR IRD поведение драйвера не определено.  
  
 Изначально массив заполняется с помощью вызова **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, или **SQLSetPos**. Если вызов не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое массива, на который указывает это поле не определено. Элементы массива могут содержать следующие значения:  
  
-   SQL_ROW_SUCCESS: Строка была успешно получен и не изменились с момента последней загрузки.  
  
-   SQL_ROW_SUCCESS_WITH_INFO: Строка была успешно получен и не изменились с момента последней загрузки. Однако предупреждение был возвращен о строке.  
  
-   SQL_ROW_ERROR: Произошла ошибка при получении строки.  
  
-   SQL_ROW_UPDATED: Строка была успешно получен и обновилась с момента последней загрузки. Если строка выбирается заново, она находится в состоянии SQL_ROW_SUCCESS.  
  
-   SQL_ROW_DELETED: Строка была удалена с момента последней загрузки.  
  
-   SQL_ROW_ADDED: Строка была вставлена **SQLBulkOperations**. Если строка выбирается заново, она находится в состоянии SQL_ROW_SUCCESS.  
  
-   SQL_ROW_NOROW: В наборе строк перекрывающегося конца результирующего набора и строки не был возвращен, что значение соответствовало этот элемент массив состояния строк.  
  
 Также можно задать путем вызова этого поля в IRD **SQLSetStmtAttr** sql_attr_row_status_ptr, которое указывает атрибут.  
  
 В поле SQL_DESC_ARRAY_STATUS_PTR IRD является допустимым, только после возвращения SQL_SUCCESS или SQL_SUCCESS_WITH_INFO. Если код возврата не является одним из них, в расположении, указанном SQL_DESC_ROWS_PROCESSED_PTR не определено.  
  
 В IPD, это поле заголовка указывает на массив состояний параметров, содержащий сведения о состоянии для каждого набора значений параметров после вызова **SQLExecute** или **SQLExecDirect**. Если вызов **SQLExecute** или **SQLExecDirect** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое массива, на который указывает это поле не определено. Приложение должно выделить память для массива SQLUSMALLINTs и выберите в этом поле, чтобы он указывал на массив. Драйвер будет заполнить массив, если не задано поле SQL_DESC_ARRAY_STATUS_PTR указателем null, в этом случае нет значений состояния создаются и массива не заполняется. Элементы массива могут содержать следующие значения:  
  
-   SQL_PARAM_SUCCESS: Инструкция SQL успешно выполнена для текущего набора параметров.  
  
-   SQL_PARAM_SUCCESS_WITH_INFO: Инструкция SQL была выполнена успешно для данного набора параметров. Тем не менее сведения о предупреждении доступен в структуре данных диагностики.  
  
-   SQL_PARAM_ERROR: Произошла ошибка при обработке этот набор параметров. Дополнительные сведения об ошибке доступен в структуре данных диагностики.  
  
-   SQL_PARAM_UNUSED: Этот набор параметров был неиспользуемые, возможно из-за того, что некоторые предыдущие набор параметров вызвала ошибку, что прервана дальнейшей обработки или SQL_PARAM_IGNORE было установлено для этого набора параметров массива, заданного параметром SQL_DESC_ARRAY_ Поле STATUS_PTR дескрипторе параметра приложения.  
  
-   SQL_PARAM_DIAG_UNAVAILABLE: Диагностические сведения недоступны. Примером этого является, когда драйвер рассматривает массивы параметров как монолитные блок и поэтому не создает этот уровень сведений об ошибках.  
  
 Это поле в IPD также можно задать путем вызова **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_STATUS_PTR.  
  
 В Отменить, это поле заголовка указывает на массив значений, которые могут быть установлены приложения, укажите, является ли эта строка будет пропускаться при операции строки **SQLSetPos** операций. Элементы массива могут содержать следующие значения:  
  
-   SQL_ROW_PROCEED: Строка включается в массовой операции, используя **SQLSetPos**. (Этот параметр не гарантирует, что операция будет выполняться в строке. Если строка имеет состояние SQL_ROW_ERROR в массив состояния строк IRD, драйвер может не иметь возможность выполнения операции в строке.)  
  
-   SQL_ROW_IGNORE: Строка исключается из массовой операции, используя **SQLSetPos**.  
  
 Если нет элементов массива, при массовой операции включаются все строки. Если значение в поле SQL_DESC_ARRAY_STATUS_PTR Отменить является указателем null, все строки, включаются в пакетной операции; Интерпретация одинаково как в том случае, если указатель, на который указывает действительный массив и SQL_ROW_PROCEED были все элементы массива. Если элемент в массиве равно SQL_ROW_IGNORE, значение в массиве строк состояния для пропускаемых строк не изменяется.  
  
 Также можно задать путем вызова этого поля в Отменить **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROW_OPERATION_PTR.  
  
 В дескрипторе параметра приложения, это поле заголовка указывает на массив значений, которые могут быть установлены приложением, чтобы указать, является ли этот набор параметров для операции параметров игнорируются, когда **SQLExecute** или **SQLExecDirect**вызывается. Элементы массива могут содержать следующие значения:  
  
-   SQL_PARAM_PROCEED: Набор параметров, включается в **SQLExecute** или **SQLExecDirect** вызова.  
  
-   SQL_PARAM_IGNORE: Набор параметров исключается из **SQLExecute** или **SQLExecDirect** вызова.  
  
 Если элементы массива не заданы, все наборы параметров в массиве, используются в **SQLExecute** или **SQLExecDirect** вызовов. Если значение в поле SQL_DESC_ARRAY_STATUS_PTR APD является указателем null, используются все наборы параметров; Интерпретация одинаково как в том случае, если указатель, на который указывает действительный массив и SQL_PARAM_PROCEED были все элементы массива.  
  
 Это поле в дескрипторе параметра приложения также можно задать путем вызова **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_OPERATION_PTR.  
  
 **SQL_DESC_BIND_OFFSET_PTR [дескрипторы приложения]**  
 Это SQLLEN * точек поля заголовка на смещение привязки. По умолчанию он имеет значение на указатель null. Если это поле не является указателем null, драйвер разыменовывает указатель и добавляет разыменованное значение к каждому из отложенных полей, имеющих значение отличное от null, в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) выборки во времени и использует новые значения указателя при привязке.  
  
 Смещение привязки всегда добавляется непосредственно значения в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR. Если смещение изменяется с другим значением, новое значение все равно добавляется непосредственно к значению в каждом поле дескриптора. Новое смещение не добавляется в значении поля, а также более ранних смещения.  
  
 Это поле является *отложенное поле*: он не используется во время задано, но используется позднее драйвером, когда ему требуется определение адреса для буферов данных.  
  
 Также можно задать путем вызова этого поля в Отменить **SQLSetStmtAttr** с атрибутом SQL_ATTR_ROW_BIND_OFFSET_PTR. Также можно задать путем вызова этого поля в Отменить **SQLSetStmtAttr** с атрибутом SQL_ATTR_PARAM_BIND_OFFSET_PTR.  
  
 Дополнительные сведения см. в описании привязка в [SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md) и [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md).  
  
 **SQL_DESC_BIND_TYPE [дескрипторы приложения]**  
 Это поле заголовка SQLUINTEGER задает ориентацию привязки для привязки столбцов или параметров.  
  
 В ARDs, это поле задает ориентацию привязки при **SQLFetchScroll** или **SQLFetch** вызывается для дескриптора соответствующий оператор.  
  
 Чтобы выбрать привязку по столбцам для столбцов, это поле имеет значение равное SQL_BIND_BY_COLUMN (по умолчанию).  
  
 Также можно задать путем вызова этого поля в Отменить **SQLSetStmtAttr** с SQL_ATTR_ROW_BIND_TYPE *атрибут*.  
  
 В APDs это поле определяет ориентацию привязки для использования динамических параметров.  
  
 Чтобы выбрать привязка на уровне столбцов для параметров, это поле имеет значение равное SQL_BIND_BY_COLUMN (по умолчанию).  
  
 Это поле в дескрипторе параметра приложения также можно задать путем вызова **SQLSetStmtAttr** с SQL_ATTR_PARAM_BIND_TYPE *атрибут*.  
  
 **SQL_DESC_COUNT [All]**  
 Это поле заголовка SQLSMALLINT Указывает единицы индекс наибольший номер записи, которая содержит данные. Если драйвер устанавливает структуру данных для дескриптора, его необходимо также установить SQL_DESC_COUNT поле для отображения значительное количество записей. Если приложение выделяет экземпляр этой структуры данных, его нет необходимости указывать количество записей для резервирования места для. Как приложение определяет содержимое записи, драйвер принимает требуемые действия для дескриптора должна ссылаться на структуру данных достаточный размер.  
  
 SQL_DESC_COUNT не число все столбцы данных, привязанных (если поле в Отменить) или для всех параметров, связанных (если поле в APD), но номер записи наибольший номер. Если отменяется привязка наибольший номер столбца или параметра, SQL_DESC_COUNT меняется на число следующий наибольший номер столбца или параметра. Если столбец или параметр с номером, меньше, чем номер столбца наибольший номер отменяется привязка (путем вызова **SQLBindCol** с *TargetValuePtr* аргумент значение указателя null или **SQLBindParameter** с *ParameterValuePtr* аргумента равным пустой указатель), SQL_DESC_COUNT не изменяется. Дополнительные столбцы или параметры связаны с числами больше, чем наибольший номер записи, содержащий данные, драйвер автоматически увеличивается значение в поле SQL_DESC_COUNT. Если все столбцы являются несвязанных путем вызова **SQLFreeStmt** с параметром SQL_UNBIND поля SQL_DESC_COUNT в IRD и Отменить устанавливаются в значение 0. Если **SQLFreeStmt** вызывается с параметром SQL_RESET_PARAMS поля SQL_DESC_COUNT в APD и IPD устанавливаются в значение 0.  
  
 Значение в SQL_DESC_COUNT может быть задано явным образом приложением, вызвав **SQLSetDescField**. Если значение в SQL_DESC_COUNT явным образом уменьшается, эффективно удаляются все записи с номерами больше, чем новое значение в SQL_DESC_COUNT. Если значение в SQL_DESC_COUNT явно задано значение 0, и поле Отменить, будут освобождены все буфера данных, за исключением столбца привязанного закладки.  
  
 Число записей в этом поле Отменить не включает столбец привязанного закладки. Единственный способ отменить привязку столбца закладки является поле SQL_DESC_DATA_PTR присваивается указатель null.  
  
 **SQL_DESC_ROWS_PROCESSED_PTR [реализации дескрипторы]**  
 В IRD, этот SQLULEN \* заголовок поле указывает на буфер, содержащий количество строк, выбранных после вызова **SQLFetch** или **SQLFetchScroll**, или количество строк, затронутых при помощи массовой операции выполняется путем вызова **SQLBulkOperations** или **SQLSetPos**, включая строки ошибок.  
  
 В IPD этот SQLUINTEGER * заголовок поле указывает на буфер, содержащий число наборов параметров, которые были обработаны, включая наборы ошибки. Число не будут возвращены, если это пустой указатель.  
  
 SQL_DESC_ROWS_PROCESSED_PTR является допустимым только в том случае, после возвращения SQL_SUCCESS или SQL_SUCCESS_WITH_INFO после вызова **SQLFetch** или **SQLFetchScroll** (для IRD-полю) или **SQLExecute** , **SQLExecDirect**, или **SQLParamData** (для IPD-поле). Если вызов, который заполняет в буфере, на который указывает это поле не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определены, если только он не вернет значение SQL_NO_DATA, в котором противном случае это значение в буфер имеет значение 0.  
  
 Также можно задать путем вызова этого поля в Отменить **SQLSetStmtAttr** с помощью атрибута SQL_ATTR_ROWS_FETCHED_PTR. Это поле в дескрипторе параметра приложения также можно задать путем вызова **SQLSetStmtAttr** , атрибут SQL_ATTR_PARAMS_PROCESSED_PTR.  
  
 Буфер, по этому полю выделяется для приложения. Это отложенное выходной буфер, который задается с помощью драйвера. По умолчанию он имеет значение на указатель null.  
  
## <a name="record-fields"></a>Поля записей  
 Каждый дескриптор содержит одну или несколько записей, состоящий из полей, определенных данных столбца или динамических параметров, в зависимости от типа дескриптора. Каждая запись имеет полное определение одного столбца или параметра.  
  
 **SQL_DESC_AUTO_UNIQUE_VALUE [IRDs]**  
 Это только для чтения поле записи SQLINTEGER содержит SQL_TRUE, если столбец является столбцом с автоматическим приращением или SQL_FALSE, если столбец не является столбцом с автоматическим приращением. Это поле доступно только для чтения, но базовый столбец автоприращения не обязательно предназначены только для чтения.  
  
 **SQL_DESC_BASE_COLUMN_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержит имя базового столбца для столбца результирующего набора. Если имя базового столбца не существует (как в случае столбцы, которые являются выражениями), эта переменная содержит пустую строку.  
  
 **SQL_DESC_BASE_TABLE_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержится имя базовой таблицы, для столбца результирующего набора. Если имя базовой таблицы не может быть определен или не применяется, то эта переменная содержит пустую строку.  
  
 **SQL_DESC_CASE_SENSITIVE [реализации дескрипторы]**  
 Это только для чтения поле записи SQLINTEGER содержит SQL_TRUE, если столбец или параметр интерпретируется как с учетом регистра для сортировки и сравнения или значение SQL_FALSE Если столбец не рассматривается как с учетом регистра для сортировки и сравнения или если он является символьным столбец.  
  
 **SQL_DESC_CATALOG_NAME [IRDs]**  
 Это только для чтения SQLCHAR * каталога для базовой таблицы, содержащей столбец содержит поле записи. Возвращаемое значение зависит от драйвера, если столбец является выражением, или если столбец является частью представления. Если источник данных не поддерживает каталоги или каталог не может быть определено, эта переменная содержит пустую строку.  
  
 **SQL_DESC_CONCISE_TYPE [All]**  
 Это поле заголовка SQLSMALLINT тип четкими данных для всех типов данных, включая типы данных даты и времени и интервала.  
  
 Значения в полях SQL_DESC_CONCISE_TYPE, SQL_DESC_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE зависят друг от друга. Устанавливается каждый раз, одно из полей, другой должен иметь значение. Можно задать с помощью вызова SQL_DESC_CONCISE_TYPE **SQLBindCol** или **SQLBindParameter**, или **SQLSetDescField**. Можно задать с помощью вызова SQL_DESC_TYPE **SQLSetDescField** или **SQLSetDescRec**.  
  
 Если SQL_DESC_CONCISE_TYPE имеет значение в тип данных четкими, отличный от типа данных interval или даты и времени, в поле SQL_DESC_TYPE задано то же значение и поле SQL_DESC_DATETIME_INTERVAL_CODE имеет значение 0.  
  
 Если SQL_DESC_CONCISE_TYPE равно четкими тип данных даты-времени или интервала, поле SQL_DESC_TYPE имеет значение соответствующего типа verbose (SQL_DATETIME или SQL_INTERVAL) и полю SQL_DESC_DATETIME_INTERVAL_CODE присваивается соответствующее дополнительным кодом.  
  
 **SQL_DESC_DATA_PTR [дескрипторов приложения и реализации]**  
 Это поле записи указатель SQLPOINTER указывает на переменную, которая будет содержать значение параметра (для APDs) или значение столбца (для ARDs). Это поле является *отложенное поля*. Он не используется во время задано, но используется позже с помощью драйвера для получения данных.  
  
 Столбец, указанный в поле SQL_DESC_DATA_PTR Отменить отменяется, если *TargetValuePtr* аргумента в вызове **SQLBindCol** является пустым указателем или если SQL_DESC_DATA_PTR поля в Отменить задается вызов **SQLSetDescField** или **SQLSetDescRec** на указатель null. Если задан параметр sql_desc_data_ptr на указатель null, другие поля не затрагиваются.  
  
 Если вызов **SQLFetch** или **SQLFetchScroll** , заливки в буфере, это поле не было получено значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.  
  
 Каждый раз, когда будет задан параметр sql_desc_data_ptr APD, Отменить или IPD, драйвер проверяет, значение в поле SQL_DESC_TYPE содержит одно из допустимых типов данных ODBC C или тип данных и что все поля, влияющие на типы данных, согласованы. Проверка целостности запроса является использование только поля SQL_DESC_DATA_PTR IPD. В частности Если приложение задает поле SQL_DESC_DATA_PTR IPD и дальнейшие вызовы **SQLGetDescField** на это поле не является обязательно возвращается значение, которое он значение. Дополнительные сведения см. в разделе «Проверка согласованности» в [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md).  
  
 **SQL_DESC_DATETIME_INTERVAL_CODE [All]**  
 Это поле записи SQLSMALLINT содержит дополнительным кодом для конкретного типа данных даты-времени или интервала, если поле SQL_DESC_TYPE равно SQL_DATETIME или SQL_INTERVAL. Это верно для типов данных SQL и C. Код состоит из имени типа данных с замещен «Тип» или «C_TYPE» (для типов даты и времени) «CODE» или «CODE» замещен «ИНТЕРВАЛ» или «C_INTERVAL» (для типов интервалов).  
  
 Если дескриптор не связан с дескриптором инструкции SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE в дескриптор приложение установлено значение SQL_C_DEFAULT, содержимое SQL_DESC_DATETIME_INTERVAL_CODE не определены.  
  
 В этом поле можно задать для типов данных даты и времени, перечисленные в следующей таблице.  
  
|Типы даты и времени|DATETIME_INTERVAL_CODE|  
|--------------------|------------------------------|  
|SQL_TYPE_DATE/SQL_C_TYPE_DATE|SQL_CODE_DATE|  
|SQL_TYPE_TIME И SQL_C_TYPE_TIME|SQL_CODE_TIME|  
|SQL_TYPE_TIMESTAMP / SQL_C_TYPE_TIMESTAMP|SQL_CODE_TIMESTAMP|  
  
 В этом поле можно задать для типа данных interval, перечисленные в следующей таблице.  
  
|Тип интервала|DATETIME_INTERVAL_CODE|  
|-------------------|------------------------------|  
|SQL_INTERVAL_DAY / SQL_C_INTERVAL_DAY|SQL_CODE_DAY|  
|SQL_INTERVAL_DAY_TO_HOUR / SQL_C_INTERVAL_DAY_TO_HOUR|SQL_CODE_DAY_TO_HOUR|  
|SQL_INTERVAL_DAY_TO_MINUTE / SQL_C_INTERVAL_DAY_TO_MINUTE|SQL_CODE_DAY_TO_MINUTE|  
|SQL_INTERVAL_DAY_TO_SECOND / SQL_C_INTERVAL_DAY_TO_SECOND|SQL_CODE_DAY_TO_SECOND|  
|SQL_INTERVAL_HOUR / SQL_C_INTERVAL_HOUR|SQL_CODE_HOUR|  
QL_INTERVAL_HOUR_TO_MINUTE / SQL_C_INTERVAL_HOUR_TO_MINUTE|SQL_CODE_HOUR_TO_MINUTE|  
|SQL_INTERVAL_HOUR_TO_SECOND / SQL_C_INTERVAL_HOUR_TO_SECOND|SQL_CODE_HOUR_TO_SECOND|  
|SQL_INTERVAL_MINUTE / SQL_C_INTERVAL_MINUTE|SQL_CODE_MINUTE|  
|SQL_INTERVAL_MINUTE_TO_SECOND / SQL_C_INTERVAL_MINUTE_TO_SECOND|SQL_CODE_MINUTE_TO_SECOND|  
|SQL_INTERVAL_MONTH / SQL_C_INTERVAL_MONTH|SQL_CODE_MONTH|  
QL_INTERVAL_SECOND / SQL_C_INTERVAL_SECOND|SQL_CODE_SECOND|  
|SQL_INTERVAL_YEAR / SQL_C_INTERVAL_YEAR|SQL_CODE_YEAR|  
|SQL_INTERVAL_YEAR_TO_MONTH / SQL_C_INTERVAL_YEAR_TO_MONTH|SQL_CODE_YEAR_TO_MONTH|  
  
 Дополнительные сведения о интервалов данных, а это поле в разделе [данных идентификаторы и дескрипторы типов](../../../odbc/reference/appendixes/data-type-identifiers-and-descriptors.md).  
  
 **SQL_DESC_DATETIME_INTERVAL_PRECISION [All]**  
 Это поле записи SQLINTEGER содержит точности интервала, если поле SQL_DESC_TYPE SQL_INTERVAL. Если поле SQL_DESC_DATETIME_INTERVAL_CODE имеет значение к типу данных интервала, это поле имеет значение точности интервала по умолчанию.  
  
 **Столбцов SQL_DESC_DISPLAY_SIZE [IRDs]**  
 Это только для чтения поле записи SQLINTEGER содержит максимальное количество символов, необходимых для отображения данных из столбца.  
  
 **SQL_DESC_FIXED_PREC_SCALE [реализации дескрипторы]**  
 Это поле записи SQLSMALLINT только для чтения имеет значение SQL_TRUE, если столбец является столбцом точные числовые и фиксированные точность и масштаб ненулевое значение, или значение SQL_FALSE, если столбец не точного числового столбца с фиксированной точностью и масштабом.  
  
 **SQL_DESC_INDICATOR_PTR [дескрипторы приложения]**  
 В ARDs этот SQLLEN * записи поле точек для этой переменной. Эта переменная содержит SQL_NULL_DATA, если столбец содержит значение NULL. Для APDs этой переменной присвоено значение SQL_NULL_DATA укажите динамические аргументы NULL. В противном случае переменная равно нулю (если значения в SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR не тот же указатель).  
  
 Если поле SQL_DESC_INDICATOR_PTR Отменить является указателем null, драйвер будет запрещено возврат сведений о является ли столбец значение NULL или нет. Если столбец имеет значение NULL и SQL_DESC_INDICATOR_PTR является пустым указателем, SQLSTATE 22002 (индикатор но не была предоставлена) возвращается, когда драйвер пытается заполнения буфера после вызова **SQLFetch** или  **SQLFetchScroll**. Если вызов **SQLFetch** или **SQLFetchScroll** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определены.  
  
 Поле SQL_DESC_INDICATOR_PTR определяет, имеет ли значение поля, на который указывает SQL_DESC_OCTET_LENGTH_PTR. Если значение столбца равно NULL, драйвер задает этой переменной значение SQL_NULL_DATA. Поле, на который указывает SQL_DESC_OCTET_LENGTH_PTR не устанавливается. Если значения NULL не обнаружено во время выборки, буфера, SQL_DESC_INDICATOR_PTR, установленным равным нулю и буфера, на который указывает SQL_DESC_OCTET_LENGTH_PTR задано значение длины данных.  
  
 Если поле SQL_DESC_INDICATOR_PTR в APD является пустым указателем, приложение не может использовать эту запись дескриптора для указания аргументов NULL.  
  
 Это поле является *отложенное поле*: он не используется во время задано, но используется позже с помощью драйвера требуется указать допустимость значений NULL (ARDs) или требуется определить допустимость значений NULL (для APDs).  
  
 **SQL_DESC_LABEL [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержится название или метки столбца. Если столбец не имеет метки, эта переменная содержит имя столбца. Если столбец является безымянным и без метки, эта переменная содержит пустую строку.  
  
 **SQL_DESC_LENGTH [All]**  
 Это поле записи SQLULEN является либо максимальная или фактические Длина символьной строки в символах или двоичный тип данных в байтах. Это максимальная длина для типа данных фиксированной длины или фактическую длину для типа данных переменной длины. Его значение всегда исключает символ конечное значение null, завершающий строку символов. Для значения, тип которого является SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP или один из типов данных SQL интервала это поле имеет длину в символах символ строкового представления значения даты и времени или интервала.  
  
 Значение в этом поле может отличаться от значения «Длина» как определено в ODBC 2*.x*. Дополнительные сведения см. в разделе [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_LITERAL_PREFIX [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержит символ или символы, которые драйвер распознает как префикс для литерала этого типа данных. Эта переменная содержит пустую строку для типа данных, для которого литеральный префикс не применим.  
  
 **SQL_DESC_LITERAL_SUFFIX [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержит символ или символы, которые драйвер распознает как суффикс для литерала этого типа данных. Эта переменная содержит пустую строку для типа данных, для которого литеральный суффикс не применим.  
  
 **SQL_DESC_LOCAL_TYPE_NAME [реализации дескрипторы]**  
 Это только для чтения SQLCHAR * поле записи содержит все локализованные (собственное) название языка для типа данных, который может отличаться от имени обычных типа данных. Если отсутствует локализованное имя, возвращается пустая строка. Это поле доступно только для отображения.  
  
 **SQL_DESC_NAME [реализации дескрипторы]**  
 Это SQLCHAR * поле записи в дескриптор строки содержит псевдоним столбца, если он применяется. Если псевдоним столбца не применимо, возвращается имя столбца. В любом случае драйвер устанавливает SQL_DESC_UNNAMED поля SQL_NAMED при определении поля SQL_DESC_NAME. Если имя столбца отсутствует или псевдоним столбца, драйвер возвращает пустую строку в поля SQL_DESC_NAME и устанавливает поля SQL_DESC_UNNAMED SQL_UNNAMED.  
  
 Имя параметра или псевдоним, чтобы указать параметры хранимой процедуры по имени приложения можно задать поля SQL_DESC_NAME IPD. (Дополнительные сведения см. в разделе [привязка параметров по имени (именованные параметры)](../../../odbc/reference/develop-app/binding-parameters-by-name-named-parameters.md).) Поле SQL_DESC_NAME IRD — это поле только для чтения; SQLSTATE HY091 (недопустимый идентификатор поля дескриптора), будет возвращено в том случае, если приложение пытается установить его.  
  
 В реализации это поле не определено, если драйвер не поддерживает именованные параметры. Если драйвер поддерживает именованные параметры и пригоден для описания параметров, в этом поле возвращается имя параметра.  
  
 **SQL_DESC_NULLABLE [реализации дескрипторы]**  
 В IRDs это только для чтения поле записи SQLSMALLINT является SQL_NULLABLE, если столбец может иметь значения NULL, SQL_NO_NULLS, если столбец не имеет значения NULL или SQL_NULLABLE_UNKNOWN, если неизвестно, допускает ли столбец значения NULL. Это поле относится к столбцу результирующего набора не базового столбца.  
  
 В реализации это поле всегда равно SQL_NULLABLE поскольку динамических параметров всегда допускают значение NULL и не может быть приложением.  
  
 **SQL_DESC_NUM_PREC_RADIX [All]**  
 Это поле SQLINTEGER содержит значение 2, если тип данных в поле SQL_DESC_TYPE является приблизительных числовых данных, так как поле SQL_DESC_PRECISION содержит число битов. Это поле содержит значение 10, если тип данных в поле SQL_DESC_TYPE является точных числовых данных, так как поле SQL_DESC_PRECISION содержит количество цифр дробной части. Это поле имеет значение 0 для всех типов нечисловые данные.  
  
 **SQL_DESC_OCTET_LENGTH [All]**  
 Это поле записи SQLLEN содержит длину в байтах символьной строки или двоичный тип данных. Для фиксированной длины символьных и двоичных типов это фактическая длина в байтах. Для переменной длины символьных и двоичных типов это максимальная длина в байтах. Это значение всегда исключает место для символа конечное значение null для реализации дескрипторов и всегда включает место для символа дескрипторы приложения, конечное значение null. Для данных приложений это поле содержит размер буфера. Для APDs это поле определяется только для вывода или параметров ввода вывода.  
  
 **SQL_DESC_OCTET_LENGTH_PTR [дескрипторы приложения]**  
 Это SQLLEN * записи поле указывает на переменную, которая будет содержать общая длина в байтах динамического аргумента (для параметра дескрипторы) или значение привязанного столбца (для дескрипторов строк).  
  
 Для APD это значение игнорируется для всех аргументов, за исключением символьная строка и двоичный файл; Если это поле указывает SQL_NTS, динамические аргумент должен быть символом null. Указать, что привязанного параметра будет параметра данных во время выполнения, приложение задает это поле в соответствующую запись APD переменной, во время, исполнения будет содержать значение SQL_DATA_AT_EXEC или результата SQL_LEN_DATA_AT_EXEC макроса . Если имеется более одного поля, SQL_DESC_DATA_PTR может быть присвоено значение, уникально идентифицирующее параметра помогут определить, какой параметр запрашивается приложения.  
  
 Если в поле OCTET_LENGTH_PTR Отменить является указателем null, драйвер не возвращает сведения о длине столбца. Если поле SQL_DESC_OCTET_LENGTH_PTR в APD является указателем null, драйвер предполагается, что символьные строки, а также двоичные значения символом null. (Двоичных значений не должно быть нулем, но должны быть даны длину, чтобы избежать усечения.)  
  
 Если вызов **SQLFetch** или **SQLFetchScroll** , заливки в буфере, это поле не было получено значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено. Это поле является *отложенное поля*. Он не используется во время задано, но используется позже с помощью драйвера для определения или указания октет длины данных.  
  
 **SQL_DESC_PARAMETER_TYPE [реализации]**  
 Это поле записи SQLSMALLINT установлено значение SQL_PARAM_INPUT для входного параметра, SQL_PARAM_INPUT_OUTPUT для параметра ввода вывода, SQL_PARAM_OUTPUT для выходного параметра, SQL_PARAM_INPUT_OUTPUT_STREAM для параметра потокового ввода вывода или SQL_ PARAM_OUTPUT_STREAM для потоковой передачи выходной параметр. По умолчанию он имеет значение для SQL_PARAM_INPUT.  
  
 Для IPD поле имеет значение SQL_PARAM_INPUT по умолчанию если IPD не заполняется автоматически с помощью драйвера (атрибут инструкции SQL_ATTR_ENABLE_AUTO_IPD — SQL_FALSE). Приложение должно установить это поле в IPD для параметров, которые не являются входными параметрами.  
  
 **SQL_DESC_PRECISION [All]**  
 Это поле записи SQLSMALLINT содержит количество цифр для точных числовых типов, количество битов в мантиссе (точность двоичного представления) для приблизительный числовой тип или число цифр в компоненте долей секунды для SQL_TYPE_TIME SQL_TYPE _TIMESTAMP или SQL_INTERVAL_SECOND типом данных. Это поле не определено для всех других типов данных.  
  
 Значение в этом поле может отличаться от значения «точность» как определено в ODBC 2*.x*. Дополнительные сведения см. в разделе [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_ROWVER [реализации дескрипторы]**  
 Это поле SQLSMALLINTrecord указывает, является ли столбец автоматически изменяется СУБД обновления строки (например, столбец типа «timestamp» в SQL Server). Это поле записи имеет значение SQL_TRUE, если столбец является столбцом управление версиями строк, а также SQL_FALSE в противном случае. Этот атрибут столбца аналогично вызову **SQLSpecialColumns** с IdentifierType SQL_ROWVER, чтобы определить, является ли столбец автоматически обновляется.  
  
 **SQL_DESC_SCALE [All]**  
 Это поле записи SQLSMALLINT содержит определенный масштаб для десятичных и числовых типов данных. Поле не определено для всех других типов данных.  
  
 Значение в этом поле может отличаться от значения «scale», как определено в ODBC 2*.x*. Дополнительные сведения см. в разделе [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).  
  
 **SQL_DESC_SCHEMA_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержится имя схемы, содержащей столбец базовой таблицы. Возвращаемое значение зависит от драйвера, если столбец является выражением, или если столбец является частью представления. Если источник данных не поддерживает схемы или не удается определить имя схемы, эта переменная содержит пустую строку.  
  
 **SQL_DESC_SEARCHABLE [IRDs]**  
 Это только для чтения поле записи SQLSMALLINT присваивается одно из следующих значений:  
  
-   SQL_PRED_NONE, если столбец не может использоваться в **ГДЕ** предложения. (Это то же самое значение SQL_UNSEARCHABLE в ODBC 2*.x*.)  
  
-   SQL_PRED_CHAR, если столбец может использоваться в **ГДЕ** предложение, но только с **как** предиката. (Это то же самое значение SQL_LIKE_ONLY в ODBC 2*.x*.)  
  
-   SQL_PRED_BASIC, если столбец может использоваться в **ГДЕ** предложение со всеми операторами сравнения, за исключением **как**. (Это то же самое значение SQL_EXCEPT_LIKE в ODBC 2*.x*.)  
  
-   SQL_PRED_SEARCHABLE, если столбец может использоваться в **ГДЕ** предложение с любым оператором сравнения.  
  
 **SQL_DESC_TABLE_NAME [IRDs]**  
 Это только для чтения SQLCHAR * поле записи содержится имя базовой таблицы, который содержит этот столбец. Возвращаемое значение зависит от драйвера, если столбец является выражением, или если столбец является частью представления.  
  
 **SQL_DESC_TYPE [All]**  
 Это поле записи SQLSMALLINT указывает четкими SQL или C тип данных для всех типов данных, за исключением типов данных даты и времени и интервала. Для типов данных даты и времени и интервала это поле указывает тип подробных данных, который равно SQL_DATETIME или SQL_INTERVAL.  
  
 Каждый раз, когда в этом поле содержится SQL_DATETIME или SQL_INTERVAL, SQL_DESC_DATETIME_INTERVAL_CODE поле должно содержать соответствующие дополнительным кодом для краткого типа. Для типов данных даты и времени SQL_DESC_TYPE содержит SQL_DATETIME и SQL_DESC_DATETIME_INTERVAL_CODE поле содержит дополнительный код для типа данных для определенной даты и времени. Для типов данных интервала SQL_DESC_TYPE содержит SQL_INTERVAL и SQL_DESC_DATETIME_INTERVAL_CODE поле содержит дополнительный код для типа данных, определенный интервал времени.  
  
 Значения в полях SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE зависят друг от друга. Устанавливается каждый раз, одно из полей, другой должен иметь значение. Можно задать с помощью вызова SQL_DESC_TYPE **SQLSetDescField** или **SQLSetDescRec**. Можно задать с помощью вызова SQL_DESC_CONCISE_TYPE **SQLBindCol** или **SQLBindParameter**, или **SQLSetDescField**.  
  
 Если SQL_DESC_TYPE устанавливается тип четкими данных отличается от типа данных interval или даты и времени, в поле SQL_DESC_CONCISE_TYPE задано то же значение, и поле SQL_DESC_DATETIME_INTERVAL_CODE имеет значение 0.  
  
 Если SQL_DESC_TYPE устанавливается verbose datetime или тип данных интервала (SQL_DATETIME или SQL_INTERVAL) и в поле SQL_DESC_DATETIME_INTERVAL_CODE задано для соответствующего дополнительным кодом, поле ТИПА SQL_DESC_CONCISE присваивается четкими соответствующего типа. Попытка установить SQL_DESC_TYPE в один из краткого типов даты-времени или интервала вернет SQLSTATE HY021 (неправильные сведения о дескрипторе).  
  
 Когда поле SQL_DESC_TYPE устанавливается с помощью вызова **SQLBindCol**, **SQLBindParameter**, или **SQLSetDescField**, следующие поля задаются следующие значения по умолчанию как показано в следующей таблице. Остальные поля из той же записи значения не определены.  
  
|Значение SQL_DESC_TYPE|Остальные поля неявно задать|  
|------------------------------|---------------------------------|  
|SQL_CHAR, SQL_VARCHAR, SQL_C_CHAR, SQL_C_VARCHAR|SQL_DESC_LENGTH имеет значение 1. SQL_DESC_PRECISION имеет значение 0.|  
|SQL_DATETIME|Если имеет значение SQL_DESC_DATETIME_INTERVAL_CODE SQL_CODE_DATE или SQL_CODE_TIME, SQL_DESC_PRECISION имеет значение 0. Если значение SQL_DESC_TIMESTAMP SQL_DESC_PRECISION задано значение 6.|  
|SQL_C_NUMERIC SQL_DECIMAL SQL_NUMERIC,|SQL_DESC_SCALE имеет значение 0. SQL_DESC_PRECISION имеет значение определяемого реализацией точность для типа данных.<br /><br /> В разделе [SQL C: цифровыми](../../../odbc/reference/appendixes/sql-to-c-numeric.md) сведения о том, как вручную связать значение SQL_C_NUMERIC.|  
|SQL_FLOAT SQL_C_FLOAT|Имеет значение SQL_DESC_PRECISION точность по умолчанию, определяемое реализацией для SQL_FLOAT.|  
|SQL_INTERVAL|Если к типу данных интервал имеет значение SQL_DESC_DATETIME_INTERVAL_CODE, SQL_DESC_DATETIME_INTERVAL_PRECISION имеет значение 2 (точность по умолчанию интервал начальные). Если интервал компонент секунд, SQL_DESC_PRECISION задано значение 6 (точность секунд интервал по умолчанию).|  
  
 Если приложение вызывает **SQLSetDescField** поля дескриптора, вместо вызова метода можно установить **SQLSetDescRec**, приложение необходимо сначала объявить тип данных. Когда это происходит, неявно устанавливаются другие поля, отмеченные в предыдущей таблице. Если какие-либо значения неявно набор неприемлемо, приложение может затем вызвать **SQLSetDescField** или **SQLSetDescRec** задать явным образом недопустимые значения.  
  
 **SQL_DESC_TYPE_NAME [реализации дескрипторы]**  
 Это только для чтения SQLCHAR * записи поле содержит имя типа зависит от источника данных (например, «CHAR», «VARCHAR» и так далее). Если неизвестно имя типа данных, эта переменная содержит пустую строку.  
  
 **SQL_DESC_UNNAMED [реализации дескрипторы]**  
 Это поле SQLSMALLINT записи в дескриптор строки имеет значение драйвером SQL_NAMED или SQL_UNNAMED, если он задает поля SQL_DESC_NAME. Если поля SQL_DESC_NAME содержит псевдоним столбца или псевдонима столбца не применяется, драйвер устанавливает поля SQL_DESC_UNNAMED SQL_NAMED. Если приложение устанавливает поля SQL_DESC_NAME для IPD параметра имя или псевдоним, драйвер устанавливает поля SQL_DESC_UNNAMED для IPD SQL_NAMED. Если имя столбца отсутствует или псевдоним столбца, драйвер устанавливает поля SQL_DESC_UNNAMED SQL_UNNAMED.  
  
 Приложение может установить поле SQL_DESC_UNNAMED IPD для SQL_UNNAMED. Драйвер возвращает SQLSTATE HY091 (недопустимый идентификатор поля дескриптора) Если приложение пытается получить значение поля SQL_DESC_UNNAMED IPD SQL_NAMED. В поле SQL_DESC_UNNAMED IRD является только для чтения. SQLSTATE HY091 (недопустимый идентификатор поля дескриптора), будет возвращено в том случае, если приложение пытается установить его.  
  
 **SQL_DESC_UNSIGNED [реализации дескрипторы]**  
 Это только для чтения поле записи SQLSMALLINT задано значение SQL_TRUE, если столбец имеет тип без знака, так и нечисловых или SQL_FALSE, если тип столбца подписан.  
  
 **SQL_DESC_UPDATABLE [IRDs]**  
 Это только для чтения поле записи SQLSMALLINT присваивается одно из следующих значений:  
  
-   SQL_ATTR_READ_ONLY, если столбец результирующего набора только для чтения.  
  
-   SQL_ATTR_WRITE, если столбец результирующего набора — чтение и запись.  
  
-   Обновить SQL_ATTR_READWRITE_UNKNOWN, если он не является ли столбец результирующего набора, или нет.  
  
 SQL_DESC_UPDATABLE описывает возможность обновления столбца в результирующем наборе, не столбец в базовой таблице. Возможность обновления столбца в базовой таблице, на котором основан этот столбец результирующего набора может отличаться от значения в этом поле. Является ли столбец обновляемых может основываться на тип данных, права доступа пользователя и определения результирующего набора, сам. Если неясно, является ли столбец является обновляемым, SQL_ATTR_READWRITE_UNKNOWN должно быть возвращено.  
  
## <a name="consistency-checks"></a>Проверка согласованности  
 Проверка согласованности выполняется драйвер автоматически каждый раз, когда приложение передает значение для поля SQL_DESC_DATA_PTR Отменить, APD или IPD. Если любое из полей не согласуется с другими полями **SQLSetDescField** вернет SQLSTATE HY021 (неправильные сведения о дескрипторе). Дополнительные сведения см. в разделе «Проверка согласованности» в [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка столбца|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Привязка параметра|[Функция SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md)|  
|Получение дескриптора поля|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Задание нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Справочник по API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)
