---
title: Функция SQLFetchScroll | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
apiname:
- SQLFetchScroll
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLFetchScroll
helpviewer_keywords:
- SQLFetchScroll function [ODBC]
ms.assetid: c0243667-428c-4dda-ae91-3c307616a1ac
caps.latest.revision: 30
author: MightyPen
ms.author: genemi
manager: craigg
ms.workload: Inactive
ms.openlocfilehash: e8b244a9b4e6923c6455ea84175ed1557ec4100a
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="sqlfetchscroll-function"></a>Функция SQLFetchScroll
**Соответствия**  
 Появился в версии: ODBC 3.0 нормативных требований: ISO-92  
  
 **Сводка**  
 **SQLFetchScroll** Извлекает указанный набор строк данных из результирующего набора и возвращает данные для всех связанных столбцов. Наборы строк можно указать в абсолютные или относительные позиции или по закладке.  
  
 При работе с драйвером ODBC 2.x, диспетчер драйверов сопоставляет эту функцию для **SQLExtendedFetch**. Дополнительные сведения см. в разделе [сопоставление замены функций для обеспечения обратной совместимости приложений](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLFetchScroll(  
      SQLHSTMT      StatementHandle,  
      SQLSMALLINT   FetchOrientation,  
      SQLLEN        FetchOffset);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *FetchOrientation*  
 [Вход]  
  
 Тип выборки:  
  
 SQL_FETCH_NEXT  
  
 SQL_FETCH_PRIOR  
  
 SQL_FETCH_FIRST  
  
 SQL_FETCH_LAST  
  
 SQL_FETCH_ABSOLUTE  
  
 SQL_FETCH_RELATIVE  
  
 ИНСТРУКЦИЯ SQL_FETCH_BOOKMARK  
  
 Дополнительные сведения см. в разделе «Позиционирования курсора» в разделе «Примечания».  
  
 *FetchOffset*  
 [Вход]  
  
 Количество строк для выборки. Интерпретация этого аргумента зависит от значения *FetchOrientation* аргумент. Дополнительные сведения см. в разделе «Позиционирования курсора» в разделе «Примечания».  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLFetchScroll** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с HandleType значение SQL_HANDLE_STMT и дескриптора StatementHandle. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLFetchScroll** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное. При возникновении ошибки для одного столбца, **SQLGetDiagField** может быть вызван с DiagIdentifier SQL_DIAG_COLUMN_NUMBER определение столбца, произошла ошибка, и **SQLGetDiagField** может быть вызван Этот столбец содержит DiagIdentifier SQL_DIAG_ROW_NUMBER для определения удаляемой строки.  
  
 Для всех этих SQLSTATE, которые могут возвращать значение SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением SQLSTATE 01xxx), возвращается SQL_SUCCESS_WITH_INFO, если в одной или нескольким, но не для всех строк многострочные операции происходит ошибка, и возвращается значение SQL_ERROR, если произошла ошибка Операция одной строки.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Строка справа усечение данных|Строка или двоичные данные, возвращаемые для столбца привело к усечению непустых символьных или двоичных данных от NULL. Если он был строковое значение, было усечено справа.|  
|01S01|Ошибка в строке|Произошла ошибка при получении одну или несколько строк.<br /><br /> (Если это SQLSTATE возвращается в том случае, когда ODBC 3*.x* при работе с ODBC 2*.x* драйвера, его можно пропустить.)|  
|01S06|Попытка выборки до появления результирующий набор возвращается первый набор строк|Запрошенный набор строк перекрывающегося начала результирующий набор, если FetchOrientation была SQL_FETCH_PRIOR, текущая позиция вышла за пределы первой строки и номер текущей строки меньше или равно размеру набора строк.<br /><br /> Запрошенный набор строк перекрывающегося начала результирующий набор, если FetchOrientation был SQL_FETCH_PRIOR, текущая позиция было за пределами результирующего набора, а размер набора строк было больше размер набора результатов.<br /><br /> Запрошенный набор строк перекрывающегося начала результирующий набор, если FetchOrientation была SQL_FETCH_RELATIVE, было отрицательным FetchOffset и абсолютное значение FetchOffset было меньше или равно размеру набора строк.<br /><br /> Запрошенный набор строк перекрывающегося начала результирующий набор, если FetchOrientation была SQL_FETCH_ABSOLUTE, было отрицательным FetchOffset и абсолютное значение FetchOffset был больше размера набора результатов, но меньше или равно размеру набора строк.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S07|Частичное усечение|Данные, возвращенные для столбца было усечено. Для числовых типов данных был усечен, дробная часть числа. Время, отметка времени и интервальных типов данных, содержащего компонент времени дробная часть времени было усечено.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение столбца в результирующем наборе не удалось преобразовать тип данных, указанный в *TargetType* в **SQLBindCol**.<br /><br /> Столбец 0 был связан с типом данных SQL_C_BOOKMARK и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было задано значение SQL_UB_VARIABLE.<br /><br /> Столбец 0 был связан с типом данных SQL_C_VARBOOKMARK и не равно SQL_UB_VARIABLE атрибут SQL_ATTR_USE_BOOKMARKS инструкции.|  
|07009|Недопустимый индекс дескриптора|Драйвер не ODBC 2*.x* драйвер, который не поддерживает **SQLExtendedFetch**, и номер столбца, указанный в привязке для столбца было равно 0.<br /><br /> Столбец 0 был привязан и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было задано значение SQL_UB_OFF.|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22001|Строка справа усечение данных|Был усечен, возвращаемый для столбцов переменной длины закладки.|  
|22002|Индикатор обязательным, но не указано|Значение NULL, данные, которые были выбраны в столбец, *StrLen_or_IndPtr* задается **SQLBindCol** (или заданные SQL_DESC_INDICATOR_PTR **SQLSetDescField** или  **SQLSetDescRec**) является пустым указателем.|  
|22003|Численное значение вне допустимого диапазона|Возвращает числовое значение (как числовое или строковое) для одного или нескольких связанных столбцов могло привести целиком (в отличие от доли) часть усекаемое число.<br /><br /> Дополнительные сведения см. в разделе [преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22007|Формат недопустимые даты и времени|Символьный столбец в результирующем наборе был привязан к даты, времени или структура отметки времени C, а значение в столбце было, соответственно, неверной даты, времени или отметки времени.|  
|22012|Деление на ноль|Значение от арифметического выражения был возвращен, что привело к деления на ноль.|  
|22015|Переполнение поля интервала|Присвоение тип интервала C из точное числовое значение или интервал тип SQL привело к потере значащих разрядов в начале поля.<br /><br /> При получении данных для тип интервала C, возникла не представление значения в тип интервала C типа SQL.|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе был привязан к буфер символов C, а столбец содержится символ, для которого отсутствует в наборе символов буфера не представление.<br /><br /> Тип C был точное или Приблизительное числовое, datetime или тип интервала; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.|  
|24000|Недопустимое состояние курсора|*StatementHandle* находился в состоянии выполнения, но результирующий набор не связан с *StatementHandle*.|  
|40001|Сбой сериализации|Транзакции, в которой была выполнена выборка прервано для предотвращения взаимоблокировок.|  
|40003|Неизвестный завершение операторов|Сбой подключения во время выполнения этой функции и не удается определить состояние транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом асинхронной функция **SQLFetchScroll** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ЭТОТ ПАРАМЕТР ДОСТУПЕН. До получения данных для всех параметров потоковой вызове этой функции.<br /><br /> (DM) указанного *StatementHandle* не находился в состоянии выполнения. Функция была вызвана без предварительного вызова функции **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.<br /><br /> (DM) **SQLFetch** был вызван для *StatementHandle* после **SQLExtendedFetch** был вызван и перед **SQLFreeStmt** с SQL_ Параметр «ЗАКРЫТЬ» был вызван.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Атрибут инструкции SQL_ATTR_USE_BOOKMARK было задано значение SQL_UB_VARIABLE и 0 был привязан к буфера, длина которого не равно Максимальная длина закладки для этого результирующего набора. (Эта длина доступен в поле SQL_DESC_OCTET_LENGTH IRD и может быть получен путем вызова **SQLDescribeCol**, **SQLColAttribute**, или **SQLGetDescField**.)|  
|HY106|Тип выборки за пределами допустимого диапазона|Интеллектуальный анализ данных) Недопустимое значение, указанное в аргументе FetchOrientation.<br /><br /> (DM) аргумент FetchOrientation был SQL_FETCH_BOOKMARK и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было задано значение SQL_UB_OFF.<br /><br /> Значение атрибута SQL_ATTR_CURSOR_TYPE инструкция была SQL_CURSOR_FORWARD_ONLY, а значение аргумента FetchOrientation не SQL_FETCH_NEXT.<br /><br /> Значение атрибута инструкции SQL_ATTR_CURSOR_SCROLLABLE было SQL_NONSCROLLABLE и значение аргумента FetchOrientation не SQL_FETCH_NEXT.|  
|HY107|Значение строки за пределами диапазона|Значение, указанное с помощью атрибута SQL_ATTR_CURSOR_TYPE оператор был SQL_CURSOR_KEYSET_DRIVEN, но значение, указанное с помощью атрибута SQL_ATTR_KEYSET_SIZE атрибута инструкции больше 0 и меньше, чем значение, указанное в SQL_ATTR_ROW_ARRAY_ Атрибут инструкции размер.|  
|HY111|Недопустимый закладок|Аргумент FetchOrientation было SQL_FETCH_BOOKMARK и закладки, на который указывает значение атрибута инструкции SQL_ATTR_FETCH_BOOKMARK_PTR недопустимо или является пустым указателем.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает преобразование, определяется сочетанием *TargetType* в **SQLBindCol** и тип данных SQL соответствующего столбца.|  
|HYT00|Время ожидания истекло|Прежде чем источника данных, запрошенный результирующий набор истечения времени ожидания запроса. Время ожидания задается SQLSetStmtAttr SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
  
## <a name="comments"></a>Комментарии  
 **SQLFetchScroll** возвращает указанный набор строк из результирующего набора. Наборы строк можно указать по абсолютные или относительные позиции или закладки. **SQLFetchScroll** может быть вызван, пока существует результирующий набор, то есть после вызова метода, который создает результирующий набор и перед курсор закрыт over, результирующий набор. Если какие-либо столбцы привязаны, возвращающий данные в этих столбцах. Если приложение указатель на массив состояния строк или буфер, в которую возвращается число возвращаемых строк, **SQLFetchScroll** возвращает эти сведения также. Вызовы **SQLFetchScroll** можно комбинировать с вызовами **SQLFetch** , но невозможно комбинировать с вызовами **SQLExtendedFetch**.  
  
 Дополнительные сведения см. в разделе [использование блочных курсоров](../../../odbc/reference/develop-app/using-block-cursors.md) и [с помощью Прокручиваемые курсоры](../../../odbc/reference/develop-app/using-scrollable-cursors.md).  
  
## <a name="positioning-the-cursor"></a>Позиционирование курсора  
 Когда создается результирующий набор, курсор располагается перед началом результирующего набора. **SQLFetchScroll** помещает курсор блок, на основе значений из *FetchOrientation* и *FetchOffset* аргументы, как показано в следующей таблице. В следующем разделе показаны конкретные правила для определения начала нового набора строк.  
  
|FetchOrientation|Значение|  
|----------------------|-------------|  
|SQL_FETCH_NEXT|Возвращает следующий набор строк. Это эквивалентно вызову **SQLFetch**.<br /><br /> **SQLFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_PRIOR|Возвращает предыдущий набор строк.<br /><br /> **SQLFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_RELATIVE|Возвращает набор строк *FetchOffset* от начала текущего набора строк.|  
|SQL_FETCH_ABSOLUTE|Возвращают набор строк, начиная со строки *FetchOffset*.|  
|SQL_FETCH_FIRST|Возвращает первый набор строк в результирующем наборе.<br /><br /> **SQLFetchScroll** игнорирует значение *FetchOffset*.|  
|SQL_FETCH_LAST|Возвращает последний полный набор строк в результирующем наборе.<br /><br /> **SQLFetchScroll** игнорирует значение *FetchOffset*.|  
|ИНСТРУКЦИЯ SQL_FETCH_BOOKMARK|Возвращает набор строк FetchOffset строки от закладки, указанный атрибутом инструкции SQL_ATTR_FETCH_BOOKMARK_PTR.|  
  
 Драйверы не требуются для поддержки всех ориентациях выборки; приложение вызывает **SQLGetInfo** с типом сведения SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_CURSOR_ATTRIBUTES1 (в зависимости от типа курсора) чтобы определить, какие инструкции fetch ориентации экрана поддерживаются драйвером. Приложения должен заняться битовой маски SQL_CA1_NEXT, SQL_CA1_RELATIVE, SQL_CA1_ABSOLUTE и WQL_CA1_BOOKMARK в эти типы информации. Кроме того, если курсор последовательного доступа и FetchOrientation не SQL_FETCH_NEXT, **SQLFetchScroll** возвращает SQLSTATE HY106 (тип выборки за пределами диапазона).  
  
 Атрибут SQL_ATTR_ROW_ARRAY_SIZE инструкции указывает число строк в наборе строк. Если набор строк возвращаемых при **SQLFetchScroll** перекрывается конца результирующего набора, **SQLFetchScroll** возвращает частичный набор строк. То есть если S + R – 1 больше, чем L, где S — начальную строку набора строк выбранных, R равно размеру набора строк, а L является последней строки в результирующем наборе, затем первый L – S + 1 строк набора строк являются допустимыми. Оставшиеся строки являются пустыми и имеют статус SQL_ROW_NOROW.  
  
 После **SQLFetchScroll** возвращает, текущая строка является первой строки набора строк.  
  
## <a name="cursor-positioning-rules"></a>Правила позиционирования курсора  
 В следующих разделах описаны конкретные правила для каждого значения FetchOrientation. Эти правила нотация.  
  
|Нотация|Значение|  
|--------------|-------------|  
|*Перед запуском*|Прямоугольный курсор располагается перед началом результирующего набора. Перед началом результирующего набора, если первая строка новый набор строк **SQLFetchScroll** не вернет значение SQL_NO_DATA.|  
|*После окончания*|Прямоугольный курсор располагается после конце результирующего набора. Если первая строка новый набор строк в конце результирующего набора, **SQLFetchScroll** не вернет значение SQL_NO_DATA.|  
|*CurrRowsetStart*|Номер первой строки в текущем наборе строк.|  
|*LastResultRow*|Номер последней строки в результирующем наборе.|  
|*RowsetSize*|Размер набора строк.|  
|*FetchOffset*|Значение *FetchOffset* аргумент.|  
|*BookmarkRow*|Строка, соответствующая закладки, указанный атрибутом инструкции SQL_ATTR_FETCH_BOOKMARK_PTR.|  
  
## <a name="sqlfetchnext"></a>SQL_FETCH_NEXT  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*Перед запуском*|1|  
|*CurrRowsetStart + RowsetSize*[1]  *\<= LastResultRow*|*CurrRowsetStart + RowsetSize*[1]|  
|*CurrRowsetStart + RowsetSize*[1]*> LastResultRow*|*После окончания*|  
|*После окончания*|*После окончания*|  
  
 [1] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это размер набора строк, который использовался с предыдущим вызовом функции.  
  
## <a name="sqlfetchprior"></a>SQL_FETCH_PRIOR  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*Перед запуском*|*Перед запуском*|  
|*CurrRowsetStart = 1*|*Перед запуском*|  
|*1 < CurrRowsetStart < = RowsetSize* <sup>[2].</sup>|*1* <sup>[1]</sup>|  
|*CurrRowsetStart > RowsetSize* <sup>[2]</sup>|*CurrRowsetStart — RowsetSize* <sup>[2]</sup>|  
|*После окончания и LastResultRow < RowsetSize* <sup>[2]</sup>|*1* <sup>[1]</sup>|  
|*После окончания и LastResultRow > = RowsetSize* <sup>[2]</sup>|*LastResultRow — RowsetSize + 1* <sup>[2].</sup>|  
  
 [1] **SQLFetchScroll** возвращает SQLSTATE 01S06 (попытка выборки до появления результирующий набор возвращается первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [2] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это новый размер набора строк.  
  
## <a name="sqlfetchrelative"></a>SQL_FETCH_RELATIVE  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*(До запуска и FetchOffset > 0) ИЛИ (после окончания и FetchOffset < 0)*|*--* <sup>[1]</sup>|  
|*BeforeStart и FetchOffset < = 0*|*Перед запуском*|  
|*CurrRowsetStart = 1 и FetchOffset < 0*|*Перед запуском*|  
|*CurrRowsetStart > 1 AND CurrRowsetStart + FetchOffset < 1 AND &#124; FetchOffset &#124; > RowsetSize* <sup>[3]</sup>|*Перед запуском*|  
|*CurrRowsetStart > 1 AND CurrRowsetStart + FetchOffset < 1 AND &#124; FetchOffset &#124; < = RowsetSize* <sup>[3]</sup>|*1* <sup>[2]</sup>|  
|*1 < = CurrRowsetStart + FetchOffset \<= LastResultRow*|*CurrRowsetStart + FetchOffset*|  
|*CurrRowsetStart + FetchOffset > LastResultRow*|*После окончания*|  
|*После окончания и FetchOffset > = 0*|*После окончания*|  
  
 [1] ***SQLFetchScroll*** возвращает тот же набор строк, как если бы он был вызван с FetchOrientation значение SQL_FETCH_ABSOLUTE. Дополнительные сведения см. в разделе «SQL_FETCH_ABSOLUTE».  
  
 [2] **SQLFetchScroll** возвращает SQLSTATE 01S06 (попытка выборки до появления результирующий набор возвращается первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [3] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это новый размер набора строк.  
  
## <a name="sqlfetchabsolute"></a>SQL_FETCH_ABSOLUTE  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*FetchOffset < 0 и &#124; FetchOffset &#124; < = LastResultRow*|*LastResultRow + FetchOffset + 1*|  
|*FetchOffset < 0 и &#124; FetchOffset &#124; > LastResultRow AND &#124; FetchOffset &#124; > RowsetSize* <sup>[2]</sup>|*Перед запуском*|  
|*FetchOffset < 0 и &#124; FetchOffset &#124; > LastResultRow AND &#124; FetchOffset &#124; < = RowsetSize* <sup>[2]</sup>|*1* <sup>[1]</sup>|  
|*FetchOffset = 0*|*Перед запуском*|  
|*1 < = FetchOffset \<= LastResultRow*|*FetchOffset*|  
|*FetchOffset > LastResultRow*|*После окончания*|  
  
 [1] **SQLFetchScroll** возвращает SQLSTATE 01S06 (попытка выборки до появления результирующий набор возвращается первый набор строк) и SQL_SUCCESS_WITH_INFO.  
  
 [2] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это новый размер набора строк.  
  
 Абсолютная выборка выполняются для динамического курсора не может предоставить необходимых результатов, поскольку позиций строк динамический курсор не определено. Такая операция эквивалентно fetch после выборки относительным; он не является атомарной операции, как абсолютная выборка для статического курсора.  
  
## <a name="sqlfetchfirst"></a>SQL_FETCH_FIRST  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*Любой*|*1*|  
  
## <a name="sqlfetchlast"></a>SQL_FETCH_LAST  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*RowsetSize* <sup>[1]</sup> < = LastResultRow|*LastResultRow — RowsetSize + 1* <sup>[1]</sup>|  
|*RowsetSize* <sup>[1]</sup> > LastResultRow|*1*|  
  
 [1] Если размер набора строк был изменен с момента предыдущего вызова для выборки строк, это новый размер набора строк.  
  
## <a name="sqlfetchbookmark"></a>ИНСТРУКЦИЯ SQL_FETCH_BOOKMARK  
 Применяются следующие правила.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|*BookmarkRow + FetchOffset < 1*|*Перед запуском*|  
|*1 < = BookmarkRow + FetchOffset \<= LastResultRow*|*BookmarkRow + FetchOffset*|  
|*BookmarkRow + FetchOffset > LastResultRow*|*После окончания*|  
  
 Сведения о закладках см. в разделе [закладки (ODBC)](../../../odbc/reference/develop-app/bookmarks-odbc.md).  
  
## <a name="effect-of-deleted-added-and-error-rows-on-cursor-movement"></a>Эффект удаленные, добавленные и ошибочные строки на перемещение курсора  
 Статические и управляемые набором ключей курсоры иногда обнаружить строки, добавленные к результату установки и удаления строк, удаленных из результирующего набора. Путем вызова **SQLGetInfo** SQL_STATIC_CURSOR_ATTRIBUTES2 и SQL_KEYSET_CURSOR_ATTRIBUTES2 параметры и просмотрев SQL_CA2_SENSITIVITY_ADDITIONS, SQL_CA2_SENSITIVITY_DELETIONS и SQL_CA2_SENSITIVITY_ Битовые маски обновления, приложение определяет, является ли курсоры, реализуемые конкретный драйвер для этого. Для драйверов, которые могут определять удаленные строки и удалять их в следующих абзацах описывается последствия этого поведения. Для драйверов, которые может обнаружить удаленных строк, но не может удалить их удалений не оказывают влияния на интерфейсных и не применяются в следующих абзацах.  
  
 Если курсор определяет строки, добавленные в результирующий набор или удаляет строки, удаленные из результирующего набора, он отображается, как если бы он обнаруживает эти изменения только в том случае, если он выбирает данные. Это включает случай при **SQLFetchScroll** вызывается с FetchOrientation SQL_FETCH_RELATIVE и FetchOffset, равным 0, чтобы повторно извлечь тот же набор строк, но не включает так, при вызове SQLSetPos присвоено SQL_ fOption ОБНОВЛЕНИЕ. В последнем случае обновляются данные в буферы строк, но не refetched и удаленные строки не удаляются из результирующего набора. Таким образом при вставке в текущем наборе строк или удалены из строки, курсор не изменяет буферы строк. Вместо этого обнаруженных изменений при выборке любому набору строк, ранее включить удаленную строку, и теперь включает вставленной строки.  
  
 Например:  
  
```  
// Fetch the next rowset.  
SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 0);  
// Delete third row of the rowset. Does not modify the rowset buffers.  
SQLSetPos(hstmt, 3, SQL_DELETE, SQL_LOCK_NO_CHANGE);  
// The third row has a status of SQL_ROW_DELETED after this call.  
SQLSetPos(hstmt, 3, SQL_REFRESH, SQL_LOCK_NO_CHANGE);  
// Refetch the same rowset. The third row is removed, replaced by what  
// was previously the fourth row.  
SQLFetchScroll(hstmt, SQL_FETCH_RELATIVE, 0);  
```  
  
 Когда **SQLFetchScroll** возвращает новый набор строк, который имеет позицию относительно текущего набора строк — FetchOrientation является SQL_FETCH_NEXT, SQL_FETCH_PRIOR или SQL_FETCH_RELATIVE — он не включает изменения в текущем наборе строк При вычислении начальную позицию новый набор строк. Тем не менее включают изменений за пределами текущего набора строк, если он способен определить их. Кроме того, когда **SQLFetchScroll** возвращает новый набор строк, который имеет позицию, независимо от текущего набора строк — FetchOrientation является SQL_FETCH_FIRST, SQL_FETCH_LAST, SQL_FETCH_ABSOLUTE или SQL_FETCH_BOOKMARK — он включает в себя все изменения, которые он способен определить, даже если они находятся в текущем наборе строк.  
  
 При проверке внутри или за пределами текущего набора строк добавленные строки, частичный набор строк будет считаться концом последней строки допустимым; то есть последней строки, для которого строки не находится в состоянии SQL_ROW_NOROW. Например предположим, курсор способен определить только что добавленных строк, текущего набора строк является частичный набор строк, приложение добавляет новые строки и курсор добавляет эти строки в конец результирующего набора. Если приложение вызывает **SQLFetchScroll** с равным SQL_FETCH_NEXT, FetchOrientation **SQLFetchScroll** возвращает набор строк, начиная с первой вновь добавленной строки.  
  
 Например предположим, что текущий набор строк состоит из строк 21 — 30, размер набора строк равно 10, курсор удаляет строки, удаленные из результирующего набора и курсора определяет строки, добавленные к результирующему набору. В следующей таблице показаны строки **SQLFetchScroll** возвращает в различных ситуациях.  
  
|Изменить|Тип выборки|FetchOffset|Новый набор строк [1]|  
|------------|----------------|-----------------|---------------------|  
|Удаление строки 21|NEXT|0|31 до 40|  
|Удаление строки 31|NEXT|0|32 для 41|  
|Вставить строку между строками 21 и 22|NEXT|0|31 до 40|  
|Вставить строку между строками 30 и 31|NEXT|0|Вставленной строки, 31 39|  
|Удаление строки 21|PRIOR|0|11 до 20|  
|Удалить строку 20|PRIOR|0|10 до 19|  
|Вставить строку между строками 21 и 22|PRIOR|0|11 до 20|  
|Вставить строку между строками 20 и 21|PRIOR|0|12 до 20, вставленной строки|  
|Удаление строки 21|RELATIVE|0|22 до 31<sup>[2]</sup>|  
|Удаление строки 21|RELATIVE|1|22 до 31.|  
|Вставить строку между строками 21 и 22|RELATIVE|0|21, вставленной строки, 22 до 29|  
|Вставить строку между строками 21 и 22|RELATIVE|1|22 до 31.|  
|Удаление строки 21|ABSOLUTE|21|22 до 31<sup>[2]</sup>|  
|Удалить строку 22|ABSOLUTE|21|21, 23 до 31.|  
|Вставить строку между строками 21 и 22|ABSOLUTE|22|Вставленной строки, 22 до 29|  
  
 [1] для этого столбца используется номера строк, прежде чем любые строки были вставлены или удалены.  
  
 [2] в этом случае курсор пытается вернуть строк, начиная со строки 21. Так как строка 21 была удалена, первая строка возвращаемого имеет 22.  
  
 Ошибка строк (то есть с состоянием объекта SQL_ROW_ERROR), не влияют на перемещение курсора. Например, если текущий набор строк начинается с 11 строк и состояние 11 является SQL_ROW_ERROR, вызвав **SQLFetchScroll** с FetchOrientation SQL_FETCH_RELATIVE и FetchOffset, равным 5 возвращает набор строк, начиная со строки 16, так же, как это происходит, если состояние для строки 11 — SQL_SUCCESS.  
  
## <a name="returning-data-in-bound-columns"></a>Возврат данных в привязанные столбцы  
 **SQLFetchScroll** данные возвращаются в привязанные столбцы в так же, как **SQLFetch**. Дополнительные сведения см. в разделе «Возврат данных в привязанный столбцы» в [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
 Если столбцы не связываются, **SQLFetchScroll** не возвращает данные, но переместить блочного курсора в указанную позицию. Данные могут извлекаться из несвязанных столбцов с блочными **SQLGetData** зависит от драйвера. Эта возможность поддерживается в том случае, если вызов **SQLGetInfo** возвращает SQL_GD_BLOCK для SQL_GETDATA_EXTENSIONS типа данных bit.  
  
## <a name="buffer-addresses"></a>Адрес буфера  
 **SQLFetchScroll** использует ту же формулу для определения адреса буферов данных и длины/индикатора как **SQLFetch**. Дополнительные сведения см. в разделе «Буфера адреса» в [SQLBindCol, функция](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
## <a name="row-status-array"></a>Массив состояния строк  
 **SQLFetchScroll** задает значения в массив состояния строк так же, как SQLFetch. Дополнительные сведения см. в разделе «Массив состояния строк» в [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="rows-fetched-buffer"></a>Буфер извлеченных строк  
 **SQLFetchScroll** возвращает число строк, загружаемых в буфере строк, загружаемых в так же, как **SQLFetch**. Дополнительные сведения см. в разделе «Буфер выборки строк» в [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="error-handling"></a>Обработка ошибок  
 Если приложение вызывает **SQLFetchScroll** в драйвер ODBC 3.x, диспетчер драйверов вызывает **SQLFetchScroll** в драйвере. Если приложение вызывает **SQLFetchScroll** в драйвер ODBC 2.x, диспетчер драйверов вызывает SQLExtendedFetch в драйвере. Поскольку **SQLFetchScroll** SQLExtendedFetch немного иначе, обрабатывают ошибки, приложение будет видеть поведения при ошибке немного отличается при вызове **SQLFetchScroll** в ODBC 2.x и ODBC драйверы 3.x.  
  
 **SQLFetchScroll** возвращает ошибки и предупреждения в так же, как **SQLFetch**; Дополнительные сведения см. в разделе «Обработка ошибок» в **SQLFetch**. **SQLExtendedFetch** возвращает ошибки, так же, как **SQLFetch**, за исключением следующих случаев:  
  
 При возникновении предупреждения, которое применяется к конкретной строки в наборе строк, SQLExtendedFetch задает соответствующую запись в массиве строк состояния для SQL_ROW_SUCCESS не SQL_ROW_SUCCESS_WITH_INFO.  
  
 При возникновении ошибки в каждую строку в наборе строк SQLExtendedFetch возвращает SQL_SUCCESS_WITH_INFO, а не значение SQL_ERROR.  
  
 В каждой группе записи состояния, которая применяется к отдельной строке, первая запись состояния, возвращаемые SQLExtendedFetch должен содержать SQLSTATE 01S01 (ошибка в строке); **SQLFetchScroll** не возвращает это SQLSTATE. Если SQLExtendedFetch не может вернуть дополнительные атрибуты SQLSTATE, по-прежнему необходимо возвращается этот SQLSTATE.  
  
## <a name="sqlfetchscroll-and-optimistic-concurrency"></a>SQLFetchScroll и оптимистический параллелизм  
 Если курсор использует оптимистический параллелизм, то есть атрибута инструкции SQL_ATTR_CONCURRENCY имеет значение SQL_CONCUR_VALUES или SQL_CONCUR_ROWVER — **SQLFetchScroll** обновляет значения оптимистичного параллелизма для данных источник для определения, является ли строка была изменена. Это происходит каждый раз, когда **SQLFetchScroll** выбирается новый набор строк, в том числе его refetches текущего набора строк. (Он вызывается с FetchOrientation SQL_FETCH_RELATIVE и FetchOffset, равным 0.)  
  
## <a name="sqlfetchscroll-and-odbc-2x-drivers"></a>SQLFetchScroll и ODBC 2.x драйверы  
 Если приложение вызывает **SQLFetchScroll** в драйвер ODBC 2.x, диспетчер драйверов сопоставляет этот вызов **SQLExtendedFetch**. Он передает следующие значения для аргументов **SQLExtendedFetch**.  
  
|Аргумент SQLExtendedFetch|Значение|  
|-------------------------------|-----------|  
|StatementHandle|StatementHandle в **SQLFetchScroll**.|  
|FetchOrientation|FetchOrientation в **SQLFetchScroll**.|  
|FetchOffset|Если FetchOrientation не SQL_FETCH_BOOKMARK значение в аргументе FetchOffset **SQLFetchScroll** используется.<br /><br /> Если FetchOrientation SQL_FETCH_BOOKMARK, используется значение, сохраненное по адресу, указанному в атрибуте SQL_ATTR_FETCH_BOOKMARK_PTR инструкции.|  
|RowCountPtr|Адрес, указанный в атрибуте SQL_ATTR_ROWS_FETCHED_PTR инструкции.|  
|RowStatusArray|Адрес, указанный в атрибуте значения SQL_ATTR_ROW_STATUS_PTR инструкции.|  
  
 Дополнительные сведения см. в разделе [блочных курсоров, Прокручиваемые курсоры и обратной совместимости](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) в приложении G: драйвер рекомендации для обеспечения обратной совместимости.  
  
## <a name="descriptors-and-sqlfetchscroll"></a>Дескрипторы и SQLFetchScroll  
 **SQLFetchScroll** взаимодействует с дескрипторами так же, как **SQLFetch**. Дополнительные сведения см. в подразделе «Дескрипторы и SQLFetchScroll» [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md).  
  
## <a name="code-example"></a>Пример кода  
 В разделе [привязки на уровне столбца](../../../odbc/reference/develop-app/column-wise-binding.md), [привязка](../../../odbc/reference/develop-app/row-wise-binding.md), [располагается инструкции Update и Delete](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md), и [обновление строк в наборе строк с SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфера|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнение инструкции bulk insert, update или delete операций|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующий набор|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнения подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Выборка одной строки или блока данных в направлении только вперед|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Закрытие курсора на инструкции|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращает число результирующих столбцов набора|[Функция SQLNumResultCols](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Позиционирование курсора, обновление данных в наборе строк или удаления данных в результирующем наборе|[Функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
|С помощью атрибута инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
