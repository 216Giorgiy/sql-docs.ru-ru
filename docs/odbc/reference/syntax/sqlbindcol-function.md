---
title: SQLBindCol, функция | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
apiname:
- SQLBindCol
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLBindCol
helpviewer_keywords:
- SQLBindCol function [ODBC]
ms.assetid: 41a37655-84cd-423f-9daa-e0b47b88dc54
caps.latest.revision: 37
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: f51f8da589db04b44ab31a493d97fe3d94b3b6d7
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32922829"
---
# <a name="sqlbindcol-function"></a>SQLBindCol, функция
**Соответствия**  
 Появился в версии: Полное соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLBindCol** привязывает буферы данных приложения для столбцов в результирующем наборе.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLBindCol(  
      SQLHSTMT       StatementHandle,  
      SQLUSMALLINT   ColumnNumber,  
      SQLSMALLINT    TargetType,  
      SQLPOINTER     TargetValuePtr,  
      SQLLEN         BufferLength,  
      SQLLEN *       StrLen_or_Ind);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *ColumnNumber*  
 [Вход] Число результирующих набора столбцов для привязки. Столбцы нумеруются в порядке возрастания столбца, начиная с 0, где столбец 0 — это столбец закладки. Если не используются закладки, то есть атрибут инструкции SQL_ATTR_USE_BOOKMARKS равно SQL_UB_OFF — затем номера столбцов начинается с 1.  
  
 *TargetType*  
 [Вход] Идентификатор типа данных C \* *TargetValuePtr* буфера. При извлечении данных из источника данных с **SQLFetch**, **SQLFetchScroll**, **SQLBulkOperations**, или **SQLSetPos**, драйвер преобразует данные для этого типа; При отправке данных в источник данных с **SQLBulkOperations** или **SQLSetPos**, драйвер преобразует данные из этого типа. Список допустимых типов данных C и идентификаторы типов см. в разделе [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) раздел в типах данных приложение D:.  
  
 Если *TargetType* аргумент имеет тип данных интервал, начальные точности интервала по умолчанию (2) и точность секунд интервал по умолчанию (6), как указано в полях SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION Отменить, соответственно, используются для данных. Если *TargetType* аргумент SQL_C_NUMERIC, точность по умолчанию (определяемые драйвером) и масштаб (0), по умолчанию, указанное на полях SQL_DESC_PRECISION и SQL_DESC_SCALE Отменить, используются для данных. Если любой по умолчанию точность или масштаб не подходит, приложение должно явно задать поля дескриптора соответствующие путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Можно также указать расширенный тип данных C. Дополнительные сведения см. в разделе [типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 *TargetValuePtr*  
 [Отложенные вход/выход] Указатель на буфер данных для привязки к столбцу. **SQLFetch** и **SQLFetchScroll** возвращают данные в этом буфере. **SQLBulkOperations** возвращает данные в этом буфера при *операции* — SQL_FETCH_BY_BOOKMARK; он извлекает данные из этого буфера при *операции* SQL_ADD или SQL_UPDATE_BY_BOOKMARK. **SQLSetPos** возвращает данные в этом буфера при *операции* — SQL_REFRESH; он извлекает данные из этого буфера при *операции* — SQL_UPDATE.  
  
 Если *TargetValuePtr* является указателем null, драйвер отменяет привязку буфер данных для столбца. Приложение можно разорвать связи все столбцы, вызвав **SQLFreeStmt** с параметром SQL_UNBIND. Приложение можно отменить привязку буфер данных для столбца, но по-прежнему буфер длины/индикатора, привязанное к столбцу, если *TargetValuePtr* аргумента в вызове **SQLBindCol** является пустым указателем, но *StrLen_or_IndPtr* аргумент является допустимым значением.  
  
 *BufferLength*  
 [Вход] Длина **TargetValuePtr* буфера в байтах.  
  
 Драйвер использует *BufferLength* во избежание записи за пределами \* *TargetValuePtr* буфера при возвращении данных переменной длины, например символьных или двоичных данных. Обратите внимание, что драйвер считается знак завершения null при возвращении символьных данных \* *TargetValuePtr*. **TargetValuePtr* таким образом должна содержать место для символа конечное значение null или драйвер будет выполнять усечение данных.  
  
 Когда драйвер возвращает данных фиксированной длины, например целое число или структура даты, драйвер пропускает *BufferLength* и предполагает буфер недостаточно велик для хранения данных. Таким образом важно для приложения, чтобы выделить достаточно большого размера буфера для данных фиксированной длины или драйвер будет записывать после конца буфера.  
  
 **SQLBindCol** возвращает SQLSTATE HY090 (Недопустимая длина строки или буфера) при *BufferLength* имеет меньше 0 но не в том случае, когда *BufferLength* — 0. Тем не менее если *TargetType* Указывает символьный тип, не следует устанавливать приложение *BufferLength* 0, поскольку драйверов, совместимых с ISO CLI — возвращать SQLSTATE HY090 (Недопустимая длина строки или буфера) в том, что регистр.  
  
 *StrLen_or_IndPtr*  
 [Отложенные вход/выход] Указатель на буфер длины/индикатора для привязки к столбцу. **SQLFetch** и **SQLFetchScroll** возвращают значение в этом буфере. **SQLBulkOperations** извлекает значение из этого буфера при *операции* SQL_ADD, SQL_UPDATE_BY_BOOKMARK или SQL_DELETE_BY_BOOKMARK. **SQLBulkOperations** возвращает значение в этом буфере при *операции* — SQL_FETCH_BY_BOOKMARK. **SQLSetPos** возвращает значение в этом буфере при *операции* — SQL_REFRESH; он извлекает значение из этого буфера при *операции* — SQL_UPDATE.  
  
 **SQLFetch**, **SQLFetchScroll**, **SQLBulkOperations**, и **SQLSetPos** может возвращать следующие значения в буфер длины/индикатора:  
  
-   Длина данных, доступных для возврата  
  
-   SQL_NO_TOTAL  
  
-   SQL_NULL_DATA  
  
 Приложение можно поместить следующие значения в буфер длины/индикатора для использования с **SQLBulkOperations** или **SQLSetPos**:  
  
-   Длина отправляемых данных  
  
-   SQL_NTS  
  
-   SQL_NULL_DATA  
  
-   ЗНАЧЕНИЕ SQL_DATA_AT_EXEC  
  
-   Результат SQL_LEN_DATA_AT_EXEC-макрос  
  
-   SQL_COLUMN_IGNORE  
  
 Если буфер индикатора и буфер длины отдельных буферов, буфера индикатора может возвращать только SQL_NULL_DATA, тогда как длина буфера может возвращать все значения.  
  
 Дополнительные сведения см. в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md), [функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md), и [использование значения длины/индикатора](../../../odbc/reference/develop-app/using-length-and-indicator-values.md).  
  
 Если *StrLen_or_IndPtr* имеет значение null, значение указателя, ни длины ни индикатор используется. Это ошибка при получении данных и данных имеет значение NULL.  
  
 В разделе [сведения ODBC 64-разрядных](../../../odbc/reference/odbc-64-bit-information.md), если приложение будет выполняться на 64-разрядной операционной системе.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLBindCol** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_ HANDLE_STMT и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLBindCol** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|(DM) *ColumnNumber* аргумент было равно 0 и *TargetType* аргумент не SQL_C_BOOKMARK или SQL_C_VARBOOKMARK.|  
|07009|Недопустимый индекс дескриптора|Значение, указанное для аргумента *ColumnNumber* превышено максимальное число столбцов в результирующем наборе.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, который необходим для поддержки выполнения или завершения функции.|  
|HY003 И СООБЩЕНИЕМ|Недопустимый тип буфера приложения|Аргумент *TargetType* было SQL_C_DEFAULT ни допустимый тип данных.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом асинхронной функция **SQLBindCol** был вызван.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ЭТОТ ПАРАМЕТР ДОСТУПЕН. До получения данных для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное для аргумента *BufferLength* был меньше 0.<br /><br /> (DM) был драйвер ODBC 2. *x* драйвера, *ColumnNumber* аргумент было задано значение 0 и значения, указанного в аргументе *BufferLength* было не равно 4.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает преобразование, определяется сочетанием *TargetType* аргументов и тип данных специфические для драйвера SQL соответствующего столбца.<br /><br /> Аргумент *ColumnNumber* было равно 0, и драйвер не поддерживает закладки.<br /><br /> Драйвер поддерживает только ODBC 2. *x* и аргумента *TargetType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и любой из типов данных C интервал, перечисленных в [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) в типах данных приложение D:.<br /><br /> Драйвер поддерживает только ODBC версий, предшествующих 3,50 и аргумента *TargetType* был SQL_C_GUID.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 **SQLBindCol** используется для связи, или *привязать,* присваивает столбцам в результате буферов данных и буфер длины/индикатора в приложение. Когда приложение вызывает **SQLFetch**, **SQLFetchScroll**, или **SQLSetPos** для выборки данных, драйвер возвращает данные для связанных столбцов, в указанный буфер; Дополнительные сведения см. в разделе [SQLFetch, функция](../../../odbc/reference/syntax/sqlfetch-function.md). Когда приложение вызывает **SQLBulkOperations** для обновления или вставки строки или **SQLSetPos** попытка обновить строку, драйвер получает данные, привязанные столбцы из указанного буферов; Дополнительные сведения , в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md) или [функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md). Дополнительные сведения о привязке см. в разделе [получение результатов (Basic)](../../../odbc/reference/develop-app/retrieving-results-basic.md).  
  
 Обратите внимание, что столбцы не нужно привязать для получения данных из них. Приложение также может вызвать **SQLGetData** для получения данных из столбцов. Несмотря на то, что можно привязать некоторые столбцы в строки и вызова **SQLGetData** для других это накладываются некоторые ограничения. Дополнительные сведения см. в разделе [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md).  
  
## <a name="binding-unbinding-and-rebinding-columns"></a>Привязка, Отмена привязки и повторная привязка столбцов  
 Столбец может быть привязан, несвязанные или повторно привязаны в любое время, даже после выбранных данных из результирующего набора. Новая привязка вступает в силу при очередном вызывается функция, которая использует привязок. Предположим, что приложение привязывает столбцы в результирующем наборе и вызовы **SQLFetch**. Драйвер возвращает данные в буферах привязанного. Теперь предположим, что приложение привязывает столбцы к другому набору буферов. Драйвер не размещать данные для строки просто извлечь в новой присоединенной буферов. Вместо этого она будет ждать до **SQLFetch** вызывается снова, а затем помещает данные для следующей строки в новой присоединенной буферов.  
  
> [!NOTE]  
>  Атрибут инструкции SQL_ATTR_USE_BOOKMARKS всегда должен иметь значение перед привязкой 0 для столбцов. Это не является обязательным, но настоятельно рекомендуется.  
  
## <a name="binding-columns"></a>Привязка столбцов  
 Чтобы привязать столбец, приложение вызывает **SQLBindCol** и передает номер столбца, тип, адрес и длина буфера данных, а адрес буфер длины/индикатора. Сведения об использовании этих адресов. в разделе «Буфера адреса,» далее в этом разделе. Дополнительные сведения о столбцах привязки см. в разделе [с помощью SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md).  
  
 Эти буферы отложена; то есть, приложение выполняет привязку их в **SQLBindCol** , но драйвер получает к ним доступ из других функций, а именно **SQLBulkOperations**, **SQLFetch**,  **SQLFetchScroll**, или **SQLSetPos**. Приложения должны убедиться, что указатели, указанный в **SQLBindCol** остаются действительными до тех пор, пока действует привязки. Если приложение допускает эти указатели недопустимости — например, он освобождает буфер — и затем вызывает функцию, ожидающую их недействителен, последствия не определены. Дополнительные сведения см. в разделе [отложенное буферы](../../../odbc/reference/develop-app/deferred-buffers.md).  
  
 Привязка остается в силе до заменяется новой привязки, отменяется привязка столбца или инструкция освобождается.  
  
## <a name="unbinding-columns"></a>Отмена привязки столбцов  
 Чтобы отменить привязку один столбец, приложение вызывает **SQLBindCol** с *ColumnNumber* установите номер столбца, и *TargetValuePtr* — указатель null. Если *ColumnNumber* ссылается на несвязанного столбца **SQLBindCol** по-прежнему возвращает значение SQL_SUCCESS.  
  
 Чтобы отменить привязку всех столбцов, приложение вызывает **SQLFreeStmt** с *fOption* значение SQL_UNBIND. Также это можно сделать, задав в поле SQL_DESC_COUNT Отменить до нуля.  
  
## <a name="rebinding-columns"></a>Идет повторная привязка столбцов  
 Приложение может выполнять одно из двух операций для изменения привязки:  
  
-   Вызовите **SQLBindCol** для указания новой привязки для столбца, который уже привязан. Драйвер перезаписывает старый привязки на новую.  
  
-   Указать смещение для добавления адрес буфера, который был указан при помощи вызова привязки **SQLBindCol**. Дополнительные сведения см. следующий раздел «Смещения привязки».  
  
## <a name="binding-offsets"></a>Привязка смещения  
 Смещение привязки имеет значение, которое добавляется к адресам буферов данных и длины/индикатора (как указано в *TargetValuePtr* и *StrLen_or_IndPtr* аргумент) перед их, отменяются. При использовании смещения, привязки «шаблон» как располагаются буферы приложения и приложения можно перемещать «шаблон» к различным областям памяти, изменение смещения. Так как же смещение добавляется в каждый адрес в каждой привязке, относительные смещения между буферами для различных столбцов должен быть в пределах каждого набора буферов. Это всегда имеет значение true, если используется привязка; приложение необходимо тщательно компоновать буферы присваивать этому свойству значение true, если используется привязка на уровне столбцов.  
  
 С использованием привязки смещения по сути, имеет тот же эффект, как повторная привязка столбца путем вызова **SQLBindCol**. Различие состоит в том новый вызов **SQLBindCol** задает новый адресов буфер данных и буфер длины/индикатора, а использование смещение привязки не изменяет адреса, но только добавляет смещение к ним. Приложения можно указать новое смещение всякий раз, когда ему, и это смещение всегда добавляется изначально связанные адреса. В частности Если смещение равен 0 или оператор атрибута задано значение является пустым указателем, драйвер использует изначально связанные адреса.  
  
 Чтобы указать смещение привязки, приложение устанавливает атрибут инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR адрес буфера SQLINTEGER. Перед приложение вызывает функцию, которая использует привязки, он помещает смещение в байтах в этом буфере. Чтобы определить адрес буфера, драйвер добавляет смещение адреса в привязке. Сумма адрес и смещение должно быть допустимым адресом, но не быть допустимый адрес, к которому добавляется смещение. Дополнительные сведения об использовании смещения привязки в разделе «Буфера адреса,» далее в этом разделе.  
  
## <a name="binding-arrays"></a>Привязка массивов  
 Если размер набора строк (значение атрибута SQL_ATTR_ROW_ARRAY_SIZE инструкции) больше 1, приложение связывает массивы буферов вместо одного буферов. Дополнительные сведения см. в разделе [блочные курсоры](../../../odbc/reference/develop-app/block-cursors.md).  
  
 Приложение можно связать массивы двумя способами:  
  
-   Привязать массив для каждого столбца. Это называется *привязки на уровне столбца* так как каждая структура данных (array) содержит данные для одного столбца.  
  
-   Определение структуры для хранения данных для всей строки и привязать массив этих структур. Это называется *привязка* поскольку каждая структура данных содержит данные для одной строки.  
  
 Каждый массив буферов должен иметь по крайней мере столько же элементов, что размер набора строк.  
  
> [!NOTE]  
>  Приложение необходимо проверить правильность выравнивания. Дополнительные сведения о вопросах выравнивания см. в разделе [выравнивание](../../../odbc/reference/develop-app/alignment.md).  
  
## <a name="column-wise-binding"></a>Привязка на уровне столбца  
 В привязки на уровне столбца, приложение связывает отдельный данных и массивы длины/индикатора для каждого столбца.  
  
 Чтобы использовать привязки на уровне столбца, приложение сначала задает атрибут инструкции SQL_ATTR_ROW_BIND_TYPE SQL_BIND_BY_COLUMN. (Это значение по умолчанию). Для каждого столбца может быть привязано приложение выполняет следующие действия:  
  
1.  Выделяет массив буфера данных.  
  
2.  Выделяет массив буферов длины/индикатора.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно к дескрипторам, когда используется привязка на уровне столбцов, можно использовать отдельные массивы данных длины и индикатора.  
  
3.  Вызовы **SQLBindCol** со следующими аргументами:  
  
    -   *TargetType* тип из одного элемента в массиве буфера данных.  
  
    -   *TargetValuePtr* является адресом массива буфера данных.  
  
    -   *BufferLength* размер одиночного элемента в массиве буфера данных. *BufferLength* аргумент учитывается, если данные фиксированной длины.  
  
    -   *StrLen_or_IndPtr* является адресом массива длины/индикатора.  
  
 Дополнительные сведения о том, как эта информация используется в разделе «Буфера адреса,» далее в этом разделе. Дополнительные сведения о привязке на уровне столбца см. в разделе [привязки на уровне столбца](../../../odbc/reference/develop-app/column-wise-binding.md).  
  
## <a name="row-wise-binding"></a>Привязка на уровне строки  
 В привязку на уровне строки приложение определяет структуру, содержащую буферов данных и длины/индикатора для каждого столбца, для привязки.  
  
 Чтобы использовать привязку на уровне строки, приложение выполняет следующие действия:  
  
1.  Определяет структуру для хранения одну строку данных (включая буферов данных и длины/индикатора) и выделяет массив этих структур.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно к дескрипторам, когда привязка используется, можно использовать отдельные поля для данных, длины и индикатора.  
  
2.  Задает атрибут инструкции SQL_ATTR_ROW_BIND_TYPE размер структуры, которая содержит одну строку данных или размер экземпляра буфера, в который будет привязан столбцов с результатами. Длина должна включать пробел для всех связанных столбцов и все заполнения структуры или буфера, чтобы убедиться в том, результат адрес связанного столбца увеличивается с указанной длины, будет указывать на начало того же столбца в следующей строке. При использовании *sizeof* оператор в ANSI C, такое поведение гарантируется.  
  
3.  Вызовы **SQLBindCol** со следующими аргументами для каждого столбца для привязки:  
  
    -   *TargetType* является типом элемента буфера данных, привязанное к столбцу.  
  
    -   *TargetValuePtr* — это адрес элемента данных буфера в первом элементе массива.  
  
    -   *BufferLength* размер буфера элемента данных.  
  
    -   *StrLen_or_IndPtr* адрес длины/индикатора элемента для привязки.  
  
 Дополнительные сведения о том, как эта информация используется в разделе «Буфера адреса,» далее в этом разделе. Дополнительные сведения о привязке на уровне столбца см. в разделе [привязки на уровне строки](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="buffer-addresses"></a>Адрес буфера  
 *Буфера адрес* фактический адрес буфера данных или длины/индикатора. Драйвер вычисляет адрес буфера, непосредственно перед он записывает в буферы (например, во время выборки времени). Он вычисляется с помощью следующей формулы, которая использует адресов, указанных в *TargetValuePtr* и *StrLen_or_IndPtr* аргументов, смещение привязки и номер строки:  
  
 *Привязан адрес* + *привязки смещение* + ((*номер строки* – 1) x *размер элемента*)  
  
 Когда формула переменные определяются, как описано в следующей таблице.  
  
|Переменная|Описание|  
|--------------|-----------------|  
|*Адрес привязки*|Для буферов данных, адрес, указанный с *TargetValuePtr* аргумент в **SQLBindCol**.<br /><br /> Буфер длины/индикатора, адрес, указанный с *StrLen_or_IndPtr* аргумент в **SQLBindCol**. Дополнительные сведения см. в разделе «Примечания» в разделе «Дескрипторы и SQLBindCol».<br /><br /> Если привязан адрес равен 0, возвращаемое значение данных, даже если адрес, вычисленную по формуле предыдущих имеет ненулевое значение.|  
|*Смещение привязки*|Если используется привязка, с помощью атрибута инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR указано значение, по адресу.<br /><br /> Если используется привязка на уровне столбца или значение атрибута инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR является пустым указателем, *смещение привязки* имеет значение 0.|  
|*Номер строки*|От 1 номер строки в наборе строк. Для выборки одной строки, которые используются по умолчанию, — 1.|  
|*Размер элемента*|Размер элемента в массиве привязанных.<br /><br /> Если используется привязка на уровне столбцов, это **sizeof(SQLINTEGER)** буфер длины/индикатора. Для буферов данных это значение *BufferLength* аргумент в **SQLBindCol** Если тип данных переменной длины и размер типа данных, если тип данных фиксированной длины.<br /><br /> Если используется привязка, это значение атрибута инструкции SQL_ATTR_ROW_BIND_TYPE для буферов данных и длины/индикатора.|  
  
## <a name="descriptors-and-sqlbindcol"></a>Дескрипторы и SQLBindCol  
 В следующих разделах описаны как **SQLBindCol** взаимодействует с дескрипторами.  
  
> [!CAUTION]  
>  Вызов **SQLBindCol** для одной инструкции может повлиять на другие инструкции. Это происходит при явном выделении Отменить, связанные с инструкцией и также связан с другими инструкциями. Поскольку **SQLBindCol** изменяет дескриптор, изменения применяются ко всем операторам, с которыми связан данный дескриптор. Если это не необходимого поведения, приложение должно отменить связь этим дескриптором из других инструкций перед вызовом **SQLBindCol**.  
  
## <a name="argument-mappings"></a>Сопоставление аргументов  
 По существу **SQLBindCol** выполняет следующие шаги в последовательности:  
  
1.  Вызовы **SQLGetStmtAttr** для получения дескриптора Отменить.  
  
2.  Вызовы **SQLGetDescField** для получения дескриптора SQL_DESC_COUNT поля и, если значение в *ColumnNumber* аргумента превышает значение SQL_DESC_COUNT вызовы **SQLSetDescField**  увеличить значение SQL_DESC_COUNT для *ColumnNumber*.  
  
3.  Вызовы **SQLSetDescField** несколько раз, чтобы присвоить значения следующих полей свойства Отменить:  
  
    -   Присваивает значение SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE *TargetType*, за исключением того, что если *TargetType* является одним четкими идентификаторов подтипа даты-времени или интервала, он задает SQL_DESC_TYPE SQL_ DATETIME или SQL_INTERVAL, соответственно; Задает SQL_DESC_CONCISE_TYPE с кратким идентификатором; и наборы SQL_DESC_DATETIME_INTERVAL_CODE соответствующие даты и времени или интервала дополнительным кодом.  
  
    -   Задает один или несколько SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE и SQL_DESC_DATETIME_INTERVAL_PRECISION, в зависимости от *TargetType*.  
  
    -   Устанавливает значение поля SQL_DESC_OCTET_LENGTH *BufferLength*.  
  
    -   Устанавливает значение поля SQL_DESC_DATA_PTR *TargetValue*.  
  
    -   Устанавливает значение поля SQL_DESC_INDICATOR_PTR *StrLen_or_Ind*. (См. следующий абзац).  
  
    -   Устанавливает поля SQL_DESC_OCTET_LENGTH_PTR значение *StrLen_or_Ind*. (См. следующий абзац).  
  
 Переменная, *StrLen_or_Ind* ссылается аргумент используется для индикатора и длины данных. Если fetch встретится значение null для столбца, она сохраняет SQL_NULL_DATA в этой переменной. в противном случае он содержит длину данных в этой переменной. Передача нулевой указатель как *StrLen_or_Ind* отслеживает операции выборки возвращали длину данных, но делает fetch ошибкой, если он встретится значение null и не может возвращать значения SQL_NULL_DATA.  
  
 Если вызов **SQLBindCol** завершается с ошибкой, содержимое поля дескриптора, которые оно будет задано в Отменить не определены, и значение поля SQL_DESC_COUNT Отменить остается неизменным.  
  
## <a name="implicit-resetting-of-count-field"></a>Неявные сброса поле COUNT  
 **SQLBindCol** присваивает значение SQL_DESC_COUNT *ColumnNumber* аргумента только в том случае, если это увеличит значение SQL_DESC_COUNT. Если значение в *TargetValuePtr* аргумент является указателем null и значение в *ColumnNumber* аргумент равен SQL_DESC_COUNT (то есть, при отмене привязки с самым высоким связанного столбца), затем SQL_DESC_ Количество оставшихся связанный столбец с большим задано число.  
  
## <a name="cautions-regarding-sqldefault"></a>Предупреждения о SQL_DEFAULT  
 Чтобы получить данные столбца успешно, приложение должно определить, правильно длину и начальную точку данных в буфер приложения. Если приложение указывает явно *TargetType*, легко обнаружения неправильных приложения. Тем не менее, если приложение указывает *TargetType* из SQL_DEFAULT, **SQLBindCol** могут быть вызваны со столбцом в другой тип данных из назначенного приложением, либо из изменений метаданные или применяя код в другой столбец. В этом случае приложение может не всегда определить запуск или длина столбца извлеченных данных. Это может привести к недокументированных данных ошибок или нарушений памяти.  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение выполняет **ВЫБЕРИТЕ** инструкции в таблице Customers, чтобы вернуть результирующий набор клиента идентификаторы, имена и номера телефонов, отсортированных по имени. Затем он вызывает **SQLBindCol** привязка столбцов данных для локальными буферами. Наконец, приложение извлекает каждой строки данных с **SQLFetch** и выводит имя каждого клиента, идентификатор и номер телефона.  
  
 Дополнительные примеры кода см. в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [SQLColumns, функция](../../../odbc/reference/syntax/sqlcolumns-function.md), [функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md), и [функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
```  
// SQLBindCol_ref.cpp  
// compile with: odbc32.lib  
#include <windows.h>  
#include <stdio.h>  
  
#define UNICODE  
#include <sqlext.h>  
  
#define NAME_LEN 50  
#define PHONE_LEN 20  
  
void show_error() {  
   printf("error\n");  
}  
  
int main() {  
   SQLHENV henv;  
   SQLHDBC hdbc;  
   SQLHSTMT hstmt = 0;  
   SQLRETURN retcode;  
   SQLWCHAR szName[NAME_LEN], szPhone[PHONE_LEN], sCustID[NAME_LEN];  
   SQLLEN cbName = 0, cbCustID = 0, cbPhone = 0;  
  
   // Allocate environment handle  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
  
   // Set the ODBC version environment attribute  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
      retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
      // Allocate connection handle  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
         retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);  
  
         // Set login timeout to 5 seconds  
         if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
            SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
            // Connect to data source  
            retcode = SQLConnect(hdbc, (SQLWCHAR*) L"NorthWind", SQL_NTS, (SQLWCHAR*) NULL, 0, NULL, 0);  
  
            // Allocate statement handle  
            if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {   
               retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);   
  
               retcode = SQLExecDirect(hstmt, (SQLWCHAR *) L"SELECT CustomerID, ContactName, Phone FROM CUSTOMERS ORDER BY 2, 1, 3", SQL_NTS);  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
  
                  // Bind columns 1, 2, and 3  
                  retcode = SQLBindCol(hstmt, 1, SQL_C_CHAR, &sCustID, 100, &cbCustID);  
                  retcode = SQLBindCol(hstmt, 2, SQL_C_CHAR, szName, NAME_LEN, &cbName);  
                  retcode = SQLBindCol(hstmt, 3, SQL_C_CHAR, szPhone, PHONE_LEN, &cbPhone);   
  
                  // Fetch and print each row of data. On an error, display a message and exit.  
                  for (i ; ; i++) {  
                     retcode = SQLFetch(hstmt);  
                     if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO)  
                        show_error();  
                     if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO)  
                        wprintf(L"%d: %S %S %S\n", i + 1, sCustID, szName, szPhone);  
                     else  
                        break;  
                  }  
               }  
  
               // Process data  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
                  SQLCancel(hstmt);  
                  SQLFreeHandle(SQL_HANDLE_STMT, hstmt);  
               }  
  
               SQLDisconnect(hdbc);  
            }  
  
            SQLFreeHandle(SQL_HANDLE_DBC, hdbc);  
         }  
      }  
      SQLFreeHandle(SQL_HANDLE_ENV, henv);  
   }  
}  
```  
  
 См. также [образец программы на ODBC](../../../odbc/reference/sample-odbc-program.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Возврат сведений о столбце в результирующий набор|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выборка блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Извлечение нескольких строк данных|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Освобождение буферах столбцов на инструкцию|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Извлечение всех или части столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращает число результирующих столбцов набора|[Функция SQLNumResultCols](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
