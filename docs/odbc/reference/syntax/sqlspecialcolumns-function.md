---
title: "Функция SQLSpecialColumns | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: odbc
ms.reviewer: 
ms.suite: sql
ms.technology: drivers
ms.tgt_pltfrm: 
ms.topic: article
apiname: SQLSpecialColumns
apilocation: sqlsrv32.dll
apitype: dllExport
f1_keywords: SQLSpecialColumns
helpviewer_keywords: SQLSpecialColumns function [ODBC]
ms.assetid: bb2d9f21-bda0-4e50-a8be-f710db660034
caps.latest.revision: "22"
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: Inactive
ms.openlocfilehash: 80afdd42ee17c77a44035854207812ecac3afb46
ms.sourcegitcommit: cc71f1027884462c359effb898390c8d97eaa414
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="sqlspecialcolumns-function"></a>SQLSpecialColumns, функция
**Соответствия**  
 Появился в версии: Полное соответствие стандартам 1.0 ODBC: Open Group  
  
 **Сводка**  
 **SQLSpecialColumns** возвращает следующие сведения о столбцах в указанной таблице:  
  
-   Оптимальный набор столбцов, который уникально идентифицирует строки в таблице.  
  
-   Столбцы, которые автоматически обновляются, когда любое значение в строке обновляется транзакцией.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLSpecialColumns(  
     SQLHSTMT      StatementHandle,  
     SQLSMALLINT   IdentifierType,  
     SQLCHAR *     CatalogName,  
     SQLSMALLINT   NameLength1,  
     SQLCHAR *     SchemaName,  
     SQLSMALLINT   NameLength2,  
     SQLCHAR *     TableName,  
     SQLSMALLINT   NameLength3,  
     SQLSMALLINT   Scope,  
     SQLSMALLINT   Nullable);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *IdentifierType*  
 [Вход] Тип возвращаемого столбца. Должен быть одним из следующих значений:  
  
 SQL_BEST_ROWID: Возвращает оптимальный столбец или набор столбцов, получая значения из столбца или столбцов, позволяет любую строку в указанной таблице для однозначной идентификации. Столбец может быть либо псевдо столбцом специально для этой цели (как Oracle ROWID или Ingres TID) либо столбцом или столбцами любого уникального индекса для таблицы.  
  
 SQL_ROWVER: Возвращает столбец или столбцы в указанной таблице, если таковые имеются, автоматически обновляются по источнику данных, когда любое значение в строке обновляется транзакцией (как программа ROWID или Sybase отметки времени).  
  
 *CatalogName*  
 [Вход] Имя каталога для таблицы. Если драйвер поддерживает каталоги для некоторых таблиц, но не для других пользователей, например, когда драйвер получает данные из различных DBMS, пустая строка ("») обозначает те таблицы, которые не имеют каталоги. *CatalogName* не может содержать строку шаблона поиска.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID задано значение SQL_TRUE, *CatalogName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *CatalogName* — обычный аргумент; он интерпретируется буквально и его регистр имеет значения. Дополнительные сведения см. в разделе [аргументов функций каталога](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).  
  
 *NameLength1*  
 [Вход] Длина в символах **CatalogName*.  
  
 *SchemaName*  
 [Вход] Имя схемы для таблицы. Если драйвер поддерживает схемы для некоторых таблиц, но не для других пользователей, например, когда драйвер получает данные из различных DBMS, пустая строка ("») обозначает этих таблиц, у которых нет схемы. *SchemaName* не может содержать строку шаблона поиска.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID задано значение SQL_TRUE, *SchemaName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *SchemaName* — обычный аргумент; он интерпретируется буквально и его регистр имеет значения.  
  
 *NameLength2*  
 [Вход] Длина в символах **SchemaName*.  
  
 *Имя_таблицы*  
 [Вход] Имя таблицы. Этот аргумент не может быть пустым указателем. *TableName* не может содержать строку шаблона поиска.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID задано значение SQL_TRUE, *TableName* рассматривается как идентификатор и его регистр не имеет значения. Если это значение SQL_FALSE, *TableName* — обычный аргумент; он интерпретируется буквально и его регистр имеет значения.  
  
 *NameLength3*  
 [Вход] Длина в символах **TableName*.  
  
 *Область действия*  
 [Вход] Минимальная требуемая область rowid. Возвращаемый rowid может быть больше. Должна быть одной из следующих:  
  
 SQL_SCOPE_CURROW: Rowid гарантированно допустимы только в том случае, если курсор находится в этой строке. Проведенная позднее повторная выборка с использованием rowid не может вернуть строку, если строка была обновлена или удалена другой транзакцией.  
  
 SQL_SCOPE_TRANSACTION: Rowid гарантированно допустимы в течение текущей транзакции.  
  
 SQL_SCOPE_SESSION: Rowid гарантированно допустимы в течение всего сеанса (несмотря на границы транзакций).  
  
 *Допускает значения NULL*  
 [Вход] Определяет, следует ли возвращать специальные столбцы, которые могут иметь значение NULL. Должна быть одной из следующих:  
  
 SQL_NO_NULLS: Исключить специальные столбцы, которые могут иметь значения NULL. Некоторые драйверы не поддерживает SQL_NO_NULLS и возвращает пустой результирующий набор, если указан SQL_NO_NULLS эти драйверы. Следует подготовить приложения для этого случая и запрос SQL_NO_NULLS только в том случае, если это абсолютно необходимо.  
  
 SQL_NULLABLE: Возвращать особые столбцы, даже если они могут иметь значения NULL.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_STILL_EXECUTING, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSpecialColumns** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из Значение SQL_HANDLE_STMT и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLSpecialColumns** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|24000|Недопустимое состояние курсора|Курсор был открыт на *StatementHandle*, и **SQLFetch** или **SQLFetchScroll** бы была вызвана. Если эта ошибка возвращается диспетчером драйверов **SQLFetch** или **SQLFetchScroll** не вернула значение SQL_NO_DATA и возвращается с помощью драйвера, если **SQLFetch** или **SQLFetchScroll** вернула значение SQL_NO_DATA.<br /><br /> Курсор был открыт на *StatementHandle*, но **SQLFetch** или **SQLFetchScroll** не был вызван.|  
|40001|Сбой сериализации|Транзакции выполнен откат из-за взаимоблокировку ресурсов в другой транзакции.|  
|40003|Неизвестный завершение операторов|Сбой подключения во время выполнения этой функции и не удается определить состояние транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем функция была вызвана снова на *StatementHandle*.<br /><br /> Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY009|Недопустимое использование пустого указателя|*TableName* аргумент был пустым указателем.<br /><br /> Атрибут инструкции SQL_ATTR_METADATA_ID было задано значение SQL_TRUE, *CatalogName* аргумент был пустым указателем, а SQL_CATALOG_NAME *свойство* возвращает которых имена каталога поддерживаются.<br /><br /> (DM) атрибут инструкции SQL_ATTR_METADATA_ID было задано значение SQL_TRUE и *SchemaName* аргумент был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом функция **SQLSpecialColumns** был вызван.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ЭТОТ ПАРАМЕТР ДОСТУПЕН. До получения данных для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение одного из аргументов длины был меньше 0, но не равно SQL_NTS.<br /><br /> Значение одного из аргументов длина превышает значение максимальной длины для соответствующего имени. Максимальная длина имени каждого можно получить, вызвав **SQLGetInfo** с *свойство* значения: SQL_MAX_CATALOG_NAME_LEN, SQL_MAX_SCHEMA_NAME_LEN или SQL_MAX_TABLE_NAME_LEN.|  
|HY097|Тип столбца за пределами допустимого диапазона|(DM) недопустимый *IdentifierType* было указано значение.|  
|HY098|Тип области вне допустимого диапазона|(DM) недопустимый *область* было указано значение.|  
|HY099|Тип Nullable за пределами диапазона|(DM) недопустимый *Nullable* было указано значение.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Был указан каталог, а драйвер или источник данных не поддерживает каталоги.<br /><br /> Схема была указана и драйвера или источник данных не поддерживает схемы.<br /><br /> Сочетание текущих настроек атрибуты инструкции SQL_ATTR_CONCURRENCY и SQL_ATTR_CURSOR_TYPE не поддерживается драйвером или источником данных.<br /><br /> Атрибут инструкции SQL_ATTR_USE_BOOKMARKS было задано значение SQL_UB_VARIABLE, а атрибут инструкции SQL_ATTR_CURSOR_TYPE был задан тип курсора, для которого драйвер не поддерживает закладки.|  
|HYT00|Время ожидания истекло|Прежде чем источника данных, запрошенный результирующий набор истечения времени ожидания запроса. Время ожидания задается с помощью **SQLSetStmtAttr**, SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
  
## <a name="comments"></a>Комментарии  
 Когда *IdentifierType* аргумент является SQL_BEST_ROWID, **SQLSpecialColumns** возвращает столбец или столбцы, которые однозначно определяют каждую строку в таблице. Эти столбцы могут использоваться всегда в *список выбора* или **ГДЕ** предложения. **SQLColumns**, который используется для возвращения различных сведений для столбцов таблицы, не возвращает обязательно столбцы, которые однозначно определяют каждую строку или столбцы, которые автоматически обновляются, когда любое значение в строке обновляется транзакция. Например **SQLColumns** не может возвратить ROWID псевдо столбец Oracle. Именно поэтому **SQLSpecialColumns** используется для возврата этих столбцов. Дополнительные сведения см. в разделе [использует данные из каталога](../../../odbc/reference/develop-app/uses-of-catalog-data.md).  
  
> [!NOTE]  
>  Дополнительные сведения о общего использования, аргументы и возвращаемые данные функций каталога ODBC см. в разделе [функций каталога](../../../odbc/reference/develop-app/catalog-functions.md).  
  
 Если нет столбцов, которые однозначно определяют каждую строку в таблице, **SQLSpecialColumns** возвращает набор строк без строк; в последующем вызове **SQLFetch** или **SQLFetchScroll**в инструкции не вернет значение SQL_NO_DATA.  
  
 Если *IdentifierType*, *область*, или *Nullable* аргументы задают характеристики, которые не поддерживаются источником данных, **SQLSpecialColumns**  возвращает пустой результирующий набор.  
  
 Если атрибут инструкции SQL_ATTR_METADATA_ID задано значение SQL_TRUE, *CatalogName*, *SchemaName*, и *TableName* рассматривается как идентификаторы, поэтому они Невозможно задать указатель null в определенных ситуациях. (Дополнительные сведения см. в разделе [аргументов функций каталога](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).)  
  
 **SQLSpecialColumns** возвращает результаты в виде стандартных результирующий набор, упорядоченный по области.  
  
 Следующие столбцы были переименованы для ODBC 3*.x*. Имя столбца изменения не влияют на обратной совместимости так, как привязать приложений, номер столбца.  
  
|Столбец ODBC 2.0|ODBC 3*.x* столбца|  
|---------------------|-----------------------|  
|PRECISION|COLUMN_SIZE|  
|LENGTH|BUFFER_LENGTH|  
|SCALE|DECIMAL_DIGITS|  
  
 Чтобы определить фактическую длину столбца COLUMN_NAME, приложение может вызвать **SQLGetInfo** с параметром SQL_MAX_COLUMN_NAME_LEN.  
  
 В следующей таблице перечислены столбцы в результирующем наборе. Дополнительные столбцы вслед за столбец 8 (PSEUDO_COLUMN) можно определить с помощью драйвера. Приложение должно получить доступ к от драйвера отсчет от конца результирующего набора, а не порядковый номер явное указание. Дополнительные сведения см. в разделе [данные, возвращаемые функциями каталога](../../../odbc/reference/develop-app/data-returned-by-catalog-functions.md).  
  
|Имя столбца|Номер столбца|Тип данных|Комментарии|  
|-----------------|-------------------|---------------|--------------|  
|ОБЛАСТЬ (ODBC 1.0)|1|Smallint|Фактическая область rowid. Содержит одно из следующих значений:<br /><br /> SQL_SCOPE_CURROW SQL_SCOPE_TRANSACTION SQL_SCOPE_SESSION<br /><br /> Возвращается значение NULL, когда *IdentifierType* — SQL_ROWVER. Описание каждого значения, см. в описании *область* в «Синтаксис» данного раздела.|  
|COLUMN_NAME (ODBC 1.0)|2|Varchar not NULL|Имя столбца. Драйвер возвращает пустую строку для столбца, который не имеет имени.|  
|ТИП ДАННЫХ (ODBC 1.0)|3|Smallint, не NULL|Тип данных SQL. Это может быть тип данных SQL драйвера или тип данных ODBC SQL. Список допустимых типов данных ODBC SQL см. в разделе [типов данных SQL](../../../odbc/reference/appendixes/sql-data-types.md). Сведения о типах данных драйвера SQL см. в документации драйвера.|  
|ФУНКЦИЯ TYPE_NAME (ODBC 1.0)|4|Varchar not NULL|Имя типа данных зависит от источника данных; Например «CHAR», «VARCHAR», «Денежный», «LONG VARBINARY» или «() CHAR FOR BIT DATA».|  
|COLUMN_SIZE (ODBC 1.0)|5|Целочисленный|Размер столбца в источнике данных. Дополнительные сведения, касающиеся размер столбца см. в разделе [размер столбца, десятичных цифр, длина в октетах передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).|  
|BUFFER_LENGTH (ODBC 1.0)|6|Целочисленный|Длина в байтах данных, передаваемых по **SQLGetData** или **SQLFetch** операции, если SQL_C_DEFAULT указан. Для числовых данных этот размер может отличаться от размера данных, хранящихся в источнике данных. Это значение совпадает с столбце COLUMN_SIZE для символьных или двоичных данных. Дополнительные сведения см. в разделе [размер столбца, десятичных цифр, длина в октетах передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).|  
|DECIMAL_DIGITS (ODBC 1.0)|7|Smallint|Десятичные цифры из столбца в источнике данных. Для типов данных, где неприменимы десятичных цифр, будет возвращено значение NULL. Дополнительные сведения, касающиеся десятичных цифр см. в разделе [размер столбца, десятичных цифр, длина в октетах передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).|  
|PSEUDO_COLUMN (ODBC 2.0)|8|Smallint|Указывает, является ли столбец псевдо столбца, например Oracle ROWID:<br /><br /> SQL_PC_UNKNOWN SQL_PC_NOT_PSEUDO SQL_PC_PSEUDO **Примечание:** для максимальной совместимости псевдостолбцов следует не заключать в кавычки идентификатором знак кавычек возвращенных **SQLGetInfo**.|  
  
 Приложение получает значения для SQL_BEST_ROWID, приложение может использовать эти значения суммирование этой строки в пределах области. **ВЫБЕРИТЕ** инструкции гарантированно возвращает ни одной строки или одной строки.  
  
 Если приложение reselects строку, основанного на rowid столбец или столбцы, и строка не найдена, приложение можно предположить, что строка была удалена или rowid столбцы были изменены. Обратное неверно: даже если rowid не изменилось, могло измениться других столбцов в строке.  
  
 Столбцы, возвращенные для столбца типа SQL_BEST_ROWID полезны для приложений, которые потребуется выполнить прокрутку вперед и назад в результирующий набор, чтобы получить последние данные из набора строк. Столбец или столбцы rowid гарантированно не изменить, пока располагается в этой строке.  
  
 Столбец или столбцы rowid может оставаться допустимым даже в том случае, если курсор не располагается в строку; приложение может определить это, проверьте столбец "SCOPE" в результирующем наборе.  
  
 Столбцы, возвращенные для столбца типа SQL_ROWVER полезны для приложений, которым требуется возможность проверки того, обновлены ли все столбцы в данной строке пока строки был повторно с использованием rowid. Например после повторно выбрать строку с использованием rowid, приложение можно сравнить предыдущие значения в столбцах SQL_ROWVER, чтобы извлечь только те. Если значение в столбце SQL_ROWVER отличается от предыдущего значения, приложение можно предупредить пользователя об изменении данных на экране.  
  
## <a name="code-example"></a>Пример кода  
 Пример кода, аналогичные функции, в разделе [SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфера|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат столбцов в таблице или таблицах|[Функция SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md)|  
|Выборка одной строки или блока данных в направлении только вперед|[Функция SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Выборка блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Возврат столбцов первичного ключа|[Функция SQLPrimaryKeys](../../../odbc/reference/syntax/sqlprimarykeys-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
