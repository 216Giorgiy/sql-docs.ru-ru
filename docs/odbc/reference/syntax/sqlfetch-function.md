---
title: SQLFetch, функция | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
apiname:
- SQLFetch
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLFetch
helpviewer_keywords:
- SQLFetch function [ODBC]
ms.assetid: 6c6611d2-bc6a-4390-87c9-1c5dd9cfe07c
caps.latest.revision: 27
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 2a340283066558215e5534e327026350cdcab589
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="sqlfetch-function"></a>SQLFetch, функция
**Соответствия**  
 Появился в версии: Полное соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLFetch** производит выборку следующего набора строк данных из результирующего набора и возвращает данные для всех связанных столбцов.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLFetch(  
     SQLHSTMT     StatementHandle);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLFetch** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав [функцию SQLGetDiagRec](../../../odbc/reference/syntax/sqlgetdiagrec-function.md) с *HandleType*значение sql_handle_stmt и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLFetch** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное. При возникновении ошибки для одного столбца, [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md) не может быть вызван с *DiagIdentifier* из SQL_DIAG_COLUMN_NUMBER определение столбца, произошла ошибка, и  **SQLGetDiagField** не может быть вызван с *DiagIdentifier* из SQL_DIAG_ROW_NUMBER, чтобы определить строку, которая содержит этот столбец.  
  
 Для всех этих SQLSTATE, которые могут возвращать значение SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением SQLSTATE 01xxx), возвращается SQL_SUCCESS_WITH_INFO, если в одной или нескольким, но не для всех строк многострочные операции происходит ошибка, и возвращается значение SQL_ERROR, если произошла ошибка Операция одной строки.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Строка справа усечение данных|Строка или двоичные данные, возвращаемые для столбца привело к усечению непустых символьных или двоичных данных от NULL. Если он был строковое значение, было усечено справа.|  
|01S01|Ошибка в строке|Произошла ошибка при получении одну или несколько строк.<br /><br /> (Если это SQLSTATE возвращается в том случае, когда ODBC 3 *.x* при работе с ODBC 2 *.x* драйвера, его можно пропустить.)|  
|01S07|Частичное усечение|Данные, возвращенные для столбца было усечено. Для числовых типов данных был усечен, дробная часть числа. Время, отметка времени и интервальных типов данных, которые содержат компонент времени дробная часть времени было усечено.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение столбца в результирующем наборе не удалось преобразовать тип данных, указанный в *TargetType* в **SQLBindCol**.<br /><br /> Столбец 0 был связан с типом данных SQL_C_BOOKMARK и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было задано значение SQL_UB_VARIABLE.<br /><br /> Столбец 0 был связан с типом данных SQL_C_VARBOOKMARK и не равно SQL_UB_VARIABLE атрибут SQL_ATTR_USE_BOOKMARKS инструкции.|  
|07009|Недопустимый индекс дескриптора|Драйвер не ODBC 2 *.x* драйвер, который не поддерживает **SQLExtendedFetch**, и номер столбца, указанный в привязке для столбца было равно 0.<br /><br /> Столбец 0 был привязан и атрибут инструкции SQL_ATTR_USE_BOOKMARKS было задано значение SQL_UB_OFF.|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22001|Строка справа усечение данных|Был усечен, возвращаемый для столбцов переменной длины закладки.|  
|22002|Индикатор обязательным, но не указано|Значение NULL, данные, которые были выбраны в столбец, *StrLen_or_IndPtr* задается **SQLBindCol** (или заданные SQL_DESC_INDICATOR_PTR **SQLSetDescField** или  **SQLSetDescRec**) является пустым указателем.|  
|22003|Численное значение вне допустимого диапазона|Возвращает числовое значение, как числа или строки для одного или нескольких связанных столбцов могло привести целиком (в отличие от доли) часть усекаемое число.<br /><br /> Дополнительные сведения см. в разделе [преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в типах данных приложение D:.|  
|22007|Формат недопустимые даты и времени|Символьный столбец в результирующем наборе был привязан к даты, времени или структура отметки времени C, а значение в столбце было, соответственно, неверной даты, времени или отметки времени.|  
|22012|Деление на ноль|Значение от арифметического выражения был возвращен, что привело к деления на ноль.|  
|22015|Переполнение поля интервала|Присвоение тип интервала C из точное числовое значение или интервал тип SQL привело к потере значащих разрядов в начале поля.<br /><br /> При получении данных для тип интервала C, возникла не представление значения в тип интервала C типа SQL.|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе был привязан к буфер символов C, а столбец содержится символ, для которого отсутствует в наборе символов буфера не представление.<br /><br /> Тип C был точное или Приблизительное числовое, datetime или тип интервала; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.|  
|24000|Недопустимое состояние курсора|*StatementHandle* находился в состоянии выполнения, но результирующий набор не связан с *StatementHandle*.|  
|40001|Сбой сериализации|Транзакции, в которой была выполнена выборка прервано для предотвращения взаимоблокировок.|  
|40003|Неизвестный завершение операторов|Сбой подключения во время выполнения этой функции и не удается определить состояние транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, который необходим для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. **SQLFetch** была вызвана функция и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*. Затем **SQLFetch** функция была вызвана снова на *StatementHandle*.<br /><br /> Или **SQLFetch** была вызвана функция и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*  из другого потока в многопоточных приложениях.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом асинхронной функция **SQLFetch** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ЭТОТ ПАРАМЕТР ДОСТУПЕН. До получения данных для всех параметров потоковой вызове этой функции.<br /><br /> (DM) указанного *StatementHandle* не находился в состоянии выполнения. Функция была вызвана без предварительного вызова функции **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.<br /><br /> (DM) **SQLFetch** был вызван для *StatementHandle* после **SQLExtendedFetch** был вызван и перед **SQLFreeStmt** с SQL_ Параметр «ЗАКРЫТЬ» был вызван.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|Атрибут инструкции SQL_ATTR_USE_BOOKMARK было задано значение SQL_UB_VARIABLE и 0 был привязан к буфера, длина которого не равно Максимальная длина закладки для этого результирующего набора. (Эта длина доступен в поле SQL_DESC_OCTET_LENGTH IRD и может быть получен путем вызова **SQLDescribeCol**, **SQLColAttribute**, или **SQLGetDescField**.)|  
|HY107|Значение строки за пределами диапазона|Значение, указанное с помощью атрибута SQL_ATTR_CURSOR_TYPE оператор был SQL_CURSOR_KEYSET_DRIVEN, но значение, указанное с помощью атрибута SQL_ATTR_KEYSET_SIZE атрибута инструкции больше 0 и меньше, чем значение, указанное в SQL_ATTR_ROW_ARRAY_ Атрибут инструкции размер.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает преобразование, определяется сочетанием *TargetType* в **SQLBindCol** и тип данных SQL соответствующего столбца.|  
|HYT00|Время ожидания истекло|Прежде чем источника данных, запрошенный результирующий набор истечения времени ожидания запроса. Время ожидания задается SQLSetStmtAttr SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
  
## <a name="comments"></a>Комментарии  
 **SQLFetch** возвращает следующий набор строк в результирующем наборе. Он может быть вызван, пока существует результирующий набор: то есть после вызова метода, который создает результирующий набор и перед курсор закрыт over, результирующий набор. Если какие-либо столбцы привязаны, возвращающий данные в этих столбцах. Если приложение указатель на массив состояния строк или буфер, в которую возвращается число возвращаемых строк, **SQLFetch** также возвращает эти сведения. Вызовы **SQLFetch** можно комбинировать с вызовами **SQLFetchScroll** , но невозможно комбинировать с вызовами **SQLExtendedFetch**. Дополнительные сведения см. в разделе [выборки данных из строк](../../../odbc/reference/develop-app/fetching-a-row-of-data.md).  
  
 Если ODBC 3 *.x* приложение работает с ODBC 2 *.x* сопоставляет драйвера, диспетчер драйверов **SQLFetch** вызовы **SQLExtendedFetch** для ODBC 2 *.x* драйвером, поддерживающим **SQLExtendedFetch**. Если ODBC 2 *.x* драйвер не поддерживает **SQLExtendedFetch**, диспетчер драйверов сопоставляет **SQLFetch** вызовы **SQLFetch** в ODBC версии 2 *.x* драйвер, который можно выбрать только одну строку.  
  
 Дополнительные сведения см. в разделе [блочных курсоров, Прокручиваемые курсоры и обратной совместимости](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md) в приложении G: драйвер рекомендации для обеспечения обратной совместимости.  
  
## <a name="positioning-the-cursor"></a>Позиционирование курсора  
 Когда создается результирующий набор, курсор располагается перед началом результирующего набора. **SQLFetch** извлекает следующий набор строк. Это эквивалентно вызову метода **SQLFetchScroll** с *FetchOrientation* значение SQL_FETCH_NEXT. Дополнительные сведения о курсорах см. в разделе [курсоров](../../../odbc/reference/develop-app/cursors.md) и [блочные курсоры](../../../odbc/reference/develop-app/block-cursors.md).  
  
 Атрибут SQL_ATTR_ROW_ARRAY_SIZE инструкции указывает число строк в наборе строк. Если набор строк возвращаемых при **SQLFetch** перекрывается конца результирующего набора, **SQLFetch** возвращает частичный набор строк. То есть если S + R – 1 больше, чем L, где S — начальную строку набора строк выбранных, R равно размеру набора строк, а L является последней строки в результирующем наборе, затем первый L – S + 1 строк набора строк являются допустимыми. Оставшиеся строки являются пустыми и имеют статус SQL_ROW_NOROW.  
  
 После **SQLFetch** возвращает, текущая строка является первой строки набора строк.  
  
 Правила, перечисленные в следующей таблице описаны после вызова позиционирования курсора **SQLFetch**в зависимости от условия, указанные во второй таблице в этом разделе.  
  
|Условие|Первая строка новый набор строк|  
|---------------|-----------------------------|  
|Перед запуском|1|  
|*CurrRowsetStart* \< =  *LastResultRow — RowsetSize*[1]|*CurrRowsetStart* + *RowsetSize*[2]|  
|*CurrRowsetStart* > *LastResultRow — RowsetSize*[1]|После окончания|  
|После окончания|После окончания|  
  
 [1] Если размер набора строк изменяется между выборки, это размер набора строк, который был использован с предыдущей выборке.  
  
 [2] Если размер набора строк изменяется между выборки, это размер набора строк, который был использован с новой выборке.  
  
|Нотация|Значение|  
|--------------|-------------|  
|Перед запуском|Прямоугольный курсор располагается перед началом результирующего набора. Перед началом результирующего набора, если первая строка новый набор строк **SQLFetch** не вернет значение SQL_NO_DATA.|  
|После окончания|Прямоугольный курсор располагается после конце результирующего набора. Если первая строка новый набор строк в конце результирующего набора, **SQLFetch** не вернет значение SQL_NO_DATA.|  
|*CurrRowsetStart*|Номер первой строки в текущем наборе строк.|  
|*LastResultRow*|Номер последней строки в результирующем наборе.|  
|*RowsetSize*|Размер набора строк.|  
  
 Например предположим, что результирующий набор состоит из 100 строк и размера набора строк — 5. В следующей таблице показаны набора строк и возвращают код, возвращенный **SQLFetch** для разных начальной позиции.  
  
|Текущий набор строк|Код возврата|Новый набор строк|число строк, загружаемых|  
|--------------------|-----------------|----------------|------------------------|  
|Перед запуском|SQL_SUCCESS|1 – 5|5|  
|1 – 5|SQL_SUCCESS|6-10|5|  
|52-56|SQL_SUCCESS|57 для 61|5|  
|91 до 95|SQL_SUCCESS|96 до 100|5|  
|93 к 97|SQL_SUCCESS|98 до 100. Строки 4 и 5, состояние массива строк, присваивается SQL_ROW_NOROW.|3|  
|96 до 100|ЗНАЧЕНИЕ SQL_NO_DATA|Нет.|0|  
|99 до 100|ЗНАЧЕНИЕ SQL_NO_DATA|Нет.|0|  
|После окончания|ЗНАЧЕНИЕ SQL_NO_DATA|Нет.|0|  
  
## <a name="returning-data-in-bound-columns"></a>Возврат данных в привязанные столбцы  
 Как **SQLFetch** возвращает каждой строки, он помещает данные для каждого привязанного столбца в буфере, привязанного к этому столбцу. Если столбцы не связываются, **SQLFetch** вперед блочного курсора, но не возвращает никаких данных. Данные по-прежнему могут быть получены с помощью **SQLGetData**. Если курсор является многострочные (то есть SQL_ATTR_ROW_ARRAY_SIZE больше 1), **SQLGetData** может вызываться только в том случае, если SQL_GD_BLOCK возвращается **SQLGetInfo** вызывается с  *Свойство* из SQL_GETDATA_EXTENSIONS. (Дополнительные сведения см. в разделе [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md).)  
  
 Для каждого привязанного столбца в строке **SQLFetch** делает следующее:  
  
1.  Задает буфер длины/индикатора на SQL_NULL_DATA и переход на следующий столбец, если данные имеют значение NULL. Если данные имеют значение NULL и буфер длины/индикатора не был привязан, **SQLFetch** возвращает SQLSTATE 22002 (индикатор но не была предоставлена) для строки и переходит на следующую строку. Сведения о том, как определить адрес в буфер длины/индикатора в разделе «Буфера адреса» в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
     Если данные для столбца не равно NULL, **SQLFetch** переходит к шагу 2.  
  
2.  Если атрибут инструкции sql_attr_max_length параметра задано ненулевое значение, и столбец содержит символьных или двоичных данных, данные усекаются до значения SQL_ATTR_MAX_LENGTH байт.  
  
    > [!NOTE]  
    >  Атрибут sql_attr_max_length параметра инструкции предназначены для сокращения сетевого трафика. Обычно он реализован в источнике данных, который производит усечение данных перед возвращением по сети. Драйверы и источники данных не требуется для его поддержки. Таким образом, чтобы гарантировать, что данные будут усечены до определенного размера, приложение должно выделить буфер указанного размера и укажите размер в *cbValueMax* аргумент в **SQLBindCol**.  
  
3.  Преобразует данные в тип, заданный параметром *TargetType* в **SQLBindCol**.  
  
4.  Если данные был преобразован в тип данных переменной длины, например символьный или двоичный файл, **SQLFetch** проверяет, является ли длина данных превышает длину буфера данных. Если длина символьных данных (включая символ завершения null) превышает длину буфера данных, **SQLFetch** усечение данных до длины буфера данных меньше длины символа конечное значение null. Он затем null прерывает данные. Если длина двоичных данных превышает длину буфера данных **SQLFetch** обрезает его до длины буфера данных. Длина буфера данных задается с помощью *BufferLength* в **SQLBindCol**.  
  
     **SQLFetch** никогда не усекает данные преобразовать типы данных фиксированной длины; он всегда предполагается, что длина буфера данных размер типа данных.  
  
5.  Помещает преобразованный (и возможно усеченное) данные в буфере данных. Сведения о том, как определить адрес буфера данных. в разделе «Буфера адреса» в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
6.  Длина данных помещаются в буфер длины/индикатора. Если индикатор указателя и указатель на длину устанавливаются для того же буфера (как вызов **SQLBindCol** does), длина записывается в буфер для допустимых данных и SQL_NULL_DATA записывается в буфер для значения NULL. Если буфер длины/индикатора не был привязан, **SQLFetch** не возвращает длину.  
  
    -   Для символьных или двоичных данных это длина данных после преобразования и перед усечение из-за слишком низкого буфера данных. Если драйвер не может определить длину данных после преобразования, как иногда в случае с большие объемы данных, она задает длину для SQL_NO_TOTAL. Если данные были усечены из-за атрибута инструкции sql_attr_max_length параметра, значение этого атрибута будет помещен в буфер длины/индикатора, а не фактическую длину. Это потому, что этот атрибут предназначен для усечения данных на сервере до преобразования, чтобы драйвер никак не нужно определять, фактическая длина:.  
  
    -   Для всех других типов данных это длина данных после преобразования; он является размер тип, к которому был преобразован данные.  
  
     Сведения о том, как определить адрес в буфер длины/индикатора в разделе «Буфера адреса» в [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
7.  Если данные будут усечены во время преобразования без потери значащих цифр (например, вещественное число 1,234 усекается до 1 при преобразовании целого числа), **SQLFetch** возвращает SQLSTATE 01S07 (частичное усечение) и SQL_ SUCCESS_WITH_INFO. Если данные будут усечены, так как длина буфера данных слишком мал (например, строка «abcdef» помещается в буфер байтов 4), **SQLFetch** возвращает SQLSTATE 01004 (данных) и SQL_SUCCESS_WITH_INFO. Если данные будут усечены из-за инструкции атрибут значения SQL_ATTR_MAX_LENGTH **SQLFetch** возвращает SQL_SUCCESS и не возвращает SQLSTATE 01S07 (частичное усечение) или SQLSTATE 01004 (данных). Если данные будут усечены во время преобразования с потерей значащих цифр (например, если значение больше 100 000 SQL_INTEGER были преобразованы в SQL_C_TINYINT) **SQLFetch** возвращает SQLSTATE 22003 (численное значение вне допустимого диапазона) и значение SQL_ERROR (если размер набора строк равен 1) или SQL_SUCCESS_WITH_INFO (если размер набора строк больше, чем 1).  
  
 Содержимое буфера привязанного к данным и буфер длины/индикатора не определены, если **SQLFetch** или **SQLFetchScroll** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
## <a name="row-status-array"></a>Массив состояния строк  
 Массив состояния строк используется для возвращения состояния каждой строки в наборе строк. С помощью атрибута инструкции sql_attr_row_status_ptr, которое указывает указан адрес данного массива. Массив выделяется для приложения и должен иметь столько элементов, как указано в атрибуте SQL_ATTR_ROW_ARRAY_SIZE инструкции. Задаются значения его **SQLFetch**, **SQLFetchScroll**, и **SQLBulkOperations** или **SQLSetPos** (за исключением того, если они уже были вызваны После курсор, было располагается по **SQLExtendedFetch**). Если значение атрибута инструкции значения SQL_ATTR_ROW_STATUS_PTR является пустым указателем, эти функции не возвращают строки состояния.  
  
 Содержимое буфера строки состояния массива не определены, если **SQLFetch** или **SQLFetchScroll** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
 Следующие значения возвращаются в массив состояния строк.  
  
|Значение массива строки состояния|Описание|  
|----------------------------|-----------------|  
|SQL_ROW_SUCCESS|Строка была успешно получен и не изменились с момента последней загрузки из этого результирующего набора.|  
|SQL_ROW_SUCCESS_WITH_INFO|Строка была успешно получен и не изменились с момента последней загрузки из этого результирующего набора. Однако предупреждение был возвращен о строке.|  
|SQL_ROW_ERROR|Произошла ошибка при получении строки.|  
|SQL_ROW_UPDATED [1], [2] и [3]|Строка была успешно получен и была изменена с момента последней загрузки из этого результирующего набора. Если строка выбирается заново из этого результирующего набора или обновляется в соответствии с **SQLSetPos**, состояние изменяется на новое состояние строки.|  
|SQL_ROW_DELETED [3]|Строка была удалена с момента последней загрузки из этого результирующего набора.|  
|SQL_ROW_ADDED [4]|Строка была вставлена **SQLBulkOperations**. Если строка выбирается заново из этого результирующего набора или обновляется в соответствии с **SQLSetPos**, она находится в состоянии SQL_ROW_SUCCESS.|  
|SQL_ROW_NOROW|Набор строк перекрывающегося конца результирующего набора и строки не был возвращен, что значение соответствовало этот элемент массив состояния строк.|  
  
 [1] для ключей, смешанные и динамические курсоры, при обновлении значения ключа строка данных считается были удалены и добавлена новая строка.  
  
 [2], некоторые драйверы не может обнаружить обновления данных и поэтому не может возвращать это значение. Чтобы определить ли драйвер может обнаружить обновления refetched строк, приложение вызывает **SQLGetInfo** с параметром SQL_ROW_UPDATES.  
  
 [3] **SQLFetch** может возвращать это значение, только когда это вперемешку с вызовы **SQLFetchScroll**. Это вызвано **SQLFetch** перемещается вперед по результирующему набору и если она используется в монопольном режиме, не повторно извлечь все строки. Так как строки не являются refetched, **SQLFetch** не обнаруживает изменения, внесенные в ранее извлеченных строк. Однако если **SQLFetchScroll** помещает курсор перед любой ранее выбранных строк и **SQLFetch** позволяет извлечь эти строки **SQLFetch** может обнаружить все изменения в Эти строки.  
  
 [4], возвращенных SQLBulkOperations только. Не задано **SQLFetch** или **SQLFetchScroll**.  
  
### <a name="rows-fetched-buffer"></a>Буфер извлеченных строк  
 Извлеченных буфера строк используется для возврата числа возвращаемых строк, включая те строки, для которых было возвращено никаких данных, так как они были выбраны произошла ошибка. Другими словами это число строк, для которых значение в массив состояния строк не SQL_ROW_NOROW. С помощью атрибута SQL_ATTR_ROWS_FETCHED_PTR инструкции указан адрес данного буфера. Буфер выделяется для приложения. Оно задается **SQLFetch** и **SQLFetchScroll**. Если значение атрибута SQL_ATTR_ROWS_FETCHED_PTR инструкция является пустым указателем, эти функции не возвращают число возвращаемых строк. Чтобы определить номер текущей строки в результирующем наборе, приложение может вызвать **SQLGetStmtAttr** с атрибутом SQL_ATTR_ROW_NUMBER.  
  
 Содержимое буфера извлеченных строк не определены, если **SQLFetch** или **SQLFetchScroll** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, за исключением случаев, когда будет возвращено значение SQL_NO_DATA, в этом случае значение в строках буфера выборки равно 0.  
  
### <a name="error-handling"></a>Обработка ошибок  
 Ошибки и предупреждения можно применять к отдельным строкам или функции в целом. Дополнительные сведения о диагностических записях см. в разделе [диагностики](../../../odbc/reference/develop-app/diagnostics.md) и [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md).  
  
#### <a name="errors-and-warnings-on-the-entire-function"></a>Ошибки и предупреждения для всей функции  
 Если ошибка относится ко всей функции, такие как SQLSTATE HYT00 (превышено время ожидания) или SQLSTATE 24000 (недопустимое состояние курсора), **SQLFetch** возвращает значение SQL_ERROR и применимые SQLSTATE. Содержимое буфера строк не определено, и позиция курсора не меняется.  
  
 Если предупреждение применяется ко всей функции **SQLFetch** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE применимо. Состояние записи для предупреждений, которые применяются ко всей функции возвращаются до состояния записей, которые применяются к отдельным строкам.  
  
#### <a name="errors-and-warnings-in-individual-rows"></a>Ошибки и предупреждения в отдельных строках.  
 Если произошла ошибка (например SQLSTATE 22012 (деление на ноль)) или предупреждение (например, SQLSTATE 01004 (данные усечены)) применяется к одной строки, **SQLFetch**делает следующее:  
  
-   Задает соответствующий элемент массив состояния строк SQL_ROW_ERROR ошибок или SQL_ROW_SUCCESS_WITH_INFO для предупреждений.  
  
-   Добавляет ноль или более записей состояния, содержащие атрибуты SQLSTATE для ошибки или предупреждения.  
  
-   Задает поля номеров строк и столбцов в записях состояния. Если **SQLFetch** не удается определить число строк или столбцов, он присваивает это число SQL_ROW_NUMBER_UNKNOWN или SQL_COLUMN_NUMBER_UNKNOWN, соответственно. Если запись состояния не применяется к отдельному столбцу, **SQLFetch** SQL_NO_COLUMN_NUMBER задает номер столбца.  
  
 **SQLFetch** по-прежнему выборки строк, пока он выбраны все строки в наборе строк. Он возвращает значение SQL_SUCCESS_WITH_INFO, если происходит ошибка в каждой строке набора строк (не включая строки со статусом SQL_ROW_NOROW), в этом случае он возвращает значение SQL_ERROR. В частности, если размер набора строк равен 1 и возникает ошибка в этой строке **SQLFetch** возвращает значение SQL_ERROR.  
  
 **SQLFetch** возвращает состояние записи в порядке номеров строк. То есть он возвращает все записи состояния для неизвестных строк (если таковые имеются); Затем он возвращает все записи состояния для первой строки (если таковые имеются) и затем возвращает все записи состояния для второй строке (если таковые имеются) и т. д. Состояние записи для каждой строки упорядочены в соответствии с обычным правилам для упорядочения записей состояния; Дополнительные сведения см. в разделе «Последовательность записей состояния» в [SQLGetDiagField](../../../odbc/reference/syntax/sqlgetdiagfield-function.md).  
  
### <a name="descriptors-and-sqlfetch"></a>Дескрипторы и SQLFetch  
 В следующих разделах описаны как **SQLFetch** взаимодействует с дескрипторами.  
  
#### <a name="argument-mappings"></a>Сопоставление аргументов  
 Драйвер не устанавливает все поля дескриптора, в зависимости от аргументов **SQLFetch**.  
  
#### <a name="other-descriptor-fields"></a>Другие поля дескриптора  
 Используются следующие поля дескриптора **SQLFetch**.  
  
|Поле дескриптора|DESC.|Поля в|Задать с помощью|  
|----------------------|-----------|--------------|-----------------|  
|SQL_DESC_ARRAY_SIZE|ОТМЕНИТЬ|Заголовок|Атрибут SQL_ATTR_ROW_ARRAY_SIZE инструкции|  
|SQL_DESC_ARRAY_STATUS_PTR|IRD|Заголовок|Атрибут значения SQL_ATTR_ROW_STATUS_PTR инструкции|  
|SQL_DESC_BIND_OFFSET_PTR|ОТМЕНИТЬ|Заголовок|Атрибут инструкции SQL_ATTR_ROW_BIND_OFFSET_PTR|  
|SQL_DESC_BIND_TYPE|ОТМЕНИТЬ|Заголовок|Атрибут инструкции SQL_ATTR_ROW_BIND_TYPE|  
|SQL_DESC_COUNT|ОТМЕНИТЬ|Заголовок|*ColumnNumber* аргумент **SQLBindCol**|  
|SQL_DESC_DATA_PTR|ОТМЕНИТЬ|записей|*TargetValuePtr* аргумент **SQLBindCol**|  
|SQL_DESC_INDICATOR_PTR|ОТМЕНИТЬ|записей|*StrLen_or_IndPtr* аргумент в **SQLBindCol**|  
|SQL_DESC_OCTET_LENGTH|ОТМЕНИТЬ|записей|*BufferLength* аргумент в **SQLBindCol**|  
|SQL_DESC_OCTET_LENGTH_PTR|ОТМЕНИТЬ|записей|*StrLen_or_IndPtr* аргумент в **SQLBindCol**|  
|SQL_DESC_ROWS_PROCESSED_PTR|IRD|Заголовок|Атрибут инструкции SQL_ATTR_ROWS_FETCHED_PTR|  
|SQL_DESC_TYPE|ОТМЕНИТЬ|записей|*TargetType* аргумент в **SQLBindCol**|  
  
 Все поля дескриптора можно также задать с помощью **SQLSetDescField**.  
  
#### <a name="separate-length-and-indicator-buffers"></a>Отдельные длины и индикатора буферов  
 Приложения можно связать один буфер или два отдельных буферов, используемых для хранения значения длины и индикатора. Если приложение вызывает **SQLBindCol**, драйвер задает поля SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR Отменить один и тот же адрес, который передается в *StrLen_or_IndPtr* аргумент. Если приложение вызывает **SQLSetDescField** или **SQLSetDescRec**, его можно задать эти поля к различным адресам.  
  
 **SQLFetch** определяет, ли приложение указанного отдельных буферов длины и индикатора. В этом случае, когда данные не равно NULL, **SQLFetch** задает буфер индикатор 0 и возвращает длину в буфер длины. Если данные имеют значение NULL, **SQLFetch** задает буфера индикатора на SQL_NULL_DATA и не изменяет длину буфера.  
  
### <a name="code-example"></a>Пример кода  
 В разделе [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md), [SQLColumns](../../../odbc/reference/syntax/sqlcolumns-function.md), [SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md), и [SQLProcedures](../../../odbc/reference/syntax/sqlprocedures-function.md).  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфера|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат сведений о столбце в результирующий набор|[Функция SQLDescribeCol](../../../odbc/reference/syntax/sqldescribecol-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнения подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Выборка блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Закрытие курсора на инструкции|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Извлечение всех или части столбца данных|[Функция SQLGetData](../../../odbc/reference/syntax/sqlgetdata-function.md)|  
|Возвращает число результирующих столбцов набора|[Функция SQLNumResultCols](../../../odbc/reference/syntax/sqlnumresultcols-function.md)|  
|Подготовка инструкции для выполнения|[Функция SQLPrepare](../../../odbc/reference/syntax/sqlprepare-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
