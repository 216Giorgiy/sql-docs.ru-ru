---
title: Функция SQLConnect | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
apiname:
- SQLConnect
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLConnect
helpviewer_keywords:
- SQLConnect function [ODBC]
ms.assetid: 59075e46-a0ca-47bf-972a-367b08bb518d
caps.latest.revision: 37
author: MightyPen
ms.author: genemi
manager: craigg
ms.workload: On Demand
ms.openlocfilehash: e34b622b12cc4de020403eda60bdd6b5d231777d
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="sqlconnect-function"></a>Функция SQLConnect
**Соответствия**  
 Появился в версии: Полное соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLConnect** устанавливает соединения с драйвером и источником данных. Дескриптора соединения ссылается на хранение всех сведений о соединении с источником данных, включая состояние, состояние транзакции и сведения об ошибке.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLConnect(  
     SQLHDBC        ConnectionHandle,  
     SQLCHAR *      ServerName,  
     SQLSMALLINT    NameLength1,  
     SQLCHAR *      UserName,  
     SQLSMALLINT    NameLength2,  
     SQLCHAR *      Authentication,  
     SQLSMALLINT    NameLength3);  
```  
  
## <a name="arguments"></a>Аргументы  
 *ConnectionHandle*  
 [Вход] Дескриптор соединения.  
  
 *ServerName*  
 [Вход] Имя источника данных. Данные могут быть расположены на том же компьютере, что и программа или на другом компьютере, где-нибудь в сети. Сведения о выборе источника данных в приложении см. в разделе [Выбор источника данных или драйвер](../../../odbc/reference/develop-app/choosing-a-data-source-or-driver.md).  
  
 *NameLength1*  
 [Вход] Длина **ServerName* в символах.  
  
 *UserName*  
 [Вход] Идентификатор пользователя.  
  
 *NameLength2*  
 [Вход] Длина **UserName* в символах.  
  
 *Проверка подлинности*  
 [Вход] Строка для проверки подлинности (обычно пароль).  
  
 *NameLength3*  
 [Вход] Длина **проверки подлинности* в символах.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE или SQL_STILL_EXECUTING.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLConnect** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_ HANDLE_DBC и *обработки* из *ConnectionHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLConnect** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменено|Драйвер не поддерживает указанное значение *ValuePtr* аргумент в **SQLSetConnectAttr** и заменить примерно такое же значение. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08001|Клиенту не удается установить соединение|Драйвер не удалось установить соединение с источником данных.|  
|08002|Имя подключения используется|(DM) указанного *ConnectionHandle* уже была использована для установления соединения с источником данных и подключение было все еще открыто и пользователь навигации для подключения.|  
|08004|Сервер отклонил соединение|Источник данных отклонены установление соединения по причинам, определяемого реализацией.|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которой пытается подключиться драйвер перед обработкой функции было завершено.|  
|28000|Недопустимая спецификация авторизации|Значение, указанное для аргумента *UserName* или значения, заданного для аргумента *проверки подлинности* нарушены ограничения, определенные в источнике данных.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Диспетчер драйверов (DM) не удалось выделить память, который необходим для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *ConnectionHandle*. **SQLConnect** была вызвана функция и до выполнения, [функция SQLCancelHandle](../../../odbc/reference/syntax/sqlcancelhandle-function.md) был вызван для *ConnectionHandle*и затем **SQLConnect** функция была вызвана снова на *ConnectionHandle*.<br /><br /> Или **SQLConnect** была вызвана функция и до выполнения, **SQLCancelHandle** был вызван для *ConnectionHandle* из другого потока в многопоточные приложения.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции (не данный файл) для *ConnectionHandle* и все еще выполняется, при вызове этой функции.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное в аргументе *NameLength1*, *NameLength2*, или *NameLength3* было меньше, чем 0, но не равно SQL_NTS.<br /><br /> (DM) значение, указанное в аргументе *NameLength1* превышена максимальная длина для имени источника данных.|  
|HYT00|Время ожидания истекло|Для подключения к источнику данных завершено истечения времени ожидания запроса. Время ожидания задается с помощью **SQLSetConnectAttr**, параметре.|  
|HY114|Драйвер не поддерживает подключение функция level асинхронного выполнения|(DM) приложение включен асинхронной операции на дескрипторе соединения перед подключением. Драйвер не поддерживает асинхронные операции для дескриптора соединения.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, указанного с помощью имени источника данных не поддерживает функцию.|  
|IM002|Не удалось найти источник данных и не указан драйвер по умолчанию|(DM) источника данных, имя, указанное в аргументе *ServerName* не найден в сведениях о системе, а также была ли определение драйвера по умолчанию.|  
|IM003|Указанный драйвер, не будут подключены к|Драйвер (DM), перечисленные в данных спецификация источника сведений о системе не найден или не было установлено для по другой причине.|  
|IM004|Не удалось выполнить SQLAllocHandle драйвера на SQL_HANDLE_ENV|(DM) во время **SQLConnect**, диспетчер драйверов называемая драйвером **SQLAllocHandle** функционировать с *HandleType* SQL_HANDLE_ENV и драйвер вернул ошибку.|  
|IM005|Не удалось выполнить SQLAllocHandle драйвера на SQL_HANDLE_DBC|(DM) во время **SQLConnect**, диспетчер драйверов называемая драйвером **SQLAllocHandle** функционировать с *HandleType* SQL_HANDLE_DBC и драйвер вернул ошибку.|  
|IM006|Не удалось выполнить SQLSetConnectAttr драйвера|Во время **SQLConnect**, диспетчер драйверов называемая драйвером **SQLSetConnectAttr** функции и драйвер вернул ошибку. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|IM009|Не удается подключиться к трансляции (DLL)|Драйвер не удалось подключиться к трансляции (DLL), указанный для источника данных.|  
|IM010|Слишком длинное имя источника данных|(DM)  *\*ServerName* более SQL_MAX_DSN_LENGTH символов.|  
|IM014|Указанное имя DSN содержит несоответствие архитектуры драйверов и приложения|32-разрядное приложение (DM) использует имя источника данных, подключение к 64-разрядный драйвер; и наоборот.|  
|IM015|Не удалось выполнить SQLConnect драйвера на SQL_HANDLE_DBC_INFO_HANDLE|Если драйвер возвращает значение SQL_ERROR, диспетчер драйверов вернет значение SQL_ERROR в приложение и соединение будет разорвано.<br /><br /> Дополнительные сведения о SQL_HANDLE_DBC_INFO_TOKEN см. в разделе [разработке пула соединений, поддерживающие драйвер ODBC](../../../odbc/reference/develop-driver/developing-connection-pool-awareness-in-an-odbc-driver.md).|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
|S1118|Драйвер не поддерживает асинхронное уведомление|Если драйвер не поддерживает асинхронное уведомление, нельзя вернуть SQL_ATTR_ASYNC_DBC_EVENT или SQL_ATTR_ASYNC_DBC_RETCODE_PTR.|  
  
## <a name="comments"></a>Комментарии  
 Сведения о том, почему приложение использует **SQLConnect**, в разделе [соединение с помощью SQLConnect](../../../odbc/reference/develop-app/connecting-with-sqlconnect.md).  
  
 Диспетчер драйверов не подключается к драйвер, пока приложение не вызовет функцию (**SQLConnect**, **SQLDriverConnect**, или **SQLBrowseConnect**) для подключения к драйвер. До этого момента диспетчера драйверов работает с свои собственные дескрипторы и управляет сведения о соединении. Когда приложение вызывает функцию соединений, диспетчер драйверов проверяет драйвер в настоящее время подключен ли для указанного *ConnectionHandle*:  
  
-   Если драйвер не подключен, диспетчер драйверов подключается к драйвера и вызовы **SQLAllocHandle** с *HandleType* установленным в значение sql_handle_env, **SQLAllocHandle** с *HandleType* установленным в значение sql_handle_dbc, **SQLSetConnectAttr** (если приложение указано любых атрибутов соединения) и функция подключения в драйвере. Диспетчер драйверов возвращает SQLSTATE IM006 (драйвера **SQLSetConnectOption** сбой) и SQL_SUCCESS_WITH_INFO для функции соединения, если драйвер вернул ошибку для **SQLSetConnectAttr**. Дополнительные сведения см. в разделе [соединения с источником данных или драйвер](../../../odbc/reference/develop-app/connecting-to-a-data-source-or-driver.md).  
  
-   Если указанный драйвер уже подключен к on *ConnectionHandle*, диспетчер драйверов вызывает функцию подключения в драйвере. В этом случае драйвер необходимо убедиться, что атрибуты все соединения для *ConnectionHandle* Ведение их текущих параметров.  
  
-   Если подключен другой драйвер, диспетчер драйверов вызывает **SQLFreeHandle** с *HandleType* установленным в значение sql_handle_dbc, и, если нет других драйвера подключен в этой среде, вызывает **SQLFreeHandle** с *HandleType* установленным в значение sql_handle_env в драйвере подключенной и отключается этого драйвера. Затем он выполняет те же операции, что если драйвер не соединен с.  
  
 Затем драйвер выделяет дескрипторов и инициализирует себя.  
  
 Когда приложение вызывает **SQLDisconnect**, диспетчер драйверов вызывает **SQLDisconnect** в драйвере. Тем не менее драйвер не отключить. В этом случае драйвер в памяти для приложений, которые многократно подключения и отключения от источника данных. Когда приложение вызывает **SQLFreeHandle** с *HandleType* установленным в значение sql_handle_dbc, диспетчер драйверов вызывает **SQLFreeHandle** с *HandleType*  установленным в значение sql_handle_stmt и затем **SQLFreeHandle** с *HandleType* установленным в значение sql_handle_env в драйвере, а затем отключается драйвер.  
  
 Приложение ODBC можно установить несколько подключений.  
  
## <a name="driver-manager-guidelines"></a>Диспетчер драйверов рекомендации  
 Содержимое **ServerName* влияют на совместную работу диспетчера драйверов и драйверов для установления соединения с источником данных.  
  
-   Если \* *ServerName* содержит допустимый источник данных, диспетчер драйверов находит соответствующий спецификации источника данных сведения о системе и подключается к соответствующий драйвер. Диспетчер драйверов передает каждого **SQLConnect** аргумент к драйверу.  
  
-   Если не удается найти имя источника данных или *ServerName* является пустым указателем, диспетчер драйверов находит спецификации источника данных по умолчанию и подключается к соответствующий драйвер. Диспетчер драйверов передает драйверу *UserName* и *проверки подлинности* аргументы без изменений и «DEFAULT» для *ServerName* аргумент.  
  
-   Если *ServerName* аргумент «DEFAULT», диспетчер драйверов находит спецификации источника данных по умолчанию и подключается к соответствующий драйвер. Диспетчер драйверов передает каждого **SQLConnect** аргумент к драйверу.  
  
-   Если не удается найти имя источника данных или *ServerName* является указателем null и значение по умолчанию, спецификации источника данных не существует, диспетчер драйверов возвращает ошибку SQL_ERROR с SQLSTATE IM002 (источник данных не найден и значение по умолчанию отсутствует драйвер указан).  
  
 После его подсоединения к диспетчером драйверов, драйвер может найти его соответствующей спецификации источника данных в сведения о системе и использует сведения из спецификации для завершения свой набор необходимые сведения для соединения.  
  
 Если библиотека преобразования по умолчанию указан в системные сведения для источника данных, драйвер подключается к нему. Библиотека различные преобразования можно подключить к путем вызова **SQLSetConnectAttr** с помощью настройки SQL_ATTR_TRANSLATE_LIB атрибутом. Параметр миграции можно указать путем вызова **SQLSetConnectAttr** с атрибутом SQL_ATTR_TRANSLATE_OPTION.  
  
 Если драйвер поддерживает **SQLConnect**, должен содержать раздел ключевое слово driver информация о системе для драйвера **ConnectFunctions** значение ключевого слова с первым символом «Y».  
  
### <a name="connection-pooling"></a>Организация пулов соединений  
 Организация пулов соединений позволяет приложению использовать подключение, который уже был создан. Если включен пул соединений и **SQLConnect** вызывается диспетчер драйверов пытается сделать соединение при помощи соединения, который является частью пула подключений в среде, которая была предназначена для пулов соединений. Эта среда хорошо общей среде, используемый для всех приложений, использующих соединения в пуле.  
  
 Организация пулов соединений включена перед вызовом выделяется среды **SQLSetEnvAttr** Настройка SQL_ATTR_CONNECTION_POOLING SQL_CP_ONE_PER_DRIVER (указывающая более чем один пул на драйвера) или SQL_CP_ONE_PER_HENV (указывает максимум один пул на среде). **SQLSetEnvAttr** в этом случае вызывается с *EnvironmentHandle* присваивается значение null, что делает атрибут атрибут уровня процесса. Если SQL_ATTR_CONNECTION_POOLING SQL_CP_OFF, пул подключений отключен.  
  
 Когда включено использование пулов соединений, **SQLAllocHandle** с *HandleType* установленным в значение sql_handle_env вызывается, чтобы выделить дескриптор среды. Среды, выделенной с помощью этого вызова является общей средой, так как включен пул соединений. Однако среду, которая будет использоваться не определено до **SQLAllocHandle** с *HandleType* SQL_HANDLE_DBC, называется.  
  
 **SQLAllocHandle** с *HandleType* SQL_HANDLE_DBC вызывается для выделения соединения. Диспетчер драйверов пытается найти существующей общей среды, соответствует атрибуты среды, установленный приложением. Если среда не существует, он будет создан как неявный *общей среды*. При обнаружении соответствующей общей среды приложению возвращается дескриптор среды и число ссылок увеличивается.  
  
 Однако соединения, который будет использоваться не определено до **SQLConnect** вызывается. На этом этапе диспетчер драйверов пытается найти существующее соединение в пуле соединений, которая соответствует критериям, запрошенный приложением. Критерии включают такие параметры соединения, запрашиваемого при вызове для **SQLConnect** (значения *ServerName*, *UserName*, и  *Проверка подлинности* ключевые слова) и задайте любые атрибуты соединения с момента **SQLAllocHandle** с *HandleType* был вызван установленным в значение sql_handle_stmt. Диспетчер драйверов проверяет этих критериев для соответствующих ключевых слов подключения и атрибуты в соединения в пуле. Если соответствие найдено, используется соединения в пуле. Если совпадение не найдено, создается новое соединение.  
  
 Если имеет значение атрибута среды SQL_ATTR_CP_MATCH SQL_CP_STRICT_MATCH, соответствие должен быть точное соединения в пул для использования. Если имеет значение атрибута среды SQL_ATTR_CP_MATCH SQL_CP_RELAXED_MATCH, соединение параметры в вызове **SQLConnect** необходимо соответствие, но не все атрибуты соединения должны совпадать.  
  
 Следующие правила применяются при атрибут соединения, задаваемое при помощи приложения перед **SQLConnect** вызывается, не соответствует атрибуту соединения соединения в пуле:  
  
-   Если атрибут соединения необходимо установить до подключения:  
  
     Если SQL_ATTR_CP_MATCH SQL_CP_STRICT_MATCH, SQL_ATTR_PACKET_SIZE в составе пула соединений должен быть идентичен атрибут, установленный приложением. Если SQL_CP_RELAXED_MATCH SQL_ATTR_PACKET_SIZE значения могут быть разными.  
  
     Значение SQL_ATTR_LOGIN_VALUE не влияет на совпадение.  
  
-   Если атрибут соединения можно задать до или после установки соединения.  
  
     Если атрибут соединения не было задано для приложения, но был задан для соединения в пуле, и значение по умолчанию, снова установить атрибут соединения в пуле соединений по умолчанию и объявлен совпадения. Если по умолчанию отсутствует, соединения не является соответствие.  
  
     Если атрибут соединения установлены приложением, но не указан для соединения в пуле, атрибут соединения в пуле изменены в указанный набор для приложения и объявляется совпадения.  
  
     Если атрибут соединения установлены приложением, а также был задан для соединения в пуле, но значения различаются, используется значение атрибута подключения приложения и объявлен совпадения.  
  
-   Если значения атрибутов драйвера соединения не совпадают, SQL_ATTR_CP_MATCH равно SQL_CP_STRICT_MATCH соединения в пуле не используется.  
  
 Когда приложение вызывает **SQLDisconnect** разорвать подключение, подключение возвращается в пул подключений, доступный для повторного использования.  
  
### <a name="optimizing-connection-pooling-performance"></a>Оптимизация производительности пула подключений  
 При использовании распределенных транзакций, можно оптимизировать пулы производительности с помощью соединений **SQL_DTC_TRANSITION_COST**, — битовая маска SQLUINTEGER. Переходы называют являются переходы подключения атрибут SQL_ATTR_ENLIST_IN_DTC, начиная от значения 0 ненулевое значение и наоборот. Это подключение, поступающих из не прикреплен к распределенной транзакции для прикрепляется к распределенной транзакции и наоборот. В зависимости от того, как драйвер внедрила прикрепление (параметр подключения атрибут SQL_ATTR_ENLIST_IN_DTC) эти переходы могут потреблять много ресурсов и поэтому следует избегать для достижения оптимальной производительности.  
  
 Значение, возвращаемое драйвер содержащего любое сочетание следующих битов:  
  
-   **SQL_DTC_ENLIST_EXPENSIVE**, когда набор, подразумевает нуля ненулевое переход значительно дороже, чем переход от ненулевое значение, к другой ненулевое значение (прикрепление ранее прикрепление соединения в его следующей транзакции).  
  
-   **SQL_DTC_UNENLIST_EXPENSIVE**, когда набор, подразумевает ненулевое значение, ноль переход стоит значительно дороже, чем при использовании соединения, атрибут SQL_ATTR_ENLIST_IN_DTC которого уже равен нулю.  
  
 Нет производительности и использования компромисс подключения. Если драйвер означает, что один или несколько этих переходов ресурсоемким, организатор пулов соединений диспетчер драйверов отвечает на это за счет дополнительных подключений в пуле. Некоторые подключения в пуле являются предпочтительными для использования нетранзакционной, а некоторые являются предпочтительными для использования транзакций. Тем не менее если драйвер указывает, что переходах, ресурсоемким, меньшее количество подключений можно, возможно, переключаясь между нетранзакционное и использования транзакций.  
  
 Драйверы, которые не поддерживают SQL_ATTR_ENLIST_IN_DTC не обязательно должны поддерживать SQL_DTC_TRANSITION_COST. Для драйверов, которые поддерживают SQL_ATTR_ENLIST_IN_DTC, но не SQL_DTC_TRANSITION_COST предполагается, что переходы не много ресурсов, как если бы драйвер возвращается значение 0 (нет установленных битов).  
  
 Несмотря на то, что SQL_DTC_TRANSITION_COST впервые появился в ODBC 3.5 ODBC 2. *x* драйвер также поддерживают его, поскольку диспетчер драйверов будет запрашивать эти сведения, независимо от версии драйвера.  
  
### <a name="code-example"></a>Пример кода  
 В следующем примере приложение выделяет среды и соединения дескрипторов. Затем он подключается к источнику данных заказов на продажу с бакалавра идентификатор пользователя и пароль Sesame и обрабатывает данные. После завершения обработки данных, он отключается от источника данных и освобождает маркеров.  
  
```  
// SQLConnect_ref.cpp  
// compile with: odbc32.lib  
#include <windows.h>  
#include <sqlext.h>  
  
int main() {  
   SQLHENV henv;  
   SQLHDBC hdbc;  
   SQLHSTMT hstmt;  
   SQLRETURN retcode;  
  
   SQLCHAR * OutConnStr = (SQLCHAR * )malloc(255);  
   SQLSMALLINT * OutConnStrLen = (SQLSMALLINT *)malloc(255);  
  
   // Allocate environment handle  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
  
   // Set the ODBC version environment attribute  
   if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
      retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);   
  
      // Allocate connection handle  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
         retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
  
         // Set login timeout to 5 seconds  
         if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
            SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
            // Connect to data source  
            retcode = SQLConnect(hdbc, (SQLCHAR*) "NorthWind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
  
            // Allocate statement handle  
            if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
               retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);   
  
               // Process data  
               if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO) {  
                  SQLFreeHandle(SQL_HANDLE_STMT, hstmt);  
               }  
  
               SQLDisconnect(hdbc);  
            }  
  
            SQLFreeHandle(SQL_HANDLE_DBC, hdbc);  
         }  
      }  
      SQLFreeHandle(SQL_HANDLE_ENV, henv);  
   }  
}  
```  
  
### <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Выделение дескриптора|[Функция SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)|  
|Обнаружение и перечисление значений, необходимых для подключения к источнику данных|[Функция SQLBrowseConnect](../../../odbc/reference/syntax/sqlbrowseconnect-function.md)|  
|Отключение от источника данных|[Функция SQLDisconnect](../../../odbc/reference/syntax/sqldisconnect-function.md)|  
|Соединение с источником данных, используется поле строки или диалоговое окно соединения|[Функция SQLDriverConnect](../../../odbc/reference/syntax/sqldriverconnect-function.md)|  
|Возврат значения атрибута соединения|[Функция SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Присвоение атрибуту соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
