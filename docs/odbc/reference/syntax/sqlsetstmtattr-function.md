---
title: Функция SQLSetStmtAttr | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
caps.latest.revision: 32
author: MightyPen
ms.author: genemi
manager: craigg
ms.workload: On Demand
ms.openlocfilehash: fab28d7076d4a529b1b77a340deb2f2e411da334
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="sqlsetstmtattr-function"></a>Функция SQLSetStmtAttr
**Соответствия**  
 Появился в версии: ODBC 3.0 нормативных требований: ISO-92  
  
 **Сводка**  
 **SQLSetStmtAttr** задает атрибуты, относящиеся к оператору.  
  
> [!NOTE]  
>  Дополнительные сведения о том, что диспетчер драйверов преобразует эту функцию для при ODBC 3*.x* при работе с ODBC 2*.x* драйвера, в разделе [сопоставление замены функции для назад Совместимость приложений](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *Атрибут*  
 [Вход] Возможность задания, перечисленные в «Комментарии».  
  
 *ValuePtr*  
 [Вход] Значение должно быть связано с *атрибут*. В зависимости от значения *атрибута*, *ValuePtr* будет иметь одно из следующих действий:  
  
-   Дескриптор ODBC.  
  
-   Значение SQLUINTEGER.  
  
-   Значение SQLULEN.  
  
-   Указатель на один из следующих:  
  
    -   Строка символов с завершающим нулем.  
  
    -   Двоичный буфера.  
  
    -   Значение или массив объектов типа SQLLEN, SQLULEN или SQLUSMALLINT.  
  
    -   Значение, определяемым драйвером.  
  
 Если *атрибута* аргумент представляет собой значение драйвера *ValuePtr* может быть целое число со знаком.  
  
 *stringLength*  
 [Вход] Если *атрибута* является атрибутом, определенных для ODBC и *ValuePtr* указывает на строку символов или двоичных буфера, данный аргумент должен иметь длину \* *ValuePtr*. Если *атрибута* является атрибутом, определенных для ODBC и *ValuePtr* является целым числом, *StringLength* учитывается.  
  
 Если *атрибута* является атрибутом, определяемым драйвером, приложение сможет определить природу атрибут диспетчера драйверов, задав *StringLength* аргумент. *StringLength* может иметь следующие значения:  
  
-   Если *ValuePtr* является указателем на строку символов, затем *StringLength* длина строки или SQL_NTS.  
  
-   Если *ValuePtr* — это указатель на двоичные буфер, то приложение помещает результат SQL_LEN_BINARY_ATTR (*длина*) макрос в *StringLength*. В этом случае отрицательное значение в *StringLength*.  
  
-   Если *ValuePtr* — это указатель на значение, отличное от строки символов или двоичная строка затем *StringLength* должно иметь значение SQL_IS_POINTER.  
  
-   Если *ValuePtr* содержит значение фиксированной длины, то *StringLength* — SQL_IS_INTEGER или SQL_IS_UINTEGER, соответствующим образом.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSetStmtAttr** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL _HANDLE_STMT и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLSetStmtAttr** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01S02|Значение параметра изменено|Драйвер не поддерживает значение, указанное в *ValuePtr*, или значение, указанное в *ValuePtr* недопустим из-за условий работы реализации, поэтому драйвер заменены примерно такое же значение. (**SQLGetStmtAttr** может быть вызвана для определения временно подставляемого значения.) Заменяющее значение допустимо для *StatementHandle* до закрытия курсора, после чего атрибут инструкции восстанавливает прежнее значение. Перечислены атрибуты инструкции, которые могут быть изменены.<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|24000|Недопустимое состояние курсора|*Атрибута* было SQL_ATTR_CURSOR_TYPE, SQL_ATTR_CONCURRENCY, SQL_ATTR_SIMULATE_CURSOR или SQL_ATTR_USE_BOOKMARKS, а курсор был открыт.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY009|Недопустимое использование пустого указателя|*Атрибута* аргумент определенный атрибут инструкции, которая требуемый строковый атрибут, и *ValuePtr* аргумент был пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом асинхронной функция **SQLSetStmtAttr** была вызвана функция.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ЭТОТ ПАРАМЕТР ДОСТУПЕН. До получения данных для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.|  
|HY011|Невозможно задать атрибут сейчас|*Атрибута* было SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR или SQL_ ATTR_USE_BOOKMARKS, а инструкция была подготовлена.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY017|Недопустимое использование автоматически выделенного дескриптора|(DM) *атрибута* аргумент имеет SQL_ATTR_IMP_ROW_DESC или SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) *атрибута* аргумент был SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC и значение в *ValuePtr* изначально был неявно выделенного дескриптора Кроме дескриптор выделить для Отменить или APD.|  
|HY024|Недопустимое значение атрибута|Получает указанный *атрибута* значение, недопустимое значение было указано в *ValuePtr*. (Диспетчер драйверов возвращает этот SQLSTATE только для подключения и атрибуты инструкции, которые принимают дискретного набора значений, таких как SQL_ATTR_ACCESS_MODE или SQL_ ATTR_ASYNC_ENABLE. Для всех других атрибутов соединения и инструкции, драйвер должен проверить значение, указанное в *ValuePtr*.)<br /><br /> *Атрибута* аргумент имеет SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC, и *ValuePtr* был явно выделенного дескриптора, которого нет в то же подключение  *StatementHandle* аргумент.|  
|HY090|Недопустимая длина строки или буфера|(DM)  *\*ValuePtr* представляет собой строку символов и *StringLength* аргумент был не меньше 0 но SQL_NTS.|  
|HY092|Недопустимый атрибут идентификатор или параметра|(DM) значение, указанное для аргумента *атрибут* не подходит для версии поддерживаются драйвером ODBC.<br /><br /> (DM) значение, указанное для аргумента *атрибут* был атрибут только для чтения.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Значение, указанное для аргумента *атрибут* был допустимым атрибут инструкции ODBC для используемая версия ODBC, поддерживаемых драйвером, но не поддерживается драйвером.<br /><br /> *Атрибута* аргумент был атрибуту SQL_ATTR_ASYNC_ENABLE и вызов **SQLGetInfo** с *свойство* SQL_ASYNC_MODE возвращает SQL_AM_CONNECTION.<br /><br /> *Атрибута* аргумент было SQL_ATTR_ENABLE_AUTO_IPD, а значение атрибута соединения SQL_ATTR_AUTO_IPD было SQL_FALSE.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|S1118|Драйвер не поддерживает асинхронное уведомление|Если вызов **SQLSetStmtAttr** для задания SQL_ATTR_ASYNC_STMT_EVENT; асинхронное уведомление не поддерживается драйвером.|  
  
## <a name="comments"></a>Комментарии  
 Атрибуты инструкции для инструкции, остаются в силе, пока они были изменены другим вызовом **SQLSetStmtAttr** или до удаления путем вызова инструкции **SQLFreeHandle**. Вызов **SQLFreeStmt** SQL_CLOSE, SQL_UNBIND или SQL_RESET_PARAMS параметр не сбрасывать атрибуты инструкции.  
  
 Некоторые атрибуты инструкции поддерживают замену примерно такое же значение, если источник данных не поддерживает значение, указанное в *ValuePtr*. В таких случаях драйвер возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01S02 (значение параметра изменено). Например если *атрибута* — SQL_ATTR_CONCURRENCY и *ValuePtr* SQL_CONCUR_ROWVER, и если источник данных не поддерживает это, драйвер подставляет SQL_CONCUR_VALUES и возвращает SQL_ SUCCESS_WITH_INFO. Чтобы определить значение, приложение вызывает **SQLGetStmtAttr**.  
  
 Формат данных, набор с *ValuePtr* зависит от указанного *атрибут*. **SQLSetStmtAttr** принимает данные атрибут в одной из двух различных форматов: строка символов или является целым числом. Недопустимый формат, указывается в описание атрибута. Этот формат распространяется на данные, возвращаемые для каждого атрибута в **SQLGetStmtAttr**. Символьные строки, на который указывает *ValuePtr* аргумент **SQLSetStmtAttr** длина *StringLength*.  
  
> [!NOTE]  
>  Возможность установки атрибутов инструкции на уровне соединения путем вызова **SQLSetConnectAttr** был объявлен устаревшим в ODBC 3*.x*. ODBC 3*.x* приложения никогда не следует устанавливать атрибуты инструкции на уровне соединения. ODBC 3*.x* на уровне соединения, за исключением SQL_ATTR_METADATA_ID и атрибуту SQL_ATTR_ASYNC_ENABLE атрибуты, которые атрибуты соединения и атрибуты инструкции и может быть невозможно задать атрибуты инструкции Задайте на уровне соединения или на уровне инструкции.  
  
> [!NOTE]  
>  ODBC 3*.x* драйверы должен поддерживать эту функциональность, только если они должны работать с ODBC 2*.x* приложения, значение ODBC 2*.x* параметров инструкции на уровне соединения. Дополнительные сведения см. в разделе «Параметр инструкции параметры на уровне соединения» в разделе [SQLSetConnectOption сопоставление](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) в приложении G: драйвер рекомендации для обеспечения обратной совместимости.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Атрибуты инструкции, задающие поля дескриптора  
 Многие инструкции атрибуты соответствуют поле заголовка дескриптора. Установка этих атрибутов фактически результаты в параметре поля дескриптора. Задание полей с помощью вызова **SQLSetStmtAttr** , а не к **SQLSetDescField** имеет преимущество, что дескриптор не должен получить для вызова функции.  
  
> [!CAUTION]  
>  Вызов **SQLSetStmtAttr** для одной инструкции может повлиять на другие инструкции. Это происходит, когда APD или Отменить, связанные с инструкцией явно выделяется, а также связан с другими инструкциями. Поскольку **SQLSetStmtAttr** изменяет APD или Отменить, изменения применяются ко всем операторам, с которыми связан данный дескриптор. Если это не необходимого поведения, приложение должно связь с этим дескриптором из других инструкций (путем вызова **SQLSetStmtAttr** требуется задать для поля SQL_ATTR_APP_ROW_DESC или SQL_ATTR_APP_PARAM_DESC на другой Дескриптор) перед вызовом **SQLSetStmtAttr** еще раз.  
  
 Если поле дескриптора в результате соответствующего атрибута инструкции значение поля устанавливается только для применимые дескрипторы, которые в настоящее время связан с указанной инструкцией *StatementHandle* аргумент и параметр атрибута не влияют на все дескрипторы, которые могут быть связаны с этой инструкции в будущем. Если задано поле дескриптора, который также является атрибут инструкции с помощью вызова **SQLSetDescField**, установите соответствующий атрибут оператора. Если явно выделенный дескриптор является связанным с инструкции, инструкция атрибут, который соответствует полю заголовка будет возвращено значение поля в дескрипторе неявно выделенный.  
  
 Когда выделена инструкция (см. [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), автоматически выделенных и связанные с инструкцией четыре дескриптора. Явно выделенного дескриптора может быть связан с инструкцией, вызвав **SQLAllocHandle** с *fHandleType* из SQL_HANDLE_DESC для выделения дескриптора и затем вызова  **SQLSetStmtAttr** для присоединения к ним дескриптора инструкции.  
  
 Атрибуты инструкции в следующей таблице соответствуют поля заголовка дескриптора.  
  
|Атрибут инструкции|Поле заголовка|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ОТМЕНИТЬ|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ОТМЕНИТЬ|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ОТМЕНИТЬ|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ОТМЕНИТЬ|  
|ЗНАЧЕНИЯ SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Атрибуты инструкции  
 В настоящее время определены атрибуты и используемая версия ODBC, в котором они были введены показаны в следующей таблице; Ожидается, что дополнительные атрибуты определены драйверы, чтобы воспользоваться преимуществами различных источников данных. Диапазон атрибутов зарезервирован ODBC. Разработчики необходимо зарезервировать значения для собственных нужд конкретного драйвера из Open Group. Дополнительные сведения см. в разделе [типов данных драйвера, дескрипторов типов, типов данных, типы диагностики и атрибуты](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attribute|*ValuePtr* содержимое|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Дескриптор APD для последующих вызовов **SQLExecute** и **SQLExecDirect** для дескриптора инструкции. Начальное значение этого атрибута является дескриптором, неявно выделена при инструкция изначально был выделен. Если значение этого атрибута равно SQL_NULL_DESC или дескриптор, исходно выделенного для дескриптора, явно выделенный дескриптор APD, который был ранее связан с дескриптором инструкции, отделена от него, и происходит возврат дескриптора инструкции неявно выделена в APD дескриптор.<br /><br /> Этот атрибут нельзя присвоить дескриптор окна, выделенная для другой инструкции неявно или другого дескриптора, явно установленного на одной и той же инструкции; неявно выделенного дескриптора не может быть связан с более чем одной инструкции или дескриптора.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Дескриптор Отменить для последующих выборках для дескриптора инструкции. Начальное значение этого атрибута является дескриптором, неявно выделена при инструкция изначально был выделен. Если значение этого атрибута равно SQL_NULL_DESC или дескриптор, исходно выделенного для дескриптора, явно выделенный дескриптор Отменить, который был ранее связан с дескриптором инструкции, отделена от него, и происходит возврат дескриптора инструкции неявно выделена Отменить маркер.<br /><br /> Этот атрибут нельзя присвоить дескриптор окна, выделенная для другой инструкции неявно или другого дескриптора, явно установленного на одной и той же инструкции; неявно выделенного дескриптора не может быть связан с более чем одной инструкции или дескриптора.|  
|АТРИБУТУ SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|SQLULEN значение, указывающее, является ли функция вызвана с указанной инструкцией выполняется асинхронно.<br /><br /> SQL_ASYNC_ENABLE_OFF = поддержку уровня асинхронное выполнение инструкции Disable (по умолчанию).<br /><br /> SQL_ASYNC_ENABLE_ON = включить поддержку уровня асинхронное выполнение инструкции.<br /><br /> Дополнительные сведения см. в разделе [асинхронное выполнение (метод опроса)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Для драйверов с поддержкой уровня асинхронное выполнение инструкции атрибут инструкции атрибуту SQL_ATTR_ASYNC_ENABLE только для чтения. Его значение является таким же, как значение атрибута уровня соединение с тем же именем во время был выделен с дескриптором инструкции.<br /><br /> Вызов **SQLSetStmtAttr** чтобы выставить атрибуту SQL_ATTR_ASYNC_ENABLE при SQL_ASYNC_MODE *свойство* возвращает SQL_AM_CONNECTION возвращает SQLSTATE HYC00 (дополнительная возможность не реализована). Дополнительные сведения см. в разделе [SQLSetConnectAttr, функция](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) для получения дополнительной информации.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Указатель SQLPOINTER значение, представляющее обработчик событий.<br /><br /> Уведомление о завершении асинхронной функций включена, вызвав **SQLSetStmtAttr** для задания **SQL_ATTR_ASYNC_STMT_EVENT** атрибута и укажите дескриптор события.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Указатель SQLPOINTER функция асинхронного обратного вызова.<br /><br /> Только диспетчер драйверов можно вызвать драйвер **SQLSetStmtAttr** функции с помощью этого атрибута.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Указатель SQLPOINTER структура контекста<br /><br /> Только диспетчер драйверов можно вызвать драйвер **SQLSetStmtAttr** функции с помощью этого атрибута.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|SQLULEN значение, которое указывает параллелизм курсоров:<br /><br /> SQL_CONCUR_READ_ONLY = курсор доступен только для чтения. Обновления не разрешены.<br /><br /> SQL_CONCUR_LOCK = курсор использует самый низкий уровень блокировки достаточно, чтобы убедиться, что строки могут быть обновлены.<br /><br /> SQL_CONCUR_ROWVER = курсор использует управление оптимистичным параллелизмом, сравнение версии строк, такие как программа ROWID или Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = курсор использует управление оптимистичным параллелизмом, сравнения значений.<br /><br /> Значение по умолчанию для SQL_ATTR_CONCURRENCY — SQL_CONCUR_READ_ONLY.<br /><br /> Этот атрибут не указан для открытого курсора. Дополнительные сведения см. в разделе [типы параллелизма](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Если SQL_ATTR_CURSOR_TYPE *атрибута* изменяется для типов, которые не поддерживают текущее значение SQL_ATTR_CONCURRENCY, значение SQL_ATTR_CONCURRENCY будет изменен во время выполнения и если выдано предупреждение **SQLExecDirect** или **SQLPrepare** вызывается.<br /><br /> Если драйвер поддерживает **SELECT FOR UPDATE** инструкции и такой оператор выполняется, когда значение SQL_ATTR_CONCURRENCY равно SQL_CONCUR_READ_ONLY, будет возвращена ошибка. Если значение SQL_ATTR_CONCURRENCY изменяется значение, драйвер поддерживает некоторые значения SQL_ATTR_CURSOR_TYPE, но не для текущего значения SQL_ATTR_CURSOR_TYPE, значение SQL_ATTR_CURSOR_TYPE изменится во время выполнения и SQLSTATE 01S02 (Значение параметра изменено) выдается **SQLExecDirect** или **SQLPrepare** вызывается.<br /><br /> Если указанный параллелизма не поддерживается источником данных, драйвер заменяет другой параллелизма и возвращает SQLSTATE 01S02 (значение параметра изменено). Для SQL_CONCUR_VALUES, драйвер подставляет вместо SQL_CONCUR_ROWVER и наоборот. Для SQL_CONCUR_LOCK драйвер подставляет в порядке, SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES. Допустимость подставляемого значения не проверяется только во время выполнения.<br /><br /> Дополнительные сведения об отношениях между SQL_ATTR_CONCURRENCY и другие атрибуты курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|SQLULEN значение, которое указывает уровень поддержки, который требуется приложению. Установка этого атрибута влияет на последующие вызовы **SQLExecDirect** и **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = возможна прокрутка курсоры не требуются для дескриптора инструкции. Если приложение вызывает **SQLFetchScroll** этого дескриптора, единственным допустимым значением для *FetchOrientation* — SQL_FETCH_NEXT. Это значение по умолчанию.<br /><br /> SQL_SCROLLABLE = возможна прокрутка курсоров требуются для дескриптора инструкции. При вызове **SQLFetchScroll**, приложение может задать любое допустимое значение *FetchOrientation*, достижение позиционирования курсора в режимах, отличных от последовательный режим.<br /><br /> Дополнительные сведения о Прокручиваемые курсоры см. в разделе [Прокручиваемые курсоры](../../../odbc/reference/develop-app/scrollable-cursors.md). Дополнительные сведения об отношениях между SQL_ATTR_CURSOR_SCROLLABLE и другие атрибуты курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|SQLULEN, указывает ли курсоры для дескриптора инструкции сделать видимым изменения, внесенные в результирующий набор с другим курсором. Установка этого атрибута влияет на последующие вызовы **SQLExecDirect** и **SQLExecute**. Приложение может выполнить чтение обратно значение этого атрибута, чтобы получить исходное состояние или его состояние как наиболее недавно установленные приложением.<br /><br /> SQL_UNSPECIFIED = не указан тип курсора является и ли курсоры для дескриптора инструкции сделать видимым изменения, внесенные в результирующий набор другого курсора. Курсоры для дескриптора инструкции может сделать видимым ни один, несколько или все такие изменения. Это значение по умолчанию.<br /><br /> SQL_INSENSITIVE = все курсоры на показ дескриптор инструкции, результирующий набор без отражения изменения, внесенные с любого другого курсора. Нечувствительных курсоров доступны только для чтения. Это соответствует статический курсор, который имеет параллелизма, которая доступна только для чтения.<br /><br /> SQL_SENSITIVE = все курсоры в инструкции дескриптор сделать видимыми все изменения, внесенные в результирующий набор с другим курсором.<br /><br /> Дополнительные сведения об отношениях между SQL_ATTR_CURSOR_SENSITIVITY и другие атрибуты курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|SQLULEN значение, которое указывает тип курсора:<br /><br /> SQL_CURSOR_FORWARD_ONLY = курсор только прокручивается вперед.<br /><br /> SQL_CURSOR_STATIC = данные в результирующем наборе является статическим.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = сохраняет драйвера и ключи используются для числа строк, указанное в атрибуте атрибута SQL_ATTR_KEYSET_SIZE инструкции.<br /><br /> SQL_CURSOR_DYNAMIC = драйвер сохраняет и использует только ключи для строк в наборе строк.<br /><br /> Значение по умолчанию — SQL_CURSOR_FORWARD_ONLY. Этот атрибут не указан, после подготовки инструкции SQL.<br /><br /> Если тип указанного курсора не поддерживается источником данных, драйвер заменяет другой тип курсора и возвращает SQLSTATE 01S02 (значение параметра изменено). Для смешанного или динамический курсор драйвер подставляет в порядке, управляемые набором ключей или статических курсоров. Для курсора, управляемого набором ключей драйвер подставляет вместо статического курсора.<br /><br /> Дополнительные сведения о типах прокручиваемого курсора см. в разделе [Прокручиваемый курсор типы](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Дополнительные сведения об отношениях между SQL_ATTR_CURSOR_TYPE и другие атрибуты курсора см. в разделе [характеристики курсора и тип курсора](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|SQLULEN значение, которое указывает, выполняется ли автоматическое заполнение IPD:<br /><br /> SQL_TRUE = Включение на автоматическое заполнение IPD после вызова **SQLPrepare**. Значение SQL_FALSE = отключает выключено автоматическое заполнение IPD после вызова **SQLPrepare**. (Приложение по-прежнему может получить сведения о полях IPD путем вызова **SQLDescribeParam**, если поддерживается.) Значение по умолчанию атрибута инструкции SQL_ATTR_ENABLE_AUTO_IPD — SQL_FALSE. Дополнительные сведения см. в разделе [автоматическое заполнение IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|SQLLEN \* , указывающий значение двоичного закладки. Когда **SQLFetchScroll** вызывается с *fFetchOrientation* равно SQL_FETCH_BOOKMARK, драйвер принимает значение из этого поля. По умолчанию это поле является пустым указателем. Дополнительные сведения см. в разделе [прокрутка по закладке](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Значение, указанное в этом поле не используется для удаления по закладке, обновление по закладке или fetch операциями закладки в **SQLBulkOperations**, который с помощью закладок, кэшированных в буферы строк.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Дескриптор IPD. Значение этого атрибута является дескриптором, выделяемый при инструкция изначально был выделен. Приложение не может задать этот атрибут.<br /><br /> Этот атрибут можно получить путем вызова **SQLGetStmtAttr** , но не задано с помощью вызова **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Дескриптор IRD. Значение этого атрибута является дескриптором, выделяемый при инструкция изначально был выделен. Приложение не может задать этот атрибут.<br /><br /> Этот атрибут можно получить путем вызова **SQLGetStmtAttr** , но не задано с помощью вызова **SQLSetStmtAttr**.|  
|АТРИБУТА SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Значение SQLULEN, указывающее количество строк в наборе ключей для курсора, управляемого набором ключей. Если размер набора ключей равно 0 (по умолчанию), курсор полностью управляемые набором ключей. Если размер набора ключей больше 0, курсор смешанной (управляемые набором ключей в наборе ключей и динамические вне набора ключей). Размер набора ключей по умолчанию — 0. Дополнительные сведения о управляемые набором ключей курсоры в разделе [управляемые набором ключей курсоры](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Если указанный размер превышает размер максимального набора ключей, драйвер заменяет такого размера и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> **SQLFetch** или **SQLFetchScroll** возвращает ошибку, если размер набора ключей больше 0 и меньше, чем размер набора строк.|  
|ЗНАЧЕНИЯ SQL_ATTR_MAX_LENGTH (ODBC 1.0)|SQLULEN значение, которое указывает максимальный объем данных, драйвер возвращает из символов или двоичных столбцов. Если *ValuePtr* меньше, чем длина доступных данных **SQLFetch** или **SQLGetData** усечение данных и возвращает значение SQL_SUCCESS. Если *ValuePtr* равно 0 (по умолчанию), драйвер пытается вернуть все доступные данные.<br /><br /> Если указанная длина меньше, чем минимальный объем данных, которые могут возвращаться в источнике данных или больше, чем максимальный объем данных, которые может вернуть источника данных, заменяет драйвер, и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> Значение этого атрибута можно задать на открытый курсор; Тем не менее, параметр может не вступают в силу немедленно, в этом случае драйвер вернет SQLSTATE 01S02 (значение параметра изменено) и сбросить в исходное значение атрибута.<br /><br /> Этот атрибут предназначен для снижения сетевого трафика и должны поддерживаться только в том случае, если источник данных (в отличие от драйвера) в драйвере многоуровневого его реализации. Этот механизм должен не использоваться приложениями для усечения данных. усечение данных, полученных, приложение должно указать Максимальная длина буфера в *BufferLength* аргумент в **SQLBindCol** или **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|SQLULEN значение, соответствующее максимальное число строк, возвращаемых в приложение для **ВЫБЕРИТЕ** инструкции. Если \* *ValuePtr* равен 0 (по умолчанию), драйвер возвращает все строки.<br /><br /> Этот атрибут предназначен для снижения сетевого трафика. По существу, он применяется, когда результирующий набор создан и ограничивает результирующий набор с первым *ValuePtr* строк. Если количество строк в результирующем наборе больше, чем *ValuePtr*, результирующий набор будет усечен.<br /><br /> SQL_ATTR_MAX_ROWS применяется для всех результирующих наборов на *инструкции*, включая те, возвращаемые функциями каталога. SQL_ATTR_MAX_ROWS устанавливает максимальное значение количества строк курсора.<br /><br /> Драйвер не должен эмулирует поведение SQL_ATTR_MAX_ROWS для **SQLFetch** или **SQLFetchScroll** (если ограничения размера результирующего набора не может быть реализован в источнике данных), если он не может гарантировать, что SQL_ATTR_ MAX_ROWS будет реализован должным образом.<br /><br /> Это определяемые драйвером от того, применяется ли SQL_ATTR_MAX_ROWS операторам, кроме инструкций SELECT (например, функции работы с каталогами).<br /><br /> Значение этого атрибута можно задать на открытый курсор; Тем не менее, параметр может не вступают в силу немедленно, в этом случае драйвер вернет SQLSTATE 01S02 (значение параметра изменено) и сбросить в исходное значение атрибута.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|SQLULEN значение, которое определяет, как обрабатываются строковые аргументы функций работы с каталогами.<br /><br /> Если SQL_TRUE, строковый аргумент функции работы с каталогами, интерпретируются как идентификаторы. Регистр не имеет значения. Для nondelimited строк драйвер удаляет пробелы и строка складывается в верхний регистр. Для строки с разделителями драйвер удаляет все начальные и конечные пробелы и принимает любой между разделителями буквально. Если один из этих аргументов имеет значение является пустым указателем, функция возвращает значение SQL_ERROR и SQLSTATE HY009 (недопустимое использование пустого указателя).<br /><br /> Если значение SQL_FALSE, что строковые аргументы функций каталога не интерпретируются как идентификаторы. Регистр имеет значение. Они могут содержать либо строку шаблона поиска или нет, в зависимости от аргумента.<br /><br /> Значение по умолчанию — SQL_FALSE.<br /><br /> *TableType* аргумент **SQLTables**, который принимает несколько значений, не зависит от этого атрибута.<br /><br /> SQL_ATTR_METADATA_ID можно также задать на уровне соединения. (Он и атрибуту SQL_ATTR_ASYNC_ENABLE являются атрибуты только инструкции, которые также имеются атрибуты соединения).<br /><br /> Дополнительные сведения см. в разделе [аргументов функций каталога](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|SQLULEN значение, которое указывает, должно ли драйвер проверять строки SQL для escape-последовательностей:<br /><br /> SQL_NOSCAN_OFF = драйвер просмотров строки SQL для escape-последовательности (по умолчанию).<br /><br /> SQL_NOSCAN_ON = драйвер не проверяет строки SQL для escape-последовательности. Вместо этого драйвер отправляет инструкцию непосредственно к источнику данных.<br /><br /> Дополнительные сведения см. в разделе [Escape-последовательности ODBC в](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|SQLULEN * значение, которое указывает смещение добавлены указатели для изменения привязки динамических параметров. Если это поле не равно null, драйвер разыменовывает указатель, добавляет разыменованное значение к каждому из отложенных полей в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) и использует новые значения указателя При привязке. Он устанавливается в значение null по умолчанию.<br /><br /> Смещение привязки всегда добавляется непосредственно поля SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR. Если смещение изменяется с другим значением, новое значение все равно добавляется непосредственно на значение в поле дескриптора. Новое смещение в значении поля, а также любые ранее смещения не добавляется.<br /><br /> Дополнительные сведения см. в разделе [параметр привязки смещает](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_BIND_OFFSET_PTR поля в заголовке APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|SQLULEN значение, которое указывает ориентацию привязки для использования динамических параметров.<br /><br /> Это поле будет присвоено значение SQL_PARAM_BIND_BY_COLUMN (по умолчанию), установите привязку по столбцам.<br /><br /> Чтобы выбрать привязку на уровне строки, это поле имеет значение длины структуры или экземпляра буфера, который будет привязан к набору динамических параметров. Эта длина должна включать пространство для всех связанных параметров и все заполнения структуры или буфера, чтобы убедиться, результат адрес связанного параметра увеличивается с указанной длины, будет указывать на начало того же параметра в следующем набор параметров. При использовании *sizeof* оператор в ANSI C, такое поведение гарантируется.<br /><br /> Дополнительные сведения см. в разделе [привязка массивов параметров](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_ BIND_TYPE поля в заголовке APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|SQLUSMALLINT \* использовать значение, которое указывает на массив значений SQLUSMALLINT для пропуска параметра во время выполнения инструкции SQL. Каждое значение будет присвоено SQL_PARAM_PROCEED (для параметра для выполнения) или SQL_PARAM_IGNORE (для параметра пропускаются).<br /><br /> Набор параметров может игнорироваться во время обработки, задав значение состояния в массиве, на который указывает SQL_DESC_ARRAY_STATUS_PTR в APD для SQL_PARAM_IGNORE. Набор параметров обрабатывается, если его состояние имеет значение SQL_PARAM_PROCEED или если ни один элемент в массиве.<br /><br /> Этот атрибут инструкции может быть присвоено указателем null, в котором случае драйвер не возвращает параметр значения состояния. Этот атрибут можно установить в любое время, но новое значение не используется до следующего **SQLExecDirect** или **SQLExecute** вызывается.<br /><br /> Этот атрибут игнорируется при отсутствии связанного параметра.<br /><br /> Дополнительные сведения см. в разделе [использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_ARRAY_STATUS_PTR поля в заголовке APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|SQLUSMALLINT \* значение, которое указывает на массив SQLUSMALLINT значений, содержащий сведения о состоянии для каждой строки значения параметров после вызова **SQLExecute** или **SQLExecDirect**. Это поле является обязательным только в том случае, если PARAMSET_SIZE больше 1.<br /><br /> Значения состояния может содержать следующие значения:<br /><br /> SQL_PARAM_SUCCESS: Инструкция SQL успешно выполнена для текущего набора параметров.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: Инструкция SQL была выполнена успешно для данного набора параметров. Тем не менее сведения о предупреждении доступен в структуре данных диагностики.<br /><br /> SQL_PARAM_ERROR: Произошла ошибка при обработке этот набор параметров. Дополнительные сведения об ошибке доступен в структуре данных диагностики.<br /><br /> SQL_PARAM_UNUSED: Этот набор параметров был неиспользуемые, возможно из-за того, что некоторые предыдущие набор параметров вызвала ошибку, что прервана дальнейшей обработки или SQL_PARAM_IGNORE было установлено для этого набора параметров массива, заданного параметром SQL_ATTR_PARAM_ OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Драйвер обрабатывает массивы параметров как единое монолитные и поэтому не создает этот уровень сведений об ошибках.<br /><br /> Этот атрибут инструкции может быть присвоено указателем null, в котором случае драйвер не возвращает параметр значения состояния. Этот атрибут можно установить в любое время, но новое значение не используется до следующего **SQLExecute** или **SQLExecDirect** вызывается. Обратите внимание, что установка этого атрибута могут повлиять на поведение параметра output, реализованным в драйвере.<br /><br /> Дополнительные сведения см. в разделе [использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_ARRAY_STATUS_PTR поля в заголовке IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|SQLULEN \* поле записи, которая указывает на буфер, в которую возвращается число наборов параметров, которые были обработаны, включая наборы ошибки. Число не будут возвращены, если это пустой указатель.<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_ROWS_PROCESSED_PTR поля в заголовке IPD.<br /><br /> Если вызов **SQLExecDirect** или **SQLExecute** заливки в буфере, на который указывает этот атрибут не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.<br /><br /> Дополнительные сведения см. в разделе [использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|SQLULEN значение, которое указывает количество значений для каждого параметра. Если SQL_ATTR_PARAMSET_SIZE больше 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR в APD точки к массивам. Количество элементов в каждом массиве равно значению этого поля.<br /><br /> Этот атрибут игнорируется при отсутствии связанного параметра.<br /><br /> Дополнительные сведения см. в разделе [использование массивов параметров](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_SIZE в заголовке APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Значение SQLULEN, соответствующее количество секунд ожидания инструкции SQL для выполнения перед возвратом к приложению. Если *ValuePtr* будет равно 0 (по умолчанию), что таймаут не используется.<br /><br /> Если заданное время ожидания превышает максимальное время ожидания в источнике данных или меньше, чем минимальное время ожидания, **SQLSetStmtAttr** заменяет это значение и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> Обратите внимание, что приложение не нужно вызывать **SQLCloseCursor** для повторного использования инструкции, если **ВЫБЕРИТЕ** инструкции истекло время ожидания.<br /><br /> Время ожидания запроса, заданное в этом атрибуте инструкции является допустимым в синхронный и асинхронный режимы.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Значение типа SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** и в ODBC 3*.x*, **SQLFetch** получения данных после его помещает курсор в указанное расположение. Это значение по умолчанию.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** и в ODBC 3*.x*, **SQLFetch** не извлекают данные после его помещает курсор.<br /><br /> Установив SQL_RETRIEVE_DATA SQL_RD_OFF, приложение можно проверить, существует или получить закладка для строки без несения издержек по извлечение строк строки. Дополнительные сведения см. в разделе [прокрутка и выборка строки](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Значение этого атрибута можно задать на открытый курсор; Тем не менее, параметр может не вступают в силу немедленно, в этом случае драйвер вернет SQLSTATE 01S02 (значение параметра изменено) и сбросить в исходное значение атрибута.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Значение SQLULEN, которое указывает число строк, возвращаемых при каждом вызове **SQLFetch** или **SQLFetchScroll**. Это число строк в массиве закладки, используемых в операциях массового закладки в **SQLBulkOperations**. Значение по умолчанию равно 1.<br /><br /> Если размер указанного набора строк превышает размер максимального набора строк, который поддерживается источником данных, драйвер заменяет это значение и возвращает SQLSTATE 01S02 (значение параметра изменено).<br /><br /> Дополнительные сведения см. в разделе [размер набора строк](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_SIZE в заголовке Отменить.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|SQLULEN * значение, которое указывает смещение добавлены указатели, чтобы изменить привязку данных столбца. Если это поле не равно null, драйвер разыменовывает указатель, добавляет разыменованное значение к каждому из отложенных полей в записи дескриптора (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR) и использует новые значения указателя При привязке. Он устанавливается в значение null по умолчанию.<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_BIND_OFFSET_PTR поля в заголовке Отменить.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Значение SQLULEN, которое задает ориентацию привязки для использования при **SQLFetch** или **SQLFetchScroll** будет вызван на связанный с ним оператор. Привязка на уровне столбца выбран, задав значение, равное SQL_BIND_BY_COLUMN. Привязка на уровне строки выбирается, задав значение длины структуры или экземпляра буфера, в который будет привязан результирующих столбцов.<br /><br /> Если указана длина, она должна включать пространство для всех связанных столбцов и заполнения структуры или буфера, убедитесь, что если адрес связанного столбца увеличивается с указанной длины, результат будет указывают на начало того же столбца в th e следующую строку. При использовании **sizeof** оператор с структур или объединений в ANSI C, такое поведение гарантируется.<br /><br /> Привязка на уровне столбца является направление привязки по умолчанию для **SQLFetch** и **SQLFetchScroll**.<br /><br /> Дополнительные сведения см. в разделе [привязки столбцов для использования с блочными курсорами](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_BIND_TYPE поля в заголовке Отменить.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|SQLULEN, номер текущей строки в весь результирующий набор. Если невозможно определить номер текущей строки или нет текущей строки, драйвер возвращает 0.<br /><br /> Этот атрибут можно получить путем вызова **SQLGetStmtAttr** , но не задано с помощью вызова **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|SQLUSMALLINT \* позволяет пропускать строки во время массовой операции, используя значение, которое указывает на массив значений SQLUSMALLINT **SQLSetPos**. Каждое значение будет присвоено SQL_ROW_PROCEED (для строки, которые будут включены в операции массового) или SQL_ROW_IGNORE (для строк, которые должны быть исключены из операции массовой). (Нельзя пропустить строк с помощью массива во время вызовов **SQLBulkOperations**.)<br /><br /> Этот атрибут инструкции может быть присвоено указателем null, в котором случае драйвер не возвращает значения строки состояния. Этот атрибут можно установить в любое время, но новое значение не используется до следующего **SQLSetPos** вызывается.<br /><br /> Дополнительные сведения см. в разделе [обновление строк в наборе строк с SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) и [удаление строк в наборе строк с SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Установка этого атрибута инструкция задает поле SQL_DESC_ARRAY_STATUS_PTR Отменить.|  
|ЗНАЧЕНИЯ SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|SQLUSMALLINT \* значение, которое указывает на массив SQLUSMALLINT значения содержащий значения строки состояния после вызова **SQLFetch** или **SQLFetchScroll**. Массив имеет столько же элементов как строк в наборе строк.<br /><br /> Этот атрибут инструкции может быть присвоено указателем null, в котором случае драйвер не возвращает значения строки состояния. Этот атрибут можно установить в любое время, но новое значение не используется до следующего **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, или  **SQLSetPos** вызывается.<br /><br /> Дополнительные сведения см. в разделе [номер строки выбраны и состояние](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_ARRAY_STATUS_PTR поля в заголовке IRD.<br /><br /> Этот атрибут сопоставляется с ODBC 2*.x* драйвер *rgbRowStatus* массива в вызове **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|SQLULEN \* значение, которое указывает на буфер, в котором для возврата числа строк, возвращаемых после вызова **SQLFetch** или **SQLFetchScroll**; количество строк, затронутых при массовой операции с помощью вызова **SQLSetPos** с *операции* аргумент SQL_REFRESH; или количество строк, затронутых при массовой операции, выполняемые **SQLBulkOperations**. В том числе строк с ошибками.<br /><br /> Дополнительные сведения см. в разделе [номер строки выбраны и состояние](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Установка этого атрибута инструкции устанавливает SQL_DESC_ROWS_PROCESSED_PTR поля в заголовке IRD.<br /><br /> Если вызов **SQLFetch** или **SQLFetchScroll** заливки в буфере, на который указывает этот атрибут не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, содержимое буфера не определено.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Значение SQLULEN, которое указывает, является ли драйверы, которые имитируют располагается инструкции update и delete гарантирует таких затрагивают только одну строку.<br /><br /> Для имитации позиционированного обновления и удаления инструкций, большинство драйверов создания поисковое **обновление** или **удаление** инструкция **ГДЕ** предложение, определяющее, значение для каждого столбца в текущей строке. Если эти столбцы составляющих уникальный ключ, такой оператор может повлиять на более чем одной строке.<br /><br /> Чтобы гарантировать, что такие инструкции касаются только одну строку, драйвер определяет, какие столбцы уникального ключа и добавляет эти столбцы в результирующем наборе. Если приложение гарантирует, что столбцы в результирующем наборе составляют уникальный ключ, драйвер не требуется делать это. Это может снизить время выполнения.<br /><br /> SQL_SC_NON_UNIQUE = драйвер не гарантируется, что имитируемые расположен обновления или инструкций delete повлияет только одну строку; приложение несет сделать это. Если инструкция влияет на более чем одной строке **SQLExecute**, **SQLExecDirect**, или **SQLSetPos** возвращает SQLSTATE 01001 (конфликт операции курсора).<br /><br /> SQL_SC_TRY_UNIQUE = драйвер попыток для обеспечения имитируемые располагается обновления или удаления инструкций влияет только одну строку. Драйвер всегда такие операторы выполняются, даже если они могут повлиять на более чем одной строке, например, если отсутствует уникальный ключ. Если инструкция влияет на более чем одной строке **SQLExecute**, **SQLExecDirect**, или **SQLSetPos** возвращает SQLSTATE 01001 (конфликт операции курсора).<br /><br /> SQL_SC_UNIQUE = драйвер гарантии, которые имитируемые позиционированного обновления или удаления инструкций влияет только одну строку. Если драйвер не может гарантировать это для заданной инструкции **SQLExecDirect** или **SQLPrepare** возвращает сообщение об ошибке.<br /><br /> Если источник данных предоставляет собственный SQL поддерживает позиционированные обновления для инструкций и удалять драйвер не имитации курсоров, SQL_SUCCESS возвращается при запросе SQL_SC_UNIQUE для SQL_SIMULATE_CURSOR. Если запрашивается SQL_SC_TRY_UNIQUE или SQL_SC_NON_UNIQUE возвращается SQL_SUCCESS_WITH_INFO. Если источник данных предоставляет SQL_SC_TRY_UNIQUE уровень поддержки, драйвер не поддерживает SQL_SUCCESS возвращается для SQL_SC_TRY_UNIQUE и SQL_SUCCESS_WITH_INFO, возвращается для SQL_SC_NON_UNIQUE.<br /><br /> Если тип моделирования указанного курсора не поддерживается источником данных, драйвер заменяет тип различных моделирования и возвращает SQLSTATE 01S02 (значение параметра изменено). Для SQL_SC_UNIQUE драйвер подставляет в порядке, SQL_SC_TRY_UNIQUE или SQL_SC_NON_UNIQUE. Для SQL_SC_TRY_UNIQUE драйвер подставляет вместо SQL_SC_NON_UNIQUE.<br /><br /> Значение по умолчанию — SQL_SC_UNIQUE.<br /><br /> Дополнительные сведения см. в разделе [имитация располагается обновление и удаление операторов](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|SQLULEN значение, которое указывает, использует ли приложение закладки с курсором:<br /><br /> SQL_UB_OFF = Off (по умолчанию)<br /><br /> SQL_UB_VARIABLE = приложение будет использовать закладки с курсором и драйвер предоставит закладки переменной длины, если они поддерживаются. В ODBC 3 устарел SQL_UB_FIXED*.x*. ODBC 3*.x* приложения всегда должны использовать закладки переменной длины, даже в том случае, если работа с ODBC 2*.x* драйверы (что поддерживается только 4 байта, фиксированной длины закладки). Это, поскольку закладки фиксированной длины в особых случаях закладки переменной длины. При работе с ODBC 2*.x* драйвера, диспетчер драйверов сопоставляется SQL_UB_VARIABLE SQL_UB_FIXED.<br /><br /> Чтобы к закладкам с курсором, приложение должно указать этот атрибут со значением SQL_UB_VARIABLE перед открытием курсора.<br /><br /> Дополнительные сведения см. в разделе [получение закладки](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] Эти функции могут вызываться асинхронно только в том случае, если дескриптор является дескриптор реализации не дескриптор приложения.  
  
 В разделе [привязки на уровне столбца](../../../odbc/reference/develop-app/column-wise-binding.md) и [привязка](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Возврат значения атрибута соединения|[Функция SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Возврат значения атрибута инструкции|[Функция SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Присвоение атрибуту соединения|[Функция SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Настройка одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
