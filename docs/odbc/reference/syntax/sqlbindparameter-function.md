---
title: Функция SQLBindParameter | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
apiname:
- SQLBindParameter
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLBindParameter
helpviewer_keywords:
- SQLBindParameter function [ODBC]
ms.assetid: 38349d4b-be03-46f9-9d6a-e50dd144e225
caps.latest.revision: 52
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: On Demand
ms.openlocfilehash: 299e4ced3e6047f7d3e205d384d3191d43e70ef1
ms.sourcegitcommit: cc71f1027884462c359effb898390c8d97eaa414
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="sqlbindparameter-function"></a>Функция SQLBindParameter
**Соответствия**  
 Появился в версии: ODBC 2.0 нормативных требований: ODBC  
  
 **Сводка**  
 **SQLBindParameter** привязывает буфера к маркеру параметра в инструкции SQL. **SQLBindParameter** поддерживает привязку к типу данных Юникода C, даже если основной драйвер не поддерживает данные в Юникоде.  
  
> [!NOTE]  
>  Эта функция заменяет функцию ODBC 1.0 **SQLSetParam**. Дополнительные сведения см. в разделе «Комментарии».  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLBindParameter(  
      SQLHSTMT        StatementHandle,  
      SQLUSMALLINT    ParameterNumber,  
      SQLSMALLINT     InputOutputType,  
      SQLSMALLINT     ValueType,  
      SQLSMALLINT     ParameterType,  
      SQLULEN         ColumnSize,  
      SQLSMALLINT     DecimalDigits,  
      SQLPOINTER      ParameterValuePtr,  
      SQLLEN          BufferLength,  
      SQLLEN *        StrLen_or_IndPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *ParameterNumber*  
 [Вход] Номер параметра упорядоченный последовательно в порядке возрастания параметра, начиная с 1.  
  
 *InputOutputType*  
 [Вход] Тип параметра. Дополнительные сведения см. в разделе «*InputOutputType* аргумент» в «Комментарии».  
  
 *ValueType*  
 [Вход] Тип данных C параметра. Дополнительные сведения см. в разделе «*ValueType* аргумент» в «Комментарии».  
  
 *ParameterType*  
 [Вход] Тип данных параметра SQL. Дополнительные сведения см. в разделе «*ParameterType* аргумент» в «Комментарии».  
  
 *ColumnSize*  
 [Вход] Размер столбца и выражения соответствующего маркера параметра. Дополнительные сведения см. в разделе «*ColumnSize* аргумент» в «Комментарии».  
  
 Если приложение будет выполняться в 64-разрядной операционной системе Windows, см. раздел [сведения ODBC 64-разрядных](../../../odbc/reference/odbc-64-bit-information.md).  
  
 *DecimalDigits*  
 [Вход] Десятичные цифры из столбца и выражения соответствующего маркера параметра. Дополнительные сведения о размере столбца см. в разделе [размер столбца, десятичных цифр, длина в октетах передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md).  
  
 *ParameterValuePtr*  
 [Отложенные входные данные] Указатель на буфер данных параметра. Дополнительные сведения см. в разделе «*ParameterValuePtr* аргумент» в «Комментарии».  
  
 *BufferLength*  
 [Вход/выход] Длина *ParameterValuePtr* буфера в байтах. Дополнительные сведения см. в разделе «*BufferLength* аргумент» в «Комментарии».  
  
 В разделе [сведения ODBC 64-разрядных](../../../odbc/reference/odbc-64-bit-information.md), если приложение будет выполняться на 64-разрядной операционной системе.  
  
 *StrLen_or_IndPtr*  
 [Отложенные входные данные] Указатель на буфер, длина параметра. Дополнительные сведения см. в разделе «*StrLen_or_IndPtr* аргумент» в «Комментарии».  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLBindParameter** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из Значение SQL_HANDLE_STMT и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLBindParameter** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Тип данных, определенный *ValueType* не удается преобразовать аргумент в тип данных, определяемый *ParameterType* аргумент. Обратите внимание, что эта ошибка может быть возвращено **SQLExecDirect**, **SQLExecute**, или **SQLPutData** во время выполнения, а не по **SQLBindParameter**.|  
|07009|Недопустимый индекс дескриптора|(DM) значение, указанное для аргумента *ParameterNumber* был меньше 1.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в **MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйвер не удалось выделить память, который необходим для поддержки выполнения или завершения функции.|  
|HY003 И СООБЩЕНИЕМ|Недопустимый тип буфера приложения|Значение, указанное в аргументе *ValueType* не допустимый тип данных C или SQL_C_DEFAULT.|  
|HY004|Недопустимый тип данных SQL|Значение, указанное для аргумента *ParameterType* была не является допустимым идентификатором типа данных ODBC SQL, и не специфические для драйвера SQL идентификатора типа данных поддерживается драйвером.|  
|HY009|Недопустимое значение аргумента|(DM) аргумент *ParameterValuePtr* является пустым указателем, аргумент *StrLen_or_IndPtr* был пустым указателем, а аргумент *InputOutputType* не SQL_PARAM_ ВЫХОДНЫЕ ДАННЫЕ.<br /><br /> SQL_PARAM_OUTPUT (DM), где аргумент *ParameterValuePtr* является пустым указателем, тип C была char или двоичное кодирование и BufferLength (*cbValueMax*) был больше 0.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом асинхронной функция **SQLBindParameter** был вызван.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для *StatementHandle* и возвращается SQL_PARAM_DATA_ ЭТОТ ПАРАМЕТР ДОСТУПЕН. До получения данных для всех параметров потоковой вызове этой функции.<br /><br /> (DM) был вызван асинхронно выполняемой функции для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY021|Неправильные сведения о дескрипторе|Сведения о дескрипторе, проверяется в ходе проверки согласованности не было идентичным. (См. в разделе «Проверка согласованности» в **SQLSetDescField**.)<br /><br /> Значение, указанное для аргумента *DecimalDigits* вне пределов диапазона значений, поддерживаемых источником данных для столбца типа данных SQL, определяемое *ParameterType* аргумент.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение в *BufferLength* был меньше 0. (См. в описании поля SQL_DESC_DATA_PTR в **SQLSetDescField**.)|  
|HY104|Недопустимое значение точности или масштаба|Значение, указанное для аргумента *ColumnSize* или *DecimalDigits* вне пределов диапазона значений, поддерживаемых источником данных для столбца типа данных SQL, определяемое  *ParameterType* аргумент.|  
|HY105|Недопустимый тип параметра|(DM) значение, указанное для аргумента *InputOutputType* недопустим. (В разделе «Комментарии».)|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает преобразование, определяется сочетанием значения, указанного для аргумента *ValueType* и относящиеся к драйверу значения, указанного в аргументе *ParameterType*.<br /><br /> Значение, указанное для аргумента *ParameterType* был допустимым идентификатором типа данных ODBC SQL для версия используемого протокола ODBC, поддерживаемых драйвером, но не поддерживается драйвером или источником данных.<br /><br /> Драйвер поддерживает только ODBC 2. *x* и аргумента *ValueType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и все типы данных C интервал, перечисленных в [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) в типах данных приложение D:.<br /><br /> Драйвер поддерживает только ODBC версий, предшествующих 3,50 и аргумента *ValueType* был SQL_C_GUID.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
  
## <a name="comments"></a>Комментарии  
 Приложение вызывает **SQLBindParameter** для привязки каждого маркера параметра в инструкции SQL. Привязки остаются в силе, пока приложение не вызовет метод **SQLBindParameter** снова вызывает **SQLFreeStmt** с помощью параметра SQL_RESET_PARAMS или вызовы **SQLSetDescField** для поле заголовка SQL_DESC_COUNT APD равным 0.  
  
 Дополнительные сведения о параметрах см. в разделе [параметров инструкции](../../../odbc/reference/develop-app/statement-parameters.md). Дополнительные сведения о типах данных параметров и маркеров параметров см. в разделе [типы данных параметров](../../../odbc/reference/appendixes/parameter-data-types.md) и [маркеры параметров](../../../odbc/reference/appendixes/parameter-markers.md) в грамматику SQL приложение C:.  
  
## <a name="parameternumber-argument"></a>Аргумент ParameterNumber  
 Если *ParameterNumber* в вызове **SQLBindParameter** больше, чем значение SQL_DESC_COUNT, **SQLSetDescField** вызывается, чтобы увеличить значение SQL_DESC_ ЧИСЛО для *ParameterNumber*.  
  
## <a name="inputoutputtype-argument"></a>Аргумент InputOutputType  
 *InputOutputType* аргумент задает тип параметра. Этот аргумент задает поле SQL_DESC_PARAMETER_TYPE в IPD. Все параметры в инструкции SQL, которые не вызывают процедуры, такие как **вставить** инструкций, *ввода**параметры*. Параметры в вызове процедуры могут быть входными, ввода вывода или выходных параметров. (Приложение вызывает **SQLProcedureColumns** для определения типа параметра в вызове процедуры; предполагается, что параметры, тип которого невозможно определить находятся входных параметров.)  
  
 *InputOutputType* аргумент является одним из следующих значений:  
  
-   SQL_PARAM_INPUT. Параметр отмечает параметра в инструкции SQL, не вызывает процедуру, таких как **вставить** инструкции или он помечает входного параметра в процедуре. Например, параметры в **INSERT INTO сотрудника VALUES (?,?,?)**  являются входными параметрами, тогда как параметры в **{вызовите AddEmp (?,?,?)}**  может быть, но не обязательно, входные параметры.  
  
     При выполнении инструкции драйвер отправляет данные для параметра источника данных. \* *ParameterValuePtr* буфер должен содержать допустимое входное значение или **StrLen_or_IndPtr* буфер должен содержать SQL_NULL_DATA, значение SQL_DATA_AT_EXEC или результат SQL_LEN_DATA_AT Макрос _EXEC.  
  
     Если приложение не может определить тип параметра в вызове процедуры, задает *InputOutputType* для SQL_PARAM_INPUT; Если источник данных возвращает значение для параметра, драйвер отбрасывает его.  
  
-   SQL_PARAM_INPUT_OUTPUT. Параметр отмечает входным или выходным параметром в процедуре. Например, параметр в **{вызовите GetEmpDept(?)}**  является входным или выходным параметром, который принимает имя сотрудника и возвращает имя сотрудника отдела.  
  
     При выполнении инструкции драйвер отправляет данные для параметра источника данных. \* *ParameterValuePtr* буфер должен содержать допустимое входное значение или \* *StrLen_or_IndPtr* буфер должен содержать SQL_NULL_DATA, значение SQL_DATA_AT_EXEC или результат макрос SQL_LEN_DATA_AT_EXEC. После выполнения инструкции, драйвер возвращает данные для параметра приложения; Если источник данных не возвращает значение параметра ввода вывода, драйвер задает **StrLen_or_IndPtr* буфера на SQL_NULL_DATA.  
  
    > [!NOTE]  
    >  Если приложение ODBC 1.0 вызывает **SQLSetParam** в драйвере ODBC 2.0 диспетчера драйверов преобразует это вызов **SQLBindParameter** в котором *InputOutputType* аргумент имеет значение SQL_PARAM_INPUT_OUTPUT.  
  
-   SQL_PARAM_OUTPUT. Параметр отмечает возвращаемого значения процедуры или выходного параметра в процедуре. в любом случае эти функции известны как *выходные параметры*. Например, параметр в **{? = вызовите GetNextEmpID}** является выходным параметром, возвращающим следующего идентификатора сотрудника.  
  
     После выполнения инструкции, драйвер возвращает данные для параметра в приложение, если *ParameterValuePtr* и *StrLen_or_IndPtr* аргументы являются оба указатели null в этом случае драйвер отбрасывает выходное значение. Если источник данных не возвращает значение выходного параметра, драйвер задает **StrLen_or_IndPtr* буфера на SQL_NULL_DATA.  
  
-   SQL_PARAM_INPUT_OUTPUT_STREAM. Указывает, должны передаваться входным или выходным параметром. **SQLGetData** могут считывать значения параметра в частях. *BufferLength* пропускается, так как длина буфера будет определяться при вызове **SQLGetData**. Значение *StrLen_or_IndPtr* буфер должен содержать SQL_DEFAULT_PARAM, SQL_NULL_DATA, значение SQL_DATA_AT_EXEC или результат макрос SQL_LEN_DATA_AT_EXEC. Параметр должен быть привязан как параметр данных времени выполнения (DAE) на входе, если будут передаваться в выходных данных. *ParameterValuePtr* может иметь любое значение указателя, отличных от null, будет возвращено функцией **SQLParamData** как пользовательского маркера, значение которого был передан с *ParameterValuePtr* для обоих входных данных и выходных данных. Дополнительные сведения см. в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
-   SQL_PARAM_OUTPUT_STREAM. То же, как SQL_PARAM_INPUT_OUTPUT_STREAM для выходного параметра. **StrLen_or_IndPtr* во входных данных учитывается.  
  
 В следующей таблице перечислены различные сочетания *InputOutputType* и **StrLen_or_IndPtr*:  
  
|*InputOutputType*|**StrLen_or_IndPtr*|Результат|Оператор комментария на ParameterValuePtr|  
|-----------------------|----------------------------|-------------|---------------------------------|  
|SQL_PARAM_INPUT|SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Входной в части|*ParameterValuePtr* может быть любое значение указателя, которое будет возвращено функцией **SQLParamData** как пользовательского маркера, значение которого был передан с *ParameterValuePtr*.|  
|SQL_PARAM_INPUT|Не SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Ввод привязанным буфера|*ParameterValuePtr* адрес входного буфера.|  
|SQL_PARAM_OUTPUT|Во входных данных учитывается.|Связанный буфер вывода|*ParameterValuePtr* адрес выходного буфера.|  
|SQL_PARAM_OUTPUT_STREAM|Во входных данных учитывается.|Потоковые выходные данные|*ParameterValuePtr* может иметь любое значение указателя, в которой будут возвращаться **SQLParamData** как пользовательского маркера, значение которого был передан с *ParameterValuePtr*.|  
|SQL_PARAM_INPUT_OUTPUT|SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Ввода в части и связанного буфер вывода|*ParameterValuePtr* адрес выходного буфера также вернет **SQLParamData** как пользовательского маркера, значение которого был передан с *ParameterValuePtr*.|  
|SQL_PARAM_INPUT_OUTPUT|Не SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Ввод привязанным буфера и выходного буфера привязанного|*ParameterValuePtr* адрес Общий буфер ввода вывода.|  
L_PARAM_INPUT_OUTPUT_STREAM|SQL_LEN_DATA_AT_EXEC (*len*) или SQL_DATA_AT_EXEC|Входной в части и потоковые выходные данные|*ParameterValuePtr* может быть любой указатель отличное от null значение, которое будет возвращено функцией **SQLParamData** как пользовательского маркера, значение которого был передан с *ParameterValuePtr* для обоих Ввод и вывод.|  
  
> [!NOTE]  
>  Драйвер необходимо решить, какие типы SQL допустимы в том случае, если приложение привязывает выходного или параметра ввода вывода, как передавать их потоком. Диспетчер драйверов не будет формировать ошибку для недопустимого типа SQL.  
  
## <a name="valuetype-argument"></a>Аргумент ValueType  
 *ValueType* аргумент задает C тип данных параметра. Этот аргумент задает поля SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE APD. Это должно быть одно из значений в [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) типов данных приложение D:.  
  
 Если *ValueType* аргумент является одним из типов данных интервала поле SQL_DESC_TYPE *ParameterNumber* запись о дескрипторе параметра приложения имеет значение SQL_INTERVAL, равным поле SQL_DESC_CONCISE_TYPE в APD Тип данных четкими интервала и поле SQL_DESC_DATETIME_INTERVAL_CODE *ParameterNumber* записи присваивается дополнительный код для типа данных, определенный интервал времени. (См. [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).) Интервал по умолчанию начальные точность (2) и точность секунд интервал по умолчанию (6), как указано в полях SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION APD, соответственно, используются для данных. Если либо точность по умолчанию не подходит, приложение должно явно задать поля дескриптора путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Если *ValueType* аргумент является одним из типов данных даты и времени, в поле SQL_DESC_TYPE *ParameterNumber* запись APD равно SQL_DATETIME поле SQL_DESC_CONCISE_TYPE *ParameterNumber* запись о дескрипторе параметра приложения имеет значение типа данных datetime четкими C, а поле SQL_DESC_DATETIME_INTERVAL_CODE *ParameterNumber* записи присваивается дополнительный код для определенной даты и времени Тип данных. (См. [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).)  
  
 Если *ValueType* аргумент имеет тип данных SQL_C_NUMERIC точность по умолчанию (который является определяемым драйвером) и масштаб по умолчанию (0), указанные в полях SQL_DESC_PRECISION и SQL_DESC_SCALE APD, используются для данных. Если по умолчанию точности или масштаба неприемлемо, приложение должно явно задать поля дескриптора путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 SQL_C_DEFAULT указывает передачи значение параметра из типа данных C по умолчанию для указанного типа данных SQL с *ParameterType*.  
  
 Можно также указать расширенный тип данных C. Дополнительные сведения см. в разделе [типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 Дополнительные сведения см. в разделе [типами данных C по умолчанию](../../../odbc/reference/appendixes/default-c-data-types.md), [преобразование данных из C в типы данных SQL](../../../odbc/reference/appendixes/converting-data-from-c-to-sql-data-types.md), и [преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в типах данных приложение D:.  
  
## <a name="parametertype-argument"></a>Аргумент ParameterType  
 Это должно быть одно из значений, перечисленных в [типов данных SQL](../../../odbc/reference/appendixes/sql-data-types.md) раздел типы данных приложение D: или он должен иметь значение конкретного драйвера. Этот аргумент задает поля SQL_DESC_TYPE, SQL_DESC_CONCISE_TYPE и SQL_DESC_DATETIME_INTERVAL_CODE IPD.  
  
 Если *ParameterType* аргумент является один из идентификаторов datetime, поле SQL_DESC_TYPE IPD равно SQL_DATETIME, поле SQL_DESC_CONCISE_TYPE в IPD задано для типа данных datetime четкими SQL и SQL_DESC_ Поле DATETIME_INTERVAL_CODE будет присвоено значение datetime, соответствующее дополнительного кода.  
  
 Если *ParameterType* — один из идентификаторов интервал поле SQL_DESC_TYPE IPD имеет значение SQL_INTERVAL, поле SQL_DESC_CONCISE_TYPE в IPD присвоено четкими тип данных SQL интервала и SQL_DESC_DATETIME_ Поле INTERVAL_CODE IPD присваивается дополнительным кодом соответствующие интервалы. Поле SQL_DESC_DATETIME_INTERVAL_PRECISION IPD присвоено начальные точности интервала, а поля SQL_DESC_PRECISION задана точность секунд интервал, если это применимо. Если значение по умолчанию SQL_DESC_DATETIME_INTERVAL_PRECISION или SQL_DESC_PRECISION не подходит, чтобы приложение должно явно задать его путем вызова **SQLSetDescField**. Дополнительные сведения о любом из этих полей см. в разделе [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md).  
  
 Если *ValueType* аргумент имеет тип данных SQL_NUMERIC, точность по умолчанию (который является определяемым драйвером) и масштаб по умолчанию (0), указанные в полях SQL_DESC_PRECISION и SQL_DESC_SCALE в IPD, используются для данных. Если по умолчанию точности или масштаба неприемлемо, приложение должно явно задать поля дескриптора путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
 Сведения о том, как данные преобразуются в разделе [преобразование данных из C в типы данных SQL](../../../odbc/reference/appendixes/converting-data-from-c-to-sql-data-types.md) и [преобразование данных из SQL в типы данных C](../../../odbc/reference/appendixes/converting-data-from-sql-to-c-data-types.md) в типах данных приложение D:.  
  
## <a name="columnsize-argument"></a>Аргумент ColumnSize  
 *ColumnSize* аргумент указывает размер столбца или выражение, соответствующее маркеру параметра, длину данных или оба. Этот аргумент задает различные поля IPD, в зависимости от типа данных SQL ( *ParameterType* аргумент). Чтобы это сопоставление применяются следующие правила:  
  
-   Если *ParameterType* SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY или один четкими даты-времени или интервала типы данных SQL, поле SQL_DESC_LENGTH IPD присвоено значение  *ColumnSize*. (Дополнительные сведения см. в разделе [размер столбца, десятичных цифр, длина в октетах передачи и отображаемый размер](../../../odbc/reference/appendixes/column-size-decimal-digits-transfer-octet-length-and-display-size.md) раздел в типах данных приложение D:.)  
  
-   Если *ParameterType* SQL_DECIMAL, SQL_NUMERIC, SQL_FLOAT, SQL_REAL или SQL_DOUBLE, поле SQL_DESC_PRECISION в IPD присвоено значение *ColumnSize*.  
  
-   Для других типов данных *ColumnSize* аргумент учитывается.  
  
 Дополнительные сведения см. в разделе «Передача значений параметров» и значение SQL_DATA_AT_EXEC в «*StrLen_or_IndPtr* аргумент.»  
  
## <a name="decimaldigits-argument"></a>Аргумент DecimalDigits  
 Если *ParameterType* SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP, SQL_INTERVAL_SECOND, SQL_INTERVAL_DAY_TO_SECOND, SQL_INTERVAL_HOUR_TO_SECOND или SQL_INTERVAL_MINUTE_TO_SECOND, задать поле SQL_DESC_PRECISION в IPD Чтобы *DecimalDigits*. Если *ParameterType* SQL_NUMERIC или SQL_DECIMAL, поле SQL_DESC_SCALE в IPD равно *DecimalDigits*. Для всех других типов данных *DecimalDigits* аргумент учитывается.  
  
## <a name="parametervalueptr-argument"></a>Аргумент ParameterValuePtr  
 *ParameterValuePtr* аргумент указывает на буфер, если **SQLExecute** или **SQLExecDirect** вызывается, содержит фактические данные для параметра. Данные должны быть в форме, заданной *ValueType* аргумент. Этот аргумент задает поле SQL_DESC_DATA_PTR в APD. Приложение может установить *ParameterValuePtr* аргумент является пустым указателем, при условии, что  *\*StrLen_or_IndPtr* SQL_NULL_DATA, или значение SQL_DATA_AT_EXEC. (Это относится только к параметров ввода или ввода вывода).  
  
 Если \* *StrLen_or_IndPtr* результат SQL_LEN_DATA_AT_EXEC (*длина*) макрос или SQL_DATA_AT_EXEC, затем *ParameterValuePtr* — значение указателя, определяемые приложением, связанный с параметром. Он возвращается приложению через **SQLParamData**. Например *ParameterValuePtr* может быть маркер ненулевое значение, например номер параметра, указатель на данные или указатель на структуру, используемой приложением для привязки входных параметров. Однако обратите внимание, что если параметр является входным или выходным параметром, *ParameterValuePtr* должен быть указателем на буфер, в которой будет храниться выходное значение. Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, приложение может использовать значение, указанное атрибутом инструкции SQL_ATTR_PARAMS_PROCESSED_PTR вместе с *ParameterValuePtr* аргумент. Например *ParameterValuePtr* может указывать на массив значений, и приложение может использовать значение, указанное SQL_ATTR_PARAMS_PROCESSED_PTR для получения правильного значения из массива. Дополнительные сведения см. в разделе «Передача параметра значения» далее в этом разделе.  
  
 Если *InputOutputType* аргумент является SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_OUTPUT, *ParameterValuePtr* указывает на буфер, в котором драйвер возвращает выходное значение. Если процедура возвращает один или несколько результирующих наборов, \* *ParameterValuePtr* буфера не гарантируется для задания, пока не будут обработаны все счетчики наборов или строк результата. Если буфер не задано до завершения обработки, выходные параметры и возвращаемые значения будут недоступны до **SQLMoreResults** не вернет значение SQL_NO_DATA. Вызов **SQLCloseCursor** или **SQLFreeStmt** с параметр SQL_CLOSE приведут эти значения будут отменены.  
  
 Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, *ParameterValuePtr* указывает на массив. Одну инструкцию SQL обрабатывает полный массив входных значений для входного или входного выходного параметра и возвращает массив выходных значений для ввода вывода или выходной параметр.  
  
## <a name="bufferlength-argument"></a>Аргумент BufferLength  
 Для символьных и двоичных данных C *BufferLength* аргумент указывает длину \* *ParameterValuePtr* буфера (если это единственный элемент) или длина элемента в \* *ParameterValuePtr* массив (если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1). Этот аргумент задает поле записи SQL_DESC_OCTET_LENGTH в APD. Если приложение задает несколько значений *BufferLength* используется для определения расположения значений в **ParameterValuePtr* массива на входе и на выходе. Для ввода вывода и выходные параметры используемые для определения необходимости выполнить усечение символьных и двоичных данных C на выходе:  
  
-   Для символьных C данных, если количество байтов, доступных для возврата больше или равно *BufferLength*, данные в \* *ParameterValuePtr* усекается до  *BufferLength* меньше длины знака завершения null и нули драйвером.  
  
-   Для двоичных данных C, если количество байтов, доступных для возврата превышает *BufferLength*, данные в \* *ParameterValuePtr* усекается до *BufferLength*байт.  
  
 Для всех других типов данных C *BufferLength* аргумент учитывается. Длина \* *ParameterValuePtr* буфера (если это единственный элемент) или длина элемента в \* *ParameterValuePtr* массив (если приложение вызывает  **SQLSetStmtAttr** с *атрибута* аргумент SQL_ATTR_PARAMSET_SIZE для указания нескольких значений для каждого параметра) считается длина типа данных C.  
  
 Потоковые выходные данные или параметры потокового ввода вывода *BufferLength* аргумент учитывается, так как длина буфера задается в **SQLGetData**.  
  
> [!NOTE]  
>  Если приложение ODBC 1.0 вызывает **SQLSetParam** в ODBC 3. *x* драйвера, диспетчер драйверов преобразует это вызов **SQLBindParameter** в котором *BufferLength* аргументов всегда является SQL_SETPARAM_VALUE_MAX. Поскольку диспетчер драйверов возвращает ошибку, если ODBC 3. *x* приложение задает *BufferLength* для SQL_SETPARAM_VALUE_MAX ODBC 3. *x* драйверов можно использовать для определения того, при вызове приложением ODBC 1.0.  
  
> [!NOTE]  
>  В **SQLSetParam**способом, в котором приложение указывает длину **ParameterValuePtr* буфера, чтобы драйвер может возвращать символьных или двоичных данных и способом, в котором приложение передает Массив символов или двоичных значений параметров для драйвера, драйвер определяются.  
  
## <a name="strlenorindptr-argument"></a>Аргумент StrLen_or_IndPtr  
 *StrLen_or_IndPtr* аргумент указывает на буфер, при **SQLExecute** или **SQLExecDirect** называется, содержит один из следующих действий. (Этот аргумент задает поля записи SQL_DESC_OCTET_LENGTH_PTR и SQL_DESC_INDICATOR_PTR указателей параметра приложения).  
  
-   Длина значения параметра, хранящегося в **ParameterValuePtr*. Игнорируется, кроме символьных или двоичных данных C.  
  
-   SQL_NTS. Значение параметра — строку, завершающуюся символом null.  
  
-   SQL_NULL_DATA. Значение параметра равно NULL.  
  
-   ЗНАЧЕНИЕ SQL_DEFAULT_PARAM. Процедура — Чтобы использовать значение по умолчанию параметра, а не значение, извлеченное из приложения. Это значение допустимо только в процедуру с именем в канонического синтаксиса ODBC, а затем только тогда, когда *InputOutputType* аргумент является SQL_PARAM_INPUT, SQL_PARAM_INPUT_OUTPUT или SQL_PARAM_INPUT_OUTPUT_STREAM. Когда \* *StrLen_or_IndPtr* — SQL_DEFAULT_PARAM *ValueType*, *ParameterType*, *ColumnSize*,  *DecimalDigits*, *BufferLength*, и *ParameterValuePtr* аргументов для входных параметров игнорируются и используются только для того, чтобы определить значение параметра выходных данных для входа / выходные параметры.  
  
-   Результат SQL_LEN_DATA_AT_EXEC (*длина*) макрос. Данные для параметра будут отправляться с **SQLPutData**. Если *ParameterType* аргумент равен SQL_LONGVARBINARY, SQL_LONGVARCHAR или long, тип данных, определяемые источником данных, а драйвер возвращает «Y» для типа данных SQL_NEED_LONG_DATA_LEN в **SQLGetInfo**, *длина* число байтов данных, отправляемых для параметра; в противном случае *длина* должно быть неотрицательным числом и учитывается. Дополнительные сведения см. в разделе «Передача значения параметров,» далее в этом разделе.  
  
     Например, чтобы указать, что 10 000 байт данных будет отправлено с **SQLPutData** в один или несколько вызовов параметра SQL_LONGVARCHAR приложение задает **StrLen_or_IndPtr* SQL_LEN_DATA_AT_EXEC) 10000).  
  
-   ЗНАЧЕНИЕ SQL_DATA_AT_EXEC. Данные для параметра будут отправляться с **SQLPutData**. Это значение используется в приложениях ODBC 1.0 во время звонка ODBC 3. *x* драйверы. Дополнительные сведения см. в разделе «Передача значения параметров,» далее в этом разделе.  
  
 Если *StrLen_or_IndPtr* является указателем null, драйвер предполагает, что все значения входных параметров не равны NULL и что символьных и двоичных данных, завершающуюся значением null. Если *InputOutputType* SQL_PARAM_OUTPUT или SQL_PARAM_OUTPUT_STREAM и *ParameterValuePtr* и *StrLen_or_IndPtr* — оба неопределенные указатели, драйвер отменяет Выходное значение.  
  
> [!NOTE]  
>  Разработчикам приложений не рекомендуется указывать указатель null для *StrLen_or_IndPtr* при SQL_C_BINARY тип данных параметра. Чтобы убедиться в том, что драйвер не удаляет данные SQL_C_BINARY, неожиданно *StrLen_or_IndPtr* должен содержать указатель на значение допустимую длину.  
  
 Если *InputOutputType* аргумент является SQL_PARAM_INPUT_OUTPUT, SQL_PARAM_OUTPUT, SQL_PARAM_INPUT_OUTPUT_STREAM или SQL_PARAM_OUTPUT_STREAM, *StrLen_or_IndPtr* указывает на буфер, в котором драйвер возвращает SQL_NULL_DATA, число байтов, доступных для возврата в \* *ParameterValuePtr* (за исключением байт символьных данных конечное значение null) или SQL_NO_TOTAL (если число байтов, доступных для Возврат не удается определить). Если процедура возвращает один или несколько результирующих наборов, **StrLen_or_IndPtr* буфера не обязательно задайте, пока будут выбраны все результаты.  
  
 Если значение атрибута инструкции SQL_ATTR_PARAMSET_SIZE больше 1, *StrLen_or_IndPtr* указывает на массив значений SQLLEN. Это может быть любым из значений, перечисленных ранее в этом разделе и обрабатываются с помощью одной инструкции SQL.  
  
## <a name="passing-parameter-values"></a>Передача значений параметров  
 Приложение может передать значение для параметра, либо в \* *ParameterValuePtr* буфера или с одного или нескольких вызовов **SQLPutData**. Параметры, данные которого передается с **SQLPutData** известны как *данных во время выполнения* параметров. Они обычно используются для отправки данных для параметров SQL_LONGVARBINARY и SQL_LONGVARCHAR и можно одновременно с другими параметрами.  
  
 Для передачи значений параметров, приложение выполняет следующие действия:  
  
1.  Вызовы **SQLBindParameter** для каждого параметра привязать буфер для значения параметра (*ParameterValuePtr* аргумент) и длины/индикатора (*StrLen_or_IndPtr* аргумент). Для параметров данных во время выполнения *ParameterValuePtr* имеет значение указателя, определяемые приложением, например номер параметра или указатель на данные. Значение будет возвращаться в более поздней версии и может использоваться для идентификации параметра.  
  
2.  Устанавливает значения для входных и входных/выходных параметров в \* *ParameterValuePtr* и **StrLen_or_IndPtr* буферов:  
  
    -   Для обычных параметров приложения помещает значение параметра в \* *ParameterValuePtr* буфера и длина этого значения в **StrLen_or_IndPtr* буфера. Дополнительные сведения см. в разделе [значения параметров параметр](../../../odbc/reference/develop-app/setting-parameter-values.md).  
  
    -   Для параметров данных во время выполнения приложения помещает результат SQL_LEN_DATA_AT_EXEC (*длина*) макрос (при вызове с драйвером ODBC 2.0) в **StrLen_or_IndPtr* буфера.  
  
3.  Вызовы **SQLExecute** или **SQLExecDirect** для выполнения инструкции SQL.  
  
    -   Если нет параметров данных времени выполнения, процесс будет завершен.  
  
    -   Если все параметры данных времени выполнения, функция возвращает значение SQL_NEED_DATA.  
  
4.  Вызовы **SQLParamData** для получения определяемые приложением значения, указанного в *ParameterValuePtr* аргумент **SQLBindParameter** для первого параметр данных времени выполнения для обработки. **SQLParamData** возвращает SQL_NEED_DATA.  
  
    > [!NOTE]  
    >  Несмотря на то, что параметры с данными времени выполнения напоминают столбцов данных времени выполнения, значение, возвращаемое **SQLParamData** отличается для каждого. Параметры данных времени выполнения являются параметрами в инструкции SQL, для которого данные будут отправлены с **SQLPutData** при выполнении инструкции с **SQLExecDirect** или **SQLExecute**. Они связаны с **SQLBindParameter**. Значение, возвращаемое **SQLParamData** передается значение указателя **SQLBindParameter** в *ParameterValuePtr* аргумент. Столбцы данных времени выполнения являются столбцами в наборе строк, для которого данные будут отправлены с **SQLPutData** при обновлении или добавлены строки **SQLBulkOperations** или обновлено с **SQLSetPos**. Они связаны с **SQLBindCol**. Значение, возвращаемое **SQLParamData** адрес строки в **TargetValuePtr* буфера (установить с помощью вызова **SQLBindCol**), обрабатывается.  
  
5.  Вызовы **SQLPutData** один или несколько раз для отправки данных для параметра. Если значение больше, чем требуется более одного вызова \* *ParameterValuePtr* буфера, указанный в **SQLPutData**; несколько вызовов **SQLPutData**для одного параметра допускается только в том случае, при отправке данных символ C для столбца с типом данных, определяемые источником символьных, двоичных и данных, или при отправке двоичных данных C для столбца с символом, двоичных данных, либо тип данных, определяемые источником данных.  
  
6.  Вызовы **SQLParamData** еще раз, чтобы сообщить, что все данные были переданы для параметра.  
  
    -   Если имеются дополнительные параметры данных времени выполнения, **SQLParamData** возвращает SQL_NEED_DATA и определяемые приложением значения для следующего параметра данных времени выполнения для обработки. Приложение повторяет шаги 4 и 5.  
  
    -   Если больше нет параметров данных времени выполнения, процесс будет завершен. Если инструкция была выполнена успешно, **SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO; Если выполнение завершилось неудачей, он возвращает значение SQL_ERROR. На этом этапе **SQLParamData** может возвращать любой SQLSTATE, возвращаемой функцией, которая используется для выполнения инструкции (**SQLExecDirect** или **SQLExecute**).  
  
         Выходные значения для ввода вывода или выходных параметров доступны в \* *ParameterValuePtr* и **StrLen_or_IndPtr* буферов после приложение извлекает все результирующие наборы При обработке инструкции.  
  
 Вызов **SQLExecute** или **SQLExecDirect** помещает инструкцию в состоянии SQL_NEED_DATA. На этом этапе приложение может вызвать только **SQLCancel**, **SQLGetDiagField**, **SQLGetDiagRec**, **SQLGetFunctions**, **SQLParamData**, или **SQLPutData** с инструкцией или *дескриптор подключения* связанные с инструкцией. Если она вызывает любой другой функции инструкцией или соединения, связанные с инструкцией, функция возвращает SQLSTATE HY010 (функция ошибка последовательности). Оставляет инструкции, SQL_NEED_DATA состояние, когда **SQLParamData** или **SQLPutData** возвращает сообщение об ошибке **SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO, или Инструкция отменяется.  
  
 Если приложение вызывает **SQLCancel** пока драйвер по-прежнему требуются данные для параметров данных времени выполнения, драйвер отменяет выполнение инструкций, приложение может затем вызвать **SQLExecute** или  **SQLExecDirect** еще раз.  
  
## <a name="retrieving-streamed-output-parameters"></a>Получение потоковых выходных параметров  
 Когда приложение задает *InputOutputType* SQL_PARAM_INPUT_OUTPUT_STREAM или SQL_PARAM_OUTPUT_STREAM, необходимо извлечь значение параметра выходных данных с одного или нескольких вызовов **SQLGetData**. При драйвер имеет значение параметра потоковые выходные данные, чтобы вернуться в приложение, он будет возвращать SQL_PARAM_DATA_AVAILABLE в ответ на вызов к следующим функциям: **SQLMoreResults**, **SQLExecute**, и **SQLExecDirect**. Приложение вызывает **SQLParamData** , чтобы определить, какое значение параметра доступно.  
  
 Дополнительные сведения о SQL_PARAM_DATA_AVAILABLE и потоковых выходных параметров см. в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="using-arrays-of-parameters"></a>Использование массивов параметров  
 Когда приложение подготавливает инструкцию с маркерами параметров и передает в массив параметров, существует два разных способа это могут быть выполнены. Один из способов — драйвер полагается на возможности обработки массива серверной части, в котором регистр вся инструкция с массивом параметров рассматривается как одно целое. Oracle примером может служить источником данных, которая поддерживает возможности обработки массива. Другой способ реализации этой возможности — для пакетных инструкций SQL, одну инструкцию SQL для каждого набора параметров, указанных в массиве параметров, создания и выполнения пакета драйвера. Массивы параметров не может использоваться с **обновление WHERE CURRENT OF** инструкции.  
  
 При обработке массив параметров отдельными результирующими количество наборов или строк (по одному для каждого набора параметров) могут быть доступны или сведенный статистикой результатов набора или строк в одну. В диалоговом окне SQL_PARAM_ARRAY_ROW_COUNTS **SQLGetInfo** указывает количество строк, доступных для каждого набора параметров (SQL_PARC_BATCH) или количество только одну строку — доступные (SQL_PARC_NO_BATCH).  
  
 В диалоговом окне SQL_PARAM_ARRAY_SELECTS **SQLGetInfo** указывает ли результирующий набор доступен для каждого набора параметров (SQL_PAS_BATCH) или только один результирующий набор доступных (SQL_PAS_NO_BATCH). Если драйвер не допускает результирующий набор генерации выполняемая инструкция с массивом параметров, SQL_PARAM_ARRAY_SELECTS возвращает SQL_PAS_NO_SELECT.  
  
 Дополнительные сведения см. в разделе [SQLGetInfo, функция](../../../odbc/reference/syntax/sqlgetinfo-function.md).  
  
 Для поддержки массивы параметров, атрибут инструкции SQL_ATTR_PARAMSET_SIZE задано для задания количества значений для каждого параметра. Если поле не больше 1, массивы должен указывать поля SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR в APD. Количество элементов в каждом массиве равно значению SQL_ATTR_PARAMSET_SIZE.  
  
 Поле SQL_DESC_ROWS_PROCESSED_PTR APD указывает на буфер, который содержит число наборов параметров, которые были обработаны, включая наборы ошибки. В процессе обработки каждого набора параметров драйвер сохраняет новое значение в буфере. Число не будут возвращены, если это пустой указатель. При использовании массивов параметров, значение, указанное в поле SQL_DESC_ROWS_PROCESSED_PTR APD заполняется, даже если параметр функции возвращается значение SQL_ERROR. Если возвращается значение SQL_NEED_DATA, набор параметров, которые обрабатываются присвоено значение, указанное в поле SQL_DESC_ROWS_PROCESSED_PTR дескрипторе параметра приложения.  
  
 Что происходит при привязке массив параметров и **обновление WHERE CURRENT OF** выполняется инструкция является определяемым драйвером.  
  
## <a name="column-wise-parameter-binding"></a>Привязки параметра на уровне столбца  
 В привязку по столбцам, приложение связывает отдельный параметр и массивы длины/индикатора для каждого параметра.  
  
 Чтобы использовать привязки на уровне столбца, приложение сначала задает атрибут инструкции SQL_ATTR_PARAM_BIND_TYPE значение SQL_PARAM_BIND_BY_COLUMN. (Это значение по умолчанию). Для каждого столбца может быть привязано приложение выполняет следующие действия:  
  
1.  Выделяет буфер массива параметров.  
  
2.  Выделяет массив буферов длины/индикатора.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно к дескрипторам, когда используется привязка на уровне столбцов, можно использовать отдельные массивы данных длины и индикатора.  
  
3.  Вызовы **SQLBindParameter** со следующими аргументами:  
  
    -   *ValueType* тип C из одного элемента в массиве параметров буфера.  
  
    -   *ParameterType* SQL тип параметра.  
  
    -   *ParameterValuePtr* адрес буфера массива параметров.  
  
    -   *BufferLength* размер одиночного элемента в массиве параметров буфера. *BufferLength* аргумент учитывается, если данные фиксированной длины.  
  
    -   *StrLen_or_IndPtr* является адресом массива длины/индикатора.  
  
 Дополнительные сведения о том, как эта информация используется в разделе «ParameterValuePtr аргумент» в «Комментарии» далее в этом разделе. Дополнительные сведения о привязке на уровне столбца параметров см. в разделе [массивы параметров привязки](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).  
  
## <a name="row-wise-parameter-binding"></a>Построчная привязка параметров  
 В привязку на уровне строки приложение определяет структуру, содержащую буферы параметра и длины/индикатора для каждого параметра для привязки.  
  
 Чтобы использовать привязку на уровне строки, приложение выполняет следующие действия:  
  
1.  Определяет структуру для хранения один набор параметров (включая буферы параметра и длины/индикатора) и выделяет массив этих структур.  
  
    > [!NOTE]  
    >  Если приложение записывает непосредственно к дескрипторам, когда привязка используется, можно использовать отдельные поля для данных, длины и индикатора.  
  
2.  Задает атрибут инструкции SQL_ATTR_PARAM_BIND_TYPE размер структуры, которая содержит один набор параметров или размер буфера, в который будет привязан параметры экземпляра. Длина должна включать пробел для всех связанных параметров и все заполнения структуры или буфера, чтобы убедиться в том, результат адрес связанного параметра увеличивается с указанной длины, будет указывать на начало этого параметра в Следующая строка. При использовании *sizeof* оператор в ANSI C, такое поведение гарантируется.  
  
3.  Вызовы **SQLBindParameter** со следующими аргументами для каждого параметра для привязки:  
  
    -   *ValueType* тип члена буфера параметр привязан к столбцу.  
  
    -   *ParameterType* SQL тип параметра.  
  
    -   *ParameterValuePtr* адрес параметра буфер элемента в первом элементе массива.  
  
    -   *BufferLength* размер буфера член параметра.  
  
    -   *StrLen_or_IndPtr* адрес длины/индикатора элемента для привязки.  
  
 Дополнительные сведения об использовании этих сведений см. в разделе «*ParameterValuePtr* аргумента» далее в этом разделе. Дополнительные сведения о Построчная привязка параметров см. в разделе [массивы параметров привязки](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).  
  
## <a name="error-information"></a>Сведения об ошибке  
 Если драйвер не реализует массивы параметров как пакеты (параметр SQL_PARAM_ARRAY_ROW_COUNTS равен SQL_PARC_NO_BATCH), ситуаций с ошибками, обрабатываются, как если бы выполнялись одной инструкции. Если драйвер реализует массивы параметров как пакеты, приложение может использовать поле заголовка SQL_DESC_ARRAY_STATUS_PTR IPD, чтобы определить, какой параметр инструкции SQL или вызвал какой параметр в массиве параметров  **SQLExecDirect** или **SQLExecute** будут возвращать ошибку. Это поле содержит сведения о состоянии для каждого ряда значений параметров. Если поле указывает, что произошла ошибка, поля в структуре диагностических данных будут указывать номер строки и параметр параметра, который не удалось. Число элементов в массиве будут определяться поле заголовка SQL_DESC_ARRAY_SIZE в дескрипторе параметра приложения, которое может быть задано в атрибуте SQL_ATTR_PARAMSET_SIZE инструкции.  
  
> [!NOTE]  
>  Чтобы игнорировать параметры используется поле заголовка SQL_DESC_ARRAY_STATUS_PTR в дескрипторе параметра приложения. Дополнительные сведения о пропуске параметры следующем разделе, «Пропускается набор параметров».  
  
 Когда **SQLExecute** или **SQLExecDirect** возвращает значение SQL_ERROR, элементы массива, на который указывает поле SQL_DESC_ARRAY_STATUS_PTR в IPD будет содержать SQL_ SQL_PARAM_ERROR SQL_PARAM_SUCCESS, PARAM_SUCCESS_WITH_INFO, SQL_PARAM_UNUSED или SQL_PARAM_DIAG_UNAVAILABLE.  
  
 Для каждого элемента в массиве структура диагностических данных содержит одну или несколько записей состояния. Поле SQL_DIAG_ROW_NUMBER структуры указывает номер строки, значения параметров, вызвавшие ошибку. Если это невозможно определить определенный параметр в строке параметров, вызвавшие ошибку, номер параметра будет введен в поле SQL_DIAG_COLUMN_NUMBER.  
  
 Параметр не используется из-за ошибки в более ранних параметр, который принудительно внесения SQL_PARAM_UNUSED **SQLExecute** или **SQLExecDirect** будет прервана. Например, при наличии 50 параметров и произошла ошибка при выполнении fortieth набор параметров, вызвавших **SQLExecute** или **SQLExecDirect** будет прервана, а затем SQL_PARAM_UNUSED вводится в Массив состояний параметров 41 до 50.  
  
 SQL_PARAM_DIAG_UNAVAILABLE вводится, когда драйвер считает массивы параметров монолитные единицу измерения, поэтому он не формирует этот уровень отдельного параметра сведений об ошибках.  
  
 Некоторые ошибки в ходе обработки единого набора параметров привести к обработке последующих наборы параметров в массиве, чтобы остановить. Другие ошибки, не влияют на обработку последующих параметров. Какие ошибки остановит обработку, определяемым драйвером. Если обработка не будет остановлена, обрабатываются все параметры в массиве, в результате ошибки возвращается SQL_SUCCESS_WITH_INFO и определяется SQL_ATTR_PARAMS_PROCESSED_PTR присваивается общее число наборов параметров обработки (в соответствии с определением Атрибут инструкции SQL_ATTR_PARAMSET_SIZE), включая наборы ошибки.  
  
> [!CAUTION]  
>  Поведение ODBC при возникновении ошибки в ходе обработки массив параметров отличается в ODBC 3. *x* чем ODBC 2. *x*. В ODBC 2. *x*, функция вернула значение SQL_ERROR и обработки перестали. Размер буфера, на который указывает *pirow* аргумент **SQLParamOptions** содержится номер строки ошибки. В ODBC 3. *x*, функция возвращает значение SQL_SUCCESS_WITH_INFO и обработки может либо отменить или продолжить. Если он не будет устранена, указанный буфер SQL_ATTR_PARAMS_PROCESSED_PTR будет присвоено значение всех обработанных параметров, включая те, которые привели к ошибке. Это изменение в поведении может вызвать проблемы для существующих приложений.  
  
 Когда **SQLExecute** или **SQLExecDirect** возвращает до завершения обработки всех наборов параметров в массиве параметров, например, если возвращается значение SQL_ERROR или SQL_NEED_DATA, этот массив содержит статусы для этих параметров, которые уже были обработаны. Расположение, на который указывает поле SQL_DESC_ROWS_PROCESSED_PTR в IPD содержит номер строки в массиве параметров, в результате ошибки SQL_ERROR или SQL_NEED_DATA. Когда массив параметров отправляется инструкция SELECT, доступности массив значений состояния драйвера определяется; они могут быть доступны после инструкции был выполнен или в результате будут выбраны наборов.  
  
## <a name="ignoring-a-set-of-parameters"></a>Пропуск набор параметров  
 Поле SQL_DESC_ARRAY_STATUS_PTR APD (как задаваемое при помощи инструкции sql_attr_param_status_ptr) используется для указания игнорирования набор связанных параметров в инструкции SQL. Для направления драйвера, чтобы игнорировать один или несколько наборов параметров во время выполнения, приложения должны выполнить следующие действия:  
  
1.  Вызовите **SQLSetDescField** присвоить полю заголовка SQL_DESC_ARRAY_STATUS_PTR APD, чтобы она указывала на массив значений SQLUSMALLINT содержит сведения о состоянии. Это поле также можно задать путем вызова **SQLSetStmtAttr** с *атрибута* из SQL_ATTR_PARAM_OPERATION_PTR, что позволяет приложению задать поле без получения дескриптора.  
  
2.  Значение каждого элемента массива определяется поле SQL_DESC_ARRAY_STATUS_PTR APD одно из двух значений:  
  
    -   SQL_PARAM_IGNORE, чтобы указать, что строка исключается из выполнения инструкции.  
  
    -   SQL_PARAM_PROCEED, чтобы указать, что строка включается при выполнении инструкции.  
  
3.  Вызовите **SQLExecDirect** или **SQLExecute** на выполнение подготовленной инструкции.  
  
 Массив, который определяется поле SQL_DESC_ARRAY_STATUS_PTR APD применяются следующие правила:  
  
-   Указатель устанавливается в значение null по умолчанию.  
  
-   Если указатель имеет значение null, используются все наборы параметров, как если бы все элементы, заданные для SQL_ROW_PROCEED.  
  
-   Установка элемента SQL_PARAM_PROCEED гарантирует использование определенного набора параметров операции.  
  
-   SQL_PARAM_PROCEED определяется как "0" в файле заголовка.  
  
 Приложение может установить SQL_DESC_ARRAY_STATUS_PTR поля в дескрипторе параметра приложения, чтобы она указывала на один и тот же массив как, на который указывает по полю SQL_DESC_ARRAY_STATUS_PTR в IRD. Это полезно при выполнении привязки параметров для строки данных. Параметры можно игнорировать, затем по состоянию строки данных. В дополнение к SQL_PARAM_IGNORE, следующие коды привести параметр в инструкции SQL, пропускаются: SQL_ROW_DELETED, SQL_ROW_ERROR и SQL_ROW_UPDATED. В дополнение к SQL_PARAM_PROCEED, следующие коды вызвать инструкцию SQL для продолжения: SQL_ROW_SUCCESS, SQL_ROW_SUCCESS_WITH_INFO и SQL_ROW_ADDED.  
  
## <a name="rebinding-parameters"></a>Повторная привязка параметров  
 Приложение может выполнять одно из двух операций для изменения привязки:  
  
-   Вызовите **SQLBindParameter** для указания новой привязки для столбца, который уже привязан. Драйвер перезаписывает старый привязки на новую.  
  
-   Указать смещение для добавления адрес буфера, который был указан при помощи вызова привязки **SQLBindParameter**. Дополнительные сведения см. следующий раздел «Перепривязки со смещениями».  
  
## <a name="rebinding-with-offsets"></a>Повторная привязка с отступами  
 Повторная привязка параметров особенно полезна, когда приложение удерживает установки области буфера, который может содержать множество параметров, но вызов **SQLExecDirect** или **SQLExecute** используется только несколько параметров. Путем изменения существующего привязки смещение оставшегося свободного места в буферной области можно использовать для следующего набора параметров.  
  
 Смещение привязки указывает поле заголовка SQL_DESC_BIND_OFFSET_PTR в дескрипторе параметра приложения. Если поле не равно null, драйвер разыменовывает указатель и, если ни одно из значений в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR является пустым указателем, добавляет разыменованное значение для этих полей в дескрипторе записи во время выполнения. При выполнении инструкций SQL, используются новые значения указателя. Смещение остается допустимым после повторной привязки. Поскольку SQL_DESC_BIND_OFFSET_PTR является указателем на смещение, а не сам смещение, приложение может изменять смещение напрямую, без вызова метода [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) или [SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md) для Измените поле дескриптора. Указатель устанавливается в значение null по умолчанию. Поле SQL_DESC_BIND_OFFSET_PTR Отменить можно задать с помощью вызова [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) или путем вызова [SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)с *fAttribute* из SQL_ATTR_PARAM_BIND_ OFFSET_PTR.  
  
 Смещение привязки всегда добавляется непосредственно значения в полях SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR и SQL_DESC_OCTET_LENGTH_PTR. Если смещение изменяется с другим значением, новое значение все равно добавляется непосредственно к значению в каждом поле дескриптора. Новое смещение не добавляется к сумме значение поля и любые ранее смещения.  
  
## <a name="descriptors"></a>Дескрипторы  
 Как привязать параметр определяется по полям APDs и реализации. Аргументы в **SQLBindParameter** , используются для задания этих поля дескриптора. Также можно задать поля **SQLSetDescField** функций, несмотря на то что **SQLBindParameter** более эффективно использовать, так как приложение не имеет для получения дескриптора для вызова **SQLBindParameter**.  
  
> [!CAUTION]  
>  Вызов **SQLBindParameter** для одной инструкции может повлиять на другие инструкции. Это происходит при явном выделении Отменить, связанные с инструкцией и также связан с другими инструкциями. Поскольку **SQLBindParameter** изменяет поля APD изменения применяются ко всем операторам, с которыми связан данный дескриптор. Если это не необходимого поведения, приложение должно отменить связь этим дескриптором из других инструкций перед вызовом **SQLBindParameter**.  
  
 По существу **SQLBindParameter** выполняет следующие шаги в последовательности:  
  
1.  Вызовы [SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md) для получения дескриптора APD.  
  
2.  Вызовы [SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md) для получения APD SQL_DESC_COUNT поля и, если значение *ColumnNumber* аргумента превышает значение SQL_DESC_COUNT вызовы **SQLSetDescField**увеличить значение SQL_DESC_COUNT для *ColumnNumber*.  
  
3.  Вызовы [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) несколько раз, чтобы присвоить значения следующих полей свойства APD:  
  
    -   Присваивает значение SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE *ValueType*, за исключением того, что если *ValueType* является одним четкими идентификаторов подтипа даты-времени или интервала, он задает SQL_DESC_TYPE SQL_ DATETIME или SQL_INTERVAL, соответственно, устанавливает SQL_DESC_CONCISE_TYPE четкими идентификатор и присваивает SQL_DESC_DATETIME_INTERVAL_CODE соответствующие даты и времени или интервала дополнительным кодом.  
  
    -   Устанавливает значение поля SQL_DESC_OCTET_LENGTH *BufferLength*.  
  
    -   Устанавливает значение поля SQL_DESC_DATA_PTR *ParameterValue*.  
  
    -   Устанавливает поля SQL_DESC_OCTET_LENGTH_PTR значение *StrLen_or_Ind*.  
  
    -   Также устанавливает поля SQL_DESC_INDICATOR_PTR значение *StrLen_or_Ind*.  
  
     *StrLen_or_Ind* указывает сведения индикаторов и длину для значения параметра.  
  
4.  Вызовы [SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md) для получения дескриптора IPD.  
  
5.  Вызовы [SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md) для получения IPD SQL_DESC_COUNT поля и, если значение *ColumnNumber* аргумента превышает значение SQL_DESC_COUNT вызовы **SQLSetDescField**увеличить значение SQL_DESC_COUNT для *ColumnNumber*.  
  
6.  Вызовы [SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md) несколько раз, чтобы присвоить значения следующих полей свойства IPD:  
  
    -   Присваивает значение SQL_DESC_TYPE и SQL_DESC_CONCISE_TYPE *ParameterType*, за исключением того, что если *ParameterType* является одним четкими идентификаторов подтипа даты-времени или интервала, он задает SQL_DESC_TYPE SQL_DATETIME или SQL_INTERVAL соответственно, устанавливает SQL_DESC_CONCISE_TYPE четкими идентификатор и наборы SQL_DESC_DATETIME_INTERVAL_CODE соответствующие даты и времени или интервала дополнительным кодом.  
  
    -   Задает один или несколько SQL_DESC_LENGTH, SQL_DESC_PRECISION и SQL_DESC_DATETIME_INTERVAL_PRECISION, в зависимости от *ParameterType*.  
  
    -   Присваивает значение SQL_DESC_SCALE *DecimalDigits*.  
  
 Если вызов **SQLBindParameter** завершается ошибкой, содержимое поля дескриптора, которые оно будет задано в дескрипторе параметра приложения не определены, и поле SQL_DESC_COUNT APD не меняется. Кроме того не определены поля SQL_DESC_LENGTH, SQL_DESC_PRECISION, SQL_DESC_SCALE и SQL_DESC_TYPE соответствующую запись в IPD и поле SQL_DESC_COUNT IPD не меняется.  
  
## <a name="conversion-of-calls-to-and-from-sqlsetparam"></a>Преобразование вызовы, связанные с SQLSetParam  
 Если приложение ODBC 1.0 вызывает **SQLSetParam** в ODBC 3. *x* драйвера ODBC 3. *x* диспетчера драйверов сопоставляет вызова, как показано в следующей таблице.  
  
|Вызовите приложением ODBC 1.0|Вызов ODBC 3. *x* драйвера|  
|----------------------------------|-------------------------------|  
|SQLSetParam (StatementHandle, ParameterNumber, ValueType, ParameterType, LengthPrecision, ParameterScale, ParameterValuePtr, StrLen_or_IndPtr);|SQLBindParameter (StatementHandle, ParameterNumber, SQL_PARAM_INPUT_OUTPUT, ValueType, ParameterType, *ColumnSize*, *DecimalDigits*, ParameterValuePtr, SQL_SETPARAM_VALUE_MAX,      StrLen_or_IndPtr);|  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение подготавливает инструкцию SQL для вставки данных в таблице ORDERS. Для каждого параметра в инструкции, вызываемые приложением **SQLBindParameter** для указания типа данных ODBC C и параметра типа данных SQL и выполнить привязку буфер каждого параметра. Для каждой строки данных, приложение присваивает значения данных каждого параметра и вызывает **SQLExecute** для выполнения инструкции.  
  
 Следующий пример предполагается, что источник данных ODBC на компьютере с именем Northwind, который связан с базой данных "Борей".  
  
 Дополнительные примеры кода см. в разделе [функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), [функция SQLProcedures](../../../odbc/reference/syntax/sqlprocedures-function.md), [SQLPutData, функция](../../../odbc/reference/syntax/sqlputdata-function.md), и [функция SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
```  
// SQLBindParameter_Function.cpp  
// compile with: ODBC32.lib  
#include <windows.h>  
#include <sqltypes.h>  
#include <sqlext.h>  
  
#define EMPLOYEE_ID_LEN 10  
  
SQLHENV henv = NULL;  
SQLHDBC hdbc = NULL;  
SQLRETURN retcode;  
SQLHSTMT hstmt = NULL;  
SQLSMALLINT sCustID;  
  
SQLCHAR szEmployeeID[EMPLOYEE_ID_LEN];  
SQL_DATE_STRUCT dsOrderDate;  
SQLINTEGER cbCustID = 0, cbOrderDate = 0, cbEmployeeID = SQL_NTS;  
  
int main() {  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
   retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
   retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
   retcode = SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
   retcode = SQLConnect(hdbc, (SQLCHAR*) "Northwind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
   retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);  
  
   retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, EMPLOYEE_ID_LEN, 0, szEmployeeID, 0, &cbEmployeeID);  
   retcode = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_SSHORT, SQL_INTEGER, 0, 0, &sCustID, 0, &cbCustID);  
   retcode = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_TYPE_DATE, SQL_TIMESTAMP, sizeof(dsOrderDate), 0, &dsOrderDate, 0, &cbOrderDate);  
  
   retcode = SQLPrepare(hstmt, (SQLCHAR*)"INSERT INTO Orders(CustomerID, EmployeeID, OrderDate) VALUES (?, ?, ?)", SQL_NTS);  
  
   strcpy_s((char*)szEmployeeID, _countof(szEmployeeID), "BERGS");  
   sCustID = 5;  
   dsOrderDate.year = 2006;  
   dsOrderDate.month = 3;  
   dsOrderDate.day = 17;  
  
   retcode = SQLExecute(hstmt);  
}  
```  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение выполняет хранимую процедуру SQL Server с использованием именованного параметра.  
  
```  
// SQLBindParameter_Function_2.cpp  
// compile with: ODBC32.lib  
// sample assumes the following stored procedure:  
// use northwind  
// DROP PROCEDURE SQLBindParameter  
// GO  
//   
// CREATE PROCEDURE SQLBindParameter @quote int  
// AS  
// delete from orders where OrderID >= @quote  
// GO  
#include <windows.h>  
#include <sqltypes.h>  
#include <sqlext.h>  
  
SQLHDESC hIpd = NULL;  
SQLHENV henv = NULL;  
SQLHDBC hdbc = NULL;  
SQLRETURN retcode;  
SQLHSTMT hstmt = NULL;  
SQLCHAR szQuote[50] = "100084";  
SQLINTEGER cbValue = SQL_NTS;  
  
int main() {  
   retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);  
   retcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER*)SQL_OV_ODBC3, 0);   
  
   retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);   
   retcode = SQLSetConnectAttr(hdbc, SQL_LOGIN_TIMEOUT, (SQLPOINTER)5, 0);  
  
   retcode = SQLConnect(hdbc, (SQLCHAR*) "Northwind", SQL_NTS, (SQLCHAR*) NULL, 0, NULL, 0);  
   retcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &hstmt);  
  
   retcode = SQLPrepare(hstmt, (SQLCHAR*)"{call SQLBindParameter(?)}", SQL_NTS);  
   retcode = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 50, 0, szQuote, 0, &cbValue);  
   retcode = SQLGetStmtAttr(hstmt, SQL_ATTR_IMP_PARAM_DESC, &hIpd, 0, 0);  
   retcode = SQLSetDescField(hIpd, 1, SQL_DESC_NAME, "@quote", SQL_NTS);  
  
   retcode = SQLExecute(hstmt);  
}  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Возвращение сведений о параметре в операторе|[Функция SQLDescribeParam](../../../odbc/reference/syntax/sqldescribeparam-function.md)|  
|Выполнение инструкции SQL|[Функция SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнения подготовленной инструкции SQL|[Функция SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Освобождение буферов параметра в операторе|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
|Возвращает число параметров инструкции|[Функция SQLNumParams](../../../odbc/reference/syntax/sqlnumparams-function.md)|  
|Возвращает следующий параметр для отправки данных|[Функция SQLParamData](../../../odbc/reference/syntax/sqlparamdata-function.md)|  
|Указание нескольких значений параметра|[Функция SQLParamOptions](../../../odbc/reference/syntax/sqlparamoptions-function.md)|  
|Отправка данных параметра во время выполнения|[Функция SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
