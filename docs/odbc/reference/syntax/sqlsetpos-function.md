---
title: Функция SQLSetPos | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
apiname:
- SQLSetPos
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetPos
helpviewer_keywords:
- SQLSetPos function [ODBC]
ms.assetid: 80190ee7-ae3b-45e5-92a9-693eb558f322
caps.latest.revision: 31
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: d4b8f63f0a4891ceaa6e7904135dc06db4473eec
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="sqlsetpos-function"></a>Функция SQLSetPos
**Соответствия**  
 Появился в версии: Полное соответствие стандартам 1.0 ODBC: ODBC  
  
 **Сводка**  
 **SQLSetPos** задает положение курсора в набор строк и позволяет приложению обновлять данные в наборе строк, или для обновления или удаления данных в результирующем наборе.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLSetPos(  
      SQLHSTMT        StatementHandle,  
      SQLSETPOSIROW   RowNumber,  
      SQLUSMALLINT    Operation,  
      SQLUSMALLINT    LockType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *RowNumber*  
 [Вход] Позиция строки в наборе строк, в которой нужно выполнить операцию, заданную с *операции* аргумент. Если *RowNumber* равно 0, операция применяется к каждой строки в наборе строк.  
  
 Дополнительные сведения см. в разделе «Комментарии».  
  
 *Операция*  
 [Вход] Для выполнения операции:  
  
 SQL_POSITION SQL_REFRESH SQL_UPDATE SQL_DELETE  
  
> [!NOTE]  
>  Значение SQL_ADD *операции* аргумент является устаревшим для ODBC 3 *.x*. ODBC 3. *x* драйверы потребуется для поддержки SQL_ADD для обеспечения обратной совместимости. Эта функциональность была заменена вызов **SQLBulkOperations** с *операции* из SQL_ADD. Когда ODBC 3. *x* приложение работает с ODBC 2. *x* драйвера, диспетчер драйверов сопоставляет вызов **SQLBulkOperations** с *операции* из SQL_ADD для **SQLSetPos** с  *Операция* из SQL_ADD.  
  
 Дополнительные сведения см. в разделе «Комментарии».  
  
 *LockType*  
 [Вход] Указывает способ блокировки строки после выполнения операции, указанные в *операции* аргумент.  
  
 SQL_LOCK_NO_CHANGE SQL_LOCK_EXCLUSIVE SQL_LOCK_UNLOCK  
  
 Дополнительные сведения см. в разделе «Комментарии».  
  
 **Возвращает**  
  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NEED_DATA, SQL_STILL_EXECUTING, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLSetPos** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из SQL_ HANDLE_STMT и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLSetPos** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
 Для всех этих SQLSTATE, которые могут возвращать значение SQL_SUCCESS_WITH_INFO или SQL_ERROR (за исключением SQLSTATE 01xxx), возвращается SQL_SUCCESS_WITH_INFO, если в одной или нескольким, но не для всех строк многострочные операции происходит ошибка, и возвращается значение SQL_ERROR, если произошла ошибка Операция одной строки.  
  
|SQLSTATE|Ошибка|Описание|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01001|Конфликт операции с курсором|*Операции* аргумент имеет SQL_DELETE или SQL_UPDATE и ни одной строки или более чем одной строке, удалении или обновлении. (Дополнительные сведения об обновлениях для более чем одной строке см. в описании SQL_ATTR_SIMULATE_CURSOR *атрибута* в **SQLSetStmtAttr**.) (Функция возвращает значение SQL_SUCCESS_WITH_INFO).<br /><br /> *Операции* аргумент имеет SQL_DELETE или SQL_UPDATE, и операция не выполнена из-за оптимистичного параллелизма. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Правый усечение данных строки|*Операции* аргумент был SQL_REFRESH и строка или двоичные данные, возвращаемые для столбца или столбцов с типом данных SQL_C_CHAR и SQL_C_BINARY привело к усечению непустых символьных или двоичных данных от NULL.|  
|01S01|Ошибка в строке|*RowNumber* аргумент: 0, и ошибка в одной или нескольких строк при выполнении операции, заданной с *операции* аргумент.<br /><br /> (SQL_SUCCESS_WITH_INFO возвращается, если в одной или нескольким, но не для всех строк многострочные операции происходит ошибка, и при возникновении ошибки во время операции одной строки, возвращается значение SQL_ERROR).<br /><br /> (Это SQLSTATE возвращается, только если **SQLSetPos** вызывается после **SQLExtendedFetch**, если драйвер ODBC 2. *x* драйвер и библиотеку курсоров не используется.)|  
|01S07|Частичное усечение|*Операции* аргумент был SQL_REFRESH, тип данных буфера приложения не была SQL_C_CHAR и SQL_C_BINARY и потери данных, возвращаемых буферы приложения для одного или нескольких столбцов. Для числовых типов данных был усечен, дробная часть числа. Время, отметка времени и интервальных типов данных, содержащего компонент времени дробная часть времени было усечено.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение столбца в результирующем наборе не удалось преобразовать тип данных, указанный в *TargetType* в вызове **SQLBindCol**.|  
|07009|Недопустимый индекс дескриптора|Аргумент *операции* SQL_REFRESH или SQL_UPDATE и столбец был связан с числом столбцов больше, чем количество столбцов в результирующем наборе.|  
|21S02|Структура полученной таблицы не соответствуют списку столбцов|Аргумент *операции* SQL_UPDATE, и столбцы не имели обновляемых, так как все столбцы были либо несвязанный, только для чтения, или значение в буфер связанного длины/индикатора был SQL_COLUMN_IGNORE.|  
|22001|Строковые данные, усечение справа|*Операции* аргумент был SQL_UPDATE и назначение символьное или двоичное значение в столбец привело к усечение непустым (для символов) или ненулевой (для двоичного файла) символов или байтов.|  
|22003|Численное значение вне допустимого диапазона|Аргумент *операции* был SQL_UPDATE, и назначение числовое значение для столбца в результирующем наборе вызвало целиком (в отличие от доли) часть усекаемое число.<br /><br /> Аргумент *операции* было SQL_REFRESH, и возвращает числовое значение для одного или нескольких связанных столбцов могло привести к потере значащих цифр.|  
|22007|Формат недопустимые даты и времени|Аргумент *операции* был SQL_UPDATE и присвоение значения date и timestamp со столбцом в результирующем наборе за год, месяц или день поле должно быть вне допустимого диапазона.<br /><br /> Аргумент *операции* был SQL_REFRESH и возврат значения даты или отметки времени для одного или нескольких связанных столбцов могло привести год, месяц или день поле должно быть вне допустимого диапазона.|  
|22008|Переполнение поля даты и времени|*Операции* аргумент был SQL_UPDATE и производительность арифметика на данные, отправляемые в столбец в результирующем наборе datetime привело к поля даты и времени (год, месяц, день, час, минуту или второе поле), результат за пределами допустимого диапазона значений для поля или недопустимом на основании естественным правила даты григорианского календаря.<br /><br /> *Операции* аргумент был SQL_REFRESH и производительность арифметика на полученных из результирующего набора данных datetime привело к поля даты и времени (год, месяц, день, час, минуту или второе поле), результат за пределами допустимого диапазона значений для поля или недопустимом на основании естественным правила даты григорианского календаря.|  
|22015|Переполнение поля интервала|*Операции* аргумент был SQL_UPDATE и назначение точным или тип интервала C в пределах типа данных SQL привело к потере значащих цифр.<br /><br /> *Операции* аргумент был SQL_UPDATE; при назначении в пределах типа SQL была не представление значения типа C, в течение интервала, тип SQL.<br /><br /> *Операции* аргумент был SQL_REFRESH и присвоение тип интервала C из точное числовое значение или интервал тип SQL привело к потере значащих разрядов в начале поля.<br /><br /> *Операции* аргумент был обновить SQL_; присвоить тип интервала C, возникла не представление значения в тип интервала C типа SQL.|  
|22018|Недопустимое символьное значение для спецификации приведения|*Операции* аргумент был SQL_REFRESH; тип C был точное или Приблизительное числовое, datetime или тип интервала данных; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом из связанный тип C.<br /><br /> Аргумент *операции* был SQL_UPDATE; тип SQL был точное или Приблизительное числовое, datetime или тип интервала данных; тип C была SQL_C_CHAR; и значение в столбце не является допустимым литералом связанного типа SQL.|  
|23000|Нарушение ограничения целостности|Аргумент *операции* SQL_DELETE или SQL_UPDATE и было нарушено ограничение целостности.|  
|24000|Недопустимое состояние курсора|*StatementHandle* находился в состоянии выполнения, но результирующий набор не связан с *StatementHandle*.<br /><br /> (DM) курсор был открыт на *StatementHandle*, но **SQLFetch** или **SQLFetchScroll** не был вызван.<br /><br /> Курсор был открыт на *StatementHandle*, и **SQLFetch** или **SQLFetchScroll** бы была вызвана, но курсор был установлен перед началом результирующего набора или после конец результирующего набора.<br /><br /> Аргумент *операции* SQL_DELETE, SQL_REFRESH или SQL_UPDATE и курсор был установлен перед началом результирующего набора, или в конце результирующего набора.|  
|40001|Сбой сериализации|Транзакции выполнен откат из-за взаимоблокировку ресурсов в другой транзакции.|  
|40003|Неизвестный завершение операторов|Сбой подключения во время выполнения этой функции и не удается определить состояние транзакции.|  
|42000|Синтаксическая ошибка или нарушение доступа|Драйверу не удалось заблокировать строки, необходимыми для выполнения данной операции в аргументе *операции*.<br /><br /> Драйверу не удалось заблокировать строки согласно запросу в аргументе *LockType*.|  
|44000|Нарушение параметра WITH CHECK OPTION|*Операции* аргумент был SQL_UPDATE и обновление было выполнено для просмотра таблицы или таблицы, производным от просматриваемого таблицу, которая была создана путем указания **WITH CHECK OPTION**, таким образом, что одна или несколько строк Затронутые обновление больше не будет в новой таблице просматриваемого.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*, и затем вызова функции еще раз на *StatementHandle*.<br /><br /> Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. При вызове функции SQLSetPos по-прежнему выполнении асинхронной функции.<br /><br /> (DM) указанного *StatementHandle* не находился в состоянии выполнения. Функция была вызвана без предварительного вызова функции **SQLExecDirect**, **SQLExecute**, или функции каталога.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для  *StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.<br /><br /> (DM) был драйвер ODBC 2. *x* драйвер, и **SQLSetPos** был вызван для *StatementHandle* после **SQLFetch** был вызван.|  
|HY011|Невозможно задать атрибут сейчас|(DM) был драйвер ODBC 2. *x* драйвера; значения SQL_ATTR_ROW_STATUS_PTR был задан атрибут инструкции; затем **SQLSetPos** был вызван перед **SQLFetch**, **SQLFetchScroll**, или **SQLExtendedFetch** был вызван.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|*Операции* аргумент был SQL_UPDATE, значение данных было указателем null и значение длины столбца не 0, значение SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE, SQL_NULL_DATA, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> *Операции* аргумент был SQL_UPDATE; значение данных не является пустым указателем; был тип данных C SQL_C_BINARY и SQL_C_CHAR; и значение длины столбца был меньше 0, но не равно в значение SQL_DATA_AT_EXEC, SQL_COLUMN_IGNORE , SQL_NTS или SQL_NULL_DATA, или меньше или равно SQL_LEN_DATA_AT_EXEC_OFFSET.<br /><br /> Значение в буфер длины/индикатора было значение SQL_DATA_AT_EXEC; тип SQL была SQL_LONGVARCHAR, SQL_LONGVARBINARY или тип данных long, определяемые источником данных; и введите сведения о SQL_NEED_LONG_DATA_LEN **SQLGetInfo** была «Y».|  
|HY092|Недопустимый атрибут идентификатора|(DM) значение, указанное для *операции* недопустимый аргумент.<br /><br /> (DM) значение, указанное для *LockType* недопустимый аргумент.<br /><br /> *Операции* аргумент было SQL_UPDATE или SQL_DELETE, а атрибута инструкции SQL_ATTR_CONCURRENCY было SQL_ATTR_CONCUR_READ_ONLY.|  
|HY107|Значение строки за пределами диапазона|Значение, указанное для аргумента *RowNumber* превышает количество строк в наборе строк.|  
|HY109|Недопустимое положение курсора|Курсор, связанный с *StatementHandle* был определен как однонаправленные, поэтому не быть позиционирован курсор в наборе строк. См. в описании атрибута SQL_ATTR_CURSOR_TYPE в **SQLSetStmtAttr**.<br /><br /> *Операции* аргумент был SQL_UPDATE, SQL_DELETE или SQL_REFRESH, и строка определяется *RowNumber* аргумент была удалена или не была получена.<br /><br /> (DM) *RowNumber* аргумент было равно 0 и *операции* аргумент был SQL_POSITION.<br /><br /> **SQLSetPos** был вызван после **SQLBulkOperations** был вызван и перед **SQLFetchScroll** или **SQLFetch** был вызван.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает операцию, запрашиваемый в *операции* аргумент или *LockType* аргумент.|  
|HYT00|Время ожидания истекло|Время ожидания запроса истекло раньше, чем источник данных вернул результирующий набор. Время ожидания задается с помощью **SQLSetStmtAttr** с *атрибута* из SQL_ATTR_QUERY_TIMEOUT.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *StatementHandle* не поддерживает функцию.|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
  
## <a name="comments"></a>Комментарии  
  
> [!CAUTION]  
>  Для сведения об операторе, указывающее, что **SQLSetPos** может быть вызвана и его нужно выполнить для обеспечения совместимости с ODBC 2 *.x* приложения, см. [блочных курсоров, Прокручиваемые курсоры и Обратная совместимость](../../../odbc/reference/appendixes/block-cursors-scrollable-cursors-and-backward-compatibility.md).  
  
## <a name="rownumber-argument"></a>Аргумент RowNumber  
 *RowNumber* аргумент указывает количество строк в наборе строк, в которой нужно выполнить операции, заданной параметром *операции* аргумент. Если *RowNumber* равно 0, операция применяется к каждой строки в наборе строк. *RowNumber* должен быть числом от 0 до количество строк в наборе строк.  
  
> [!NOTE]  
>  На языке C, массивы начинаются с нуля и *RowNumber* аргумент начинается с 1. Например, чтобы обновить пятая строка набора строк, приложение изменяет буферы строк индекса в массиве 4, но указывает *RowNumber* 5.  
  
 Все операции курсор на строки, заданной аргументом *RowNumber*. Положение курсора требуется для следующих операций:  
  
-   Располагается update и delete.  
  
-   Вызовы **SQLGetData**.  
  
-   Вызовы **SQLSetPos** параметры SQL_DELETE, SQL_REFRESH и SQL_UPDATE.  
  
 Например если *RowNumber* -2 для вызова **SQLSetPos** с *операции* из SQL_DELETE, курсор располагается на второй строке набора строк и удаляется строка. Запись в реализации массив состояния строк (ссылается атрибут инструкции значения SQL_ATTR_ROW_STATUS_PTR) во второй строке заменен на SQL_ROW_DELETED.  
  
 Приложение может указать положение курсора, при вызове **SQLSetPos**. Как правило, он вызывает **SQLSetPos** SQL_POSITION или SQL_REFRESH операции с поместите курсор перед выполнением позиционированные обновления или удаления инструкции и вызов **SQLGetData**.  
  
## <a name="operation-argument"></a>Аргумент операции  
 *Операции* аргумент поддерживает следующие операции. Чтобы определить, какие параметры поддерживаются источником данных, приложение вызывает **SQLGetInfo** SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_ Тип сведений CURSOR_ATTRIBUTES1 (в зависимости от типа курсора).  
  
|*Операция*<br /><br /> аргумент|Операция|  
|------------------------------|---------------|  
|SQL_POSITION|Драйвер помещает курсор на строки, заданной аргументом *RowNumber*.<br /><br /> Содержимое массив состояния строк, на который указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR игнорируется для SQL_POSITION *операции*.|  
|SQL_REFRESH|Драйвер помещает курсор на строки, заданной аргументом *RowNumber* и обновляет данные в буферах набора строк для этой строки. Дополнительные сведения о том, как драйвер возвращает данные в буферы строк см. в описаниях привязка на уровне строки и на уровне столбца **SQLBindCol**.<br /><br /> **SQLSetPos** с *операции* из SQL_REFRESH обновляет состояние и содержимого в пределах текущего набора строк извлеченных строк. Это включает обновление закладки. Поскольку данные в буферах обновления, но не refetched, фиксирован членство в наборе строк. Это поведение отличается от обновления, выполняется с помощью вызова **SQLFetchScroll** с *FetchOrientation* из SQL_FETCH_RELATIVE и *RowNumber* равно 0, что refetches набор строк из результирующего набора, чтобы ее отображение добавленных данных и удалить удалены данные, если эти операции поддерживаются драйвером и курсора.<br /><br /> Успешное обновление с **SQLSetPos** не изменится состояние строки SQL_ROW_DELETED. Удаленные строки в наборе строк будут продолжать будут отмечены как удаленные до следующей выборки. Строки будут появляться в следующей выборки, если курсор поддерживает упаковки (в котором последующие **SQLFetch** или **SQLFetchScroll** не возвращает удаленные строки).<br /><br /> Добавлены строки не отображаются, когда обновления с **SQLSetPos** выполняется. Это поведение отличается от **SQLFetchScroll** с *FetchType* из SQL_FETCH_RELATIVE и *RowNumber* равно 0, который также обновляет текущий набор строк, но Показать добавленных записей или пакета удаленных записей, если эти операции поддерживаются в курсор.<br /><br /> Успешное обновление с **SQLSetPos** изменится состояние строки SQL_ROW_ADDED SQL_ROW_SUCCESS (если существует массив состояния строк).<br /><br /> Успешное обновление с **SQLSetPos** изменится состояние строки SQL_ROW_UPDATED новое состояние строки (если существует массив состояния строк).<br /><br /> При возникновении ошибки в **SQLSetPos** операцию над строкой состояния имеет значение SQL_ROW_ERROR (если существует массив состояния строк).<br /><br /> В курсоре, открытом с атрибута инструкции SQL_ATTR_CONCURRENCY SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES обновления с **SQLSetPos** могут обновлять значения оптимистичного параллелизма, используемое источником данных для обнаружения, Строка была изменена. В этом случае версий строк или значения, используемые для обеспечения параллелизма курсоров обновляются каждый раз, когда буферы строк обновляются с сервера. Это происходит для каждой строки, которая обновляется.<br /><br /> Содержимое массив состояния строк, на который указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR игнорируется для SQL_REFRESH *операции*.|  
|SQL_UPDATE|Драйвер помещает курсор на строки, заданной аргументом *RowNumber* и обновление базовой строки данных со значениями в буферы строк ( *TargetValuePtr* аргумент в  **SQLBindCol**). Он извлекает длин данных из буфера длины/индикатора ( *StrLen_or_IndPtr* аргумент в **SQLBindCol**). Если длина любого столбца SQL_COLUMN_IGNORE, столбец не обновляется. После обновления строки, драйвер примет соответствующий элемент массив состояния строк SQL_ROW_UPDATED или SQL_ROW_SUCCESS_WITH_INFO (если существует массив состояния строк).<br /><br /> Это определяемые драйвером поведение — Если **SQLSetPos** с *операции* аргумент SQL_UPDATE вызывается в курсоре, который содержит повторяющиеся столбцы. Драйвер может возвращать SQLSTATE, определяемым драйвером, могут обновлять первый столбец, который отображается в результирующем наборе или выполнять другие правила поведения, определяемым драйвером.<br /><br /> Указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR массива операций строк можно использовать для указания, что строки в текущем наборе строк должны пропускаться во время массового обновления. Дополнительные сведения см. в разделе «Массивов состояния и операции» далее в этом справочнике по функциям.|  
|SQL_DELETE|Драйвер помещает курсор на строки, заданной аргументом *RowNumber* и удаляет базовой строки данных. Соответствующий элемент массив состояния строк примет значение SQL_ROW_DELETED. После удаления строки допустимы следующие значения не для строки: располагается update и delete, вызовы **SQLGetData**и вызовы **SQLSetPos** с *операции* значение, за исключением SQL_POSITION. Для драйверов, которые поддерживают упаковки строка удалена из курсора, при получении новых данных из источника данных.<br /><br /> Видна ли строка зависит от типа курсора. Например удаленные строки являются видимыми для статические и управляемые набором ключей курсоры, но невидим для динамических курсоров.<br /><br /> Указывает атрибут инструкции SQL_ATTR_ROW_OPERATION_PTR массива операций строк можно использовать для указания, что строки в текущем наборе строк должны пропускаться во время массового удаления. Дополнительные сведения см. в разделе «Массивов состояния и операции» далее в этом справочнике по функциям.|  
  
## <a name="locktype-argument"></a>Аргумент LockType  
 *LockType* аргумент предоставляет способ для приложений для управления параллелизмом. В большинстве случаев источников данных, поддерживающих уровней параллелизма и транзакций будет поддерживать только значение SQL_LOCK_NO_CHANGE *LockType* аргумент. *LockType* аргумент обычно используются только для поддержки на основе файлов.  
  
 *LockType* аргумент указывает состояние блокировки строки после **SQLSetPos** был выполнен. Если драйвер не удается заблокировать строки для выполнения запрошенной операции или для удовлетворения *LockType* аргумент, он возвращает значение SQL_ERROR и SQLSTATE 42000 (синтаксическая ошибка или нарушение доступа).  
  
 Несмотря на то что *LockType* задан аргумент для одной инструкции, блокировка accords те же права, чтобы все инструкции для подключения. В частности блокировка is, запрошенной одной инструкцией, для подключения можно разблокировать с помощью другой инструкции в том же соединении.  
  
 Заблокировать строки через **SQLSetPos** остаются заблокированными до приложение вызывает **SQLSetPos** для строки с *LockType* SQL_LOCK_UNLOCK или пока приложение вызовы **SQLFreeHandle** для инструкции или **SQLFreeStmt** с параметром SQL_CLOSE. Драйвер, который поддерживает транзакции, строки заблокирован через **SQLSetPos** не заблокирован, когда приложение вызывает **SQLEndTran** для фиксации или отката транзакции в соединении, (если курсор закрыт При фиксации или отката, как указано в SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR типов сведений, возвращаемых транзакции **SQLGetInfo**).  
  
 *LockType* аргумент поддерживает следующие типы блокировок. Чтобы определить, какие виды блокировок поддерживаются источником данных, приложение вызывает **SQLGetInfo** SQL_DYNAMIC_CURSOR_ATTRIBUTES1, SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, SQL_KEYSET_CURSOR_ATTRIBUTES1 или SQL_STATIC_ Тип сведений CURSOR_ATTRIBUTES1 (в зависимости от типа курсора).  
  
|*LockType* аргумент|Тип блокировки|  
|-------------------------|---------------|  
|SQL_LOCK_NO_CHANGE|Драйвер или источник данных гарантирует, что строка находится в том же состоянии заблокирован или разблокирован, после появления **SQLSetPos** был вызван. Это значение *LockType* позволяет источники данных, которые не поддерживают явную блокировка на уровне строк для использования требуется любые блокировки, текущие уровни изоляции параллелизма и транзакций.|  
|SQL_LOCK_EXCLUSIVE|Драйвер или источник данных исключительно блокирует строку. Инструкции для другого подключения или в другое приложение не может использоваться для блокировки на строки.|  
|SQL_LOCK_UNLOCK|Драйвер или источник данных снимает блокировку строки.|  
  
 Если драйвер поддерживает SQL_LOCK_EXCLUSIVE, но не поддерживает SQL_LOCK_UNLOCK, заблокированного строки будет оставаться заблокированным, пока не произойдет одно из вызовов функций, описанных в предыдущем абзаце.  
  
 Если драйвер поддерживает SQL_LOCK_EXCLUSIVE, но не поддерживает SQL_LOCK_UNLOCK, заблокированного строки будет оставаться заблокированным до приложение вызывает **SQLFreeHandle** для инструкции или **SQLFreeStmt** с параметр SQL_CLOSE. Если драйвер поддерживает транзакции и закрытие курсора при фиксации или отката транзакции, приложение вызывает **SQLEndTran**.  
  
 Для операций update и delete в **SQLSetPos**, приложение использует *LockType* аргумент, как показано ниже:  
  
-   Чтобы гарантировать, что строки не меняется после их получения, приложение вызывает **SQLSetPos** с *операции* значение SQL_REFRESH и *LockType* значение SQL_LOCK_ МОНОПОЛЬНАЯ.  
  
-   Если приложение установило *LockType* для SQL_LOCK_NO_CHANGE, драйвер гарантирует, операции delete или update завершится успешно только в том случае, если для атрибута инструкции SQL_ATTR_CONCURRENCY приложения указано SQL_CONCUR_LOCK.  
  
-   Если приложение указывает SQL_CONCUR_ROWVER или SQL_CONCUR_VALUES для атрибута инструкции SQL_ATTR_CONCURRENCY, драйвер сравнивает версии строк или значений и отклоняет операции, если строка была изменена, так как приложение извлечь строку.  
  
-   Если приложение указывает SQL_CONCUR_READ_ONLY для атрибута инструкции SQL_ATTR_CONCURRENCY, драйвер отклоняет любые обновления или удаления.  
  
 Дополнительные сведения о атрибута инструкции SQL_ATTR_CONCURRENCY см. в разделе [SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md).  
  
## <a name="status-and-operation-arrays"></a>Состояние и массивы операции  
 Следующие состояния и операции массивы используются при вызове **SQLSetPos**:  
  
-   Массив состояния строк (как поля SQL_DESC_ARRAY_STATUS_PTR в IRD и атрибут инструкции SQL_ATTR_ROW_STATUS_ARRAY указывает) содержит значения состояния для каждой строки данных в наборе строк. Драйвер устанавливает значения состояний в этом массиве после вызова **SQLFetch**, **SQLFetchScroll**, **SQLBulkOperations**, или **SQLSetPos** . Этот массив указывает атрибут значения SQL_ATTR_ROW_STATUS_PTR инструкции.  
  
-   Массива операций строк (как поля SQL_DESC_ARRAY_STATUS_PTR в Отменить и атрибут инструкции SQL_ATTR_ROW_OPERATION_ARRAY указывает) содержит значение для каждой строки в наборе строк, указывающее, является ли вызов **SQLSetPos**для операции массового пропущены или выполнить. Каждый элемент массива имеет значение SQL_ROW_PROCEED (по умолчанию) или SQL_ROW_IGNORE. Этот массив указывает атрибут SQL_ATTR_ROW_OPERATION_PTR инструкции.  
  
 Количество элементов в массивах состояние и операции должно быть равно числу строк в наборе строк (как определено в атрибуте SQL_ATTR_ROW_ARRAY_SIZE инструкции).  
  
 Сведения о массив состояния строк см. в разделе [SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md). Сведения о массива операций строк. в разделе «Без учета строки в операции массовой» далее в этом разделе.  
  
## <a name="using-sqlsetpos"></a>С помощью SQLSetPos  
 Прежде чем приложение вызывает **SQLSetPos**, он должен выполнить следующие действия:  
  
1.  Если приложение вызовет **SQLSetPos** с *операции* присвоено SQL_UPDATE вызов **SQLBindCol** (или **SQLSetDescRec**) для каждого столбец для указания типа данных и привязать буферы для данных и длина столбца.  
  
2.  Если приложение вызовет **SQLSetPos** с *операции* SQL_DELETE или SQL_UPDATE вызов **SQLColAttribute** для убедитесь, что столбцы для удаления или обновления могут быть обновлены.  
  
3.  Вызовите **SQLExecDirect**, **SQLExecute**, или функции каталога для создания результирующего набора.  
  
4.  Вызовите **SQLFetch** или **SQLFetchScroll** для извлечения данных.  
  
 Дополнительные сведения об использовании **SQLSetPos**, в разделе [обновление данных с помощью SQLSetPos](../../../odbc/reference/develop-app/updating-data-with-sqlsetpos.md).  
  
## <a name="deleting-data-using-sqlsetpos"></a>Удаление данных с помощью SQLSetPos  
 Для удаления данных с **SQLSetPos**, приложение вызывает **SQLSetPos** с *RowNumber* установите номер строки для удаления и *операции*значение SQL_DELETE.  
  
 После удаления данных, драйвер изменяет значение в массиве реализация строки состояния для соответствующей строки SQL_ROW_DELETED (или SQL_ROW_ERROR).  
  
## <a name="updating-data-using-sqlsetpos"></a>Обновление данных с помощью SQLSetPos  
 Приложение можно передать значение для столбца в буфере, привязанного к данным или с одного или нескольких вызовов **SQLPutData**. Столбцы, данные которого передается с **SQLPutData** известны как *данных во время выполнения* *столбцы*. Они обычно используются для отправки данных SQL_LONGVARBINARY и SQL_LONGVARCHAR столбцов и можно одновременно с другими столбцами.  
  
#### <a name="to-update-data-with-sqlsetpos-an-application"></a>Обновление данных с SQLSetPos приложения:  
  
1.  Привязать разрядов значения в буферы данных и длины/индикатора с **SQLBindCol**:  
  
    -   Для обычных столбцов приложение помещает значение столбца в  *\*TargetValuePtr* буфера и длина этого значения в  *\*StrLen_or_IndPtr* буфера. Если строка не должна быть обновлена, приложение помещает SQL_ROW_IGNORE в этой строке элемента массива операций строк.  
  
    -   Для столбцов данных времени выполнения, приложение помещает определяемые приложением значения, такие как номер столбца в  *\*TargetValuePtr* буфера. Значение может использоваться для идентификации столбца.  
  
         Приложение размещает результат SQL_LEN_DATA_AT_EXEC (*длина*) макрос в **StrLen_or_IndPtr* буфера. Если тип данных SQL столбца SQL_LONGVARBINARY, SQL_LONGVARCHAR или тип данных long, определяемые источником данных и драйвер возвращает «Y» для типа данных SQL_NEED_LONG_DATA_LEN в **SQLGetInfo**, *длина*  число байтов данных, отправляемых для параметра; в противном случае должно быть неотрицательным числом и учитывается.  
  
2.  Вызовы **SQLSetPos** с *операции* аргументу присвоено SQL_UPDATE для обновления строки данных.  
  
    -   Если отсутствуют столбцы данных времени выполнения, процесс будет завершен.  
  
    -   Если есть столбцы данных времени выполнения, функция возвращает SQL_NEED_DATA и переходит к шагу 3.  
  
3.  Вызовы **SQLParamData** для получения адреса  *\*TargetValuePtr* буфера для первого столбца данных во время выполнения для обработки. **SQLParamData** возвращает SQL_NEED_DATA. Приложение извлекает определяемые приложением значения из  *\*TargetValuePtr* буфера.  
  
    > [!NOTE]  
    >  Несмотря на то, что параметры с данными времени выполнения аналогичны столбцов данных времени выполнения, значение, возвращаемое **SQLParamData** отличается для каждого.  
  
    > [!NOTE]  
    >  Параметры данных времени выполнения являются параметрами в инструкции SQL, для которого данные будут отправлены с **SQLPutData** при выполнении инструкции с **SQLExecDirect** или **SQLExecute**. Они связаны с **SQLBindParameter** или установив дескрипторы с **SQLSetDescRec**. Значение, возвращаемое **SQLParamData** является 32-разрядное значение, передаваемое **SQLBindParameter** в *ParameterValuePtr* аргумент.  
  
    > [!NOTE]  
    >  Столбцы данных времени выполнения являются столбцами в наборе строк, для которого данные будут отправлены с **SQLPutData** при обновлении строки с **SQLSetPos**. Они связаны с **SQLBindCol**. Значение, возвращаемое **SQLParamData** адрес строки в **TargetValuePtr* буфера, который обрабатывается.  
  
4.  Вызовы **SQLPutData** один или несколько раз для отправки данных для столбца. Более одного вызова необходим в том случае, если все значения данных не может быть возвращен в  *\*TargetValuePtr* буфера, указанный в **SQLPutData**; несколько вызовов **SQLPutData** для того же столбца разрешены только в том случае, при отправке данных символ C для столбца с типом данных, определяемые источником символьных, двоичных и данных или при отправке двоичных данных C для столбца с символом, двоичных данных, либо тип данных, определяемые источником данных.  
  
5.  Вызовы **SQLParamData** еще раз, чтобы сообщить, что все данные были переданы для столбца.  
  
    -   Если есть дополнительные столбцы данных времени выполнения, **SQLParamData** возвращает SQL_NEED_DATA и адрес *TargetValuePtr* буфер для следующего столбца данных во время выполнения для обработки. Приложение повторяет шаги 4 и 5.  
  
    -   Если больше нет столбцов данных времени выполнения, процесс будет завершен. Если инструкция была выполнена успешно, **SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO; Если выполнение завершилось неудачей, он возвращает значение SQL_ERROR. На этом этапе **SQLParamData** может возвращать любой SQLSTATE, которые могут быть возвращены с **SQLSetPos**.  
  
 Если данные обновлены, драйвер изменяет значение в массиве реализация строки состояния для соответствующей строки на SQL_ROW_UPDATED.  
  
 Если операция отменена, или произошла ошибка в **SQLParamData** или **SQLPutData**после того, как **SQLSetPos** возвращает SQL_NEED_DATA и перед отправкой данных для всех столбцы данных времени выполнения, приложение может вызвать только **SQLCancel**, **SQLGetDiagField**, **SQLGetDiagRec**, **SQLGetFunctions** , **SQLParamData**, или **SQLPutData** для инструкции или соединения, связанные с инструкцией. Если он вызывает любой другой функции для инструкции или соединения, связанные с инструкцией, функция возвращает значение SQL_ERROR и SQLSTATE HY010 (функция ошибка последовательности).  
  
 Если приложение вызывает **SQLCancel** пока драйвер по-прежнему требуются данные для столбцов данных времени выполнения, драйвер отменяет операцию. Затем приложение может вызвать **SQLSetPos** попытку; Отмена не влияет на состояние курсора или текущей позиции курсора.  
  
 Если список ВЫБОРА спецификация запроса, связанный с курсором содержит более одной ссылки в том же столбце, формируется сообщение об ошибке или драйвер не учитывает повторяющиеся ссылки и выполняет запрошенных операций, определяемым драйвером.  
  
## <a name="performing-bulk-operations"></a>Выполнение операций массового  
 Если *RowNumber* аргумент равен 0, драйвер выполняет операцию, указанную в *операции* аргумент для каждой строки в наборе строк, имеющего значение SQL_ROW_PROCEED в поле в строке операции Массив, на который указывает атрибут SQL_ATTR_ROW_OPERATION_PTR инструкции. Это является допустимым значением для *RowNumber* аргумент для *операции* аргумент SQL_DELETE, SQL_REFRESH, или SQL_UPDATE, но не SQL_POSITION. **SQLSetPos** с *операции* из SQL_POSITION и *RowNumber* возвращает SQLSTATE HY109, равным 0 (Недопустимое положение курсора).  
  
 При возникновении ошибки, относящиеся к всего строк, таких как SQLSTATE HYT00 (превышено время ожидания), драйвер возвращает значение SQL_ERROR и соответствующий код SQLSTATE. Содержимое набора строк буфера не определено, и позиция курсора не меняется.  
  
 При возникновении ошибки, относящиеся к одной строки, драйвер:  
  
-   Задает элемент для строки в массив состояния строк, ссылается атрибут инструкции sql_attr_row_status_ptr, которое указывает на SQL_ROW_ERROR.  
  
-   Отправляет в очередь ошибок один или несколько дополнительных SQLSTATE для ошибки и устанавливает для поля SQL_DIAG_ROW_NUMBER в структуре диагностических данных.  
  
 После обработки ошибки или предупреждения, если драйвер завершает операцию для оставшихся строк в наборе строк, он возвращает значение SQL_SUCCESS_WITH_INFO. Таким образом для каждой строки, возвращена ошибка, ошибка очереди содержит ноль или более дополнительных SQLSTATE. Если драйвер Останавливает операцию, после обработки ошибки или предупреждения, он возвращает значение SQL_ERROR.  
  
 Если драйвер возвращает все предупреждения, такие как SQLSTATE 01004 (данных), он возвращает предупреждения, которые применяются для всего набора строк или неизвестный строк в наборе строк, перед тем как возвратить сведения об ошибке, который применяется в определенных строках. Он возвращает предупреждения для определенных строк, а также любые другие сведения об ошибках для этих строк.  
  
 Если *RowNumber* равен 0 и *операции* SQL_UPDATE, SQL_REFRESH или SQL_DELETE, количество строк, которые **SQLSetPos** работает на нее указывает которое Атрибут _FETCHED_PTR инструкции.  
  
 Если *RowNumber* равен 0 и *операции* SQL_DELETE, SQL_REFRESH или SQL_UPDATE текущей строки после операции совпадает со значением текущей строки перед выполнением операции.  
  
## <a name="ignoring-a-row-in-a-bulk-operation"></a>Пропуск строк при помощи массовой операции  
 Можно использовать для указания, что строки в текущем наборе строк должны пропускаться во время массовой операции с помощью массива операций строк **SQLSetPos**. Чтобы направить драйверу пропустить одну или несколько строк во время массовой операции, приложение должно выполните следующие действия:  
  
1.  Вызовите **SQLSetStmtAttr** присвоить атрибут SQL_ATTR_ROW_OPERATION_PTR инструкции, чтобы она указывала на массив SQLUSMALLINTs. Это поле также можно задать путем вызова **SQLSetDescField** присвоить полю заголовка SQL_DESC_ARRAY_STATUS_PTR Отменить, которая требует, что приложение получает дескриптор.  
  
2.  Каждый элемент массива операций строк задайте одно из двух значений:  
  
    -   SQL_ROW_IGNORE для указания исключить строки для массовой операции.  
  
    -   SQL_ROW_PROCEED для указания, что строки будут включены в массовой операции. (Это значение по умолчанию.)  
  
3.  Вызовите **SQLSetPos** для выполнения массовой операции.  
  
 Для массива операций строк применяются следующие правила:  
  
-   SQL_ROW_IGNORE и SQL_ROW_PROCEED влияют на массовые операции, с использованием **SQLSetPos** с *операции* SQL_DELETE или SQL_UPDATE. Они не влияют на вызовы **SQLSetPos** с *операции* SQL_REFRESH или SQL_POSITION.  
  
-   Указатель устанавливается в значение null по умолчанию.  
  
-   Если указатель имеет значение null, как если бы все элементы, заданные для SQL_ROW_PROCEED обновляются все строки.  
  
-   Установка элемента SQL_ROW_PROCEED не гарантирует, что операция будет выполняться на определенной строки. Например если некоторые строки в наборе строк имеет статус SQL_ROW_ERROR, драйвер не можно для обновления этой строки, независимо от приложения SQL_ROW_PROCEED. Приложения всегда необходимо проверить массив состояния строк, чтобы увидеть, является ли операция выполнена успешно.  
  
-   SQL_ROW_PROCEED определяется как "0" в файле заголовка. Приложение может инициализировать массива операций строк на 0 для обработки всех строк.  
  
-   Если номер элемента «n» в массива операций строк равно SQL_ROW_IGNORE и **SQLSetPos** вызывается для выполнения массового обновления или удаления, n-й строки в наборе строк остаются без изменений после вызова **SQLSetPos**.  
  
-   Приложение должно автоматически присваивается только для чтения столбец SQL_ROW_IGNORE.  
  
## <a name="ignoring-a-column-in-a-bulk-operation"></a>Пропуск столбцов при помощи массовой операции  
 Чтобы избежать лишней обработки диагностики, созданные попытки обновления одного или нескольких столбцов, только для чтения, приложение может установить значение SQL_COLUMN_IGNORE буфера привязанного длины/индикатора. Дополнительные сведения см. в разделе [SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md).  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение позволяет пользователю просматривать в таблице ORDERS и обновления состояния заказа. Курсор, управляемые набором ключей с размером набора строк, равным 20 и использует управление оптимистичным параллелизмом, сравнение версий строк. После каждого набора строк извлекается, приложение выводит ее и позволяет пользователю выбрать и обновить состояние заказа. Приложение использует **SQLSetPos** для позиционирования курсора на выбранной строки и выполняет позиционированного обновления строки. (Для ясности опущена обработка ошибок.)  
  
```  
#define ROWS 20  
#define STATUS_LEN 6  
  
SQLCHAR        szStatus[ROWS][STATUS_LEN], szReply[3];  
SQLINTEGER     cbStatus[ROWS], cbOrderID;  
SQLUSMALLINT   rgfRowStatus[ROWS];  
SQLUINTEGER    sOrderID, crow = ROWS, irow;  
SQLHSTMT       hstmtS, hstmtU;  
  
SQLSetStmtAttr(hstmtS, SQL_ATTR_CONCURRENCY, (SQLPOINTER) SQL_CONCUR_ROWVER, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_CURSOR_TYPE, (SQLPOINTER) SQL_CURSOR_KEYSET_DRIVEN, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_ROW_ARRAY_SIZE, (SQLPOINTER) ROWS, 0);  
SQLSetStmtAttr(hstmtS, SQL_ATTR_ROW_STATUS_PTR, (SQLPOINTER) rgfRowStatus, 0);  
SQLSetCursorName(hstmtS, "C1", SQL_NTS);  
SQLExecDirect(hstmtS, "SELECT ORDERID, STATUS FROM ORDERS ", SQL_NTS);  
  
SQLBindCol(hstmtS, 1, SQL_C_ULONG, &sOrderID, 0, &cbOrderID);  
SQLBindCol(hstmtS, 2, SQL_C_CHAR, szStatus, STATUS_LEN, &cbStatus);  
  
while ((retcode == SQLFetchScroll(hstmtS, SQL_FETCH_NEXT, 0)) != SQL_ERROR) {  
   if (retcode == SQL_NO_DATA_FOUND)  
      break;  
   for (irow = 0; irow < crow; irow++) {  
      if (rgfRowStatus[irow] != SQL_ROW_DELETED)  
         printf("%2d %5d %*s\n", irow+1, sOrderID, NAME_LEN-1, szStatus[irow]);  
   }  
   while (TRUE) {  
      printf("\nRow number to update?");  
      gets_s(szReply, 3);  
      irow = atoi(szReply);  
      if (irow > 0 && irow <= crow) {  
         printf("\nNew status?");  
         gets_s(szStatus[irow-1], (ROWS * STATUS_LEN));  
         SQLSetPos(hstmtS, irow, SQL_POSITION, SQL_LOCK_NO_CHANGE);  
         SQLPrepare(hstmtU,  
          "UPDATE ORDERS SET STATUS=? WHERE CURRENT OF C1", SQL_NTS);  
         SQLBindParameter(hstmtU, 1, SQL_PARAM_INPUT,  
            SQL_C_CHAR, SQL_CHAR,  
            STATUS_LEN, 0, szStatus[irow], 0, NULL);  
         SQLExecute(hstmtU);  
      } else if (irow == 0) {  
         break;  
      }  
   }  
}  
```  
  
 Дополнительные примеры см. в разделе [располагается обновление и удаление операторов](../../../odbc/reference/develop-app/positioned-update-and-delete-statements.md) и [обновление строк в наборе строк с SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md).  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Привязка к столбцу в результирующем наборе буфера|[Функция SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнения массовых операций, которые не связаны с позицией курсора блока|[Функция SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки инструкции|[Функция SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выборка блока данных или прокрутке результирующего набора|[Функция SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Получение одного поля дескриптора|[Функция SQLGetDescField](../../../odbc/reference/syntax/sqlgetdescfield-function.md)|  
|Получение нескольких полей дескриптора|[Функция SQLGetDescRec](../../../odbc/reference/syntax/sqlgetdescrec-function.md)|  
|Настройка одного поля дескриптора|[Функция SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
|Задание нескольких полей дескриптора|[Функция SQLSetDescRec](../../../odbc/reference/syntax/sqlsetdescrec-function.md)|  
|С помощью атрибута инструкции|[Функция SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md)|  
  
## <a name="see-also"></a>См. также  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовков ODBC](../../../odbc/reference/install/odbc-header-files.md)
