---
title: "Функция SQLEndTran | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: reference
ms.reviewer: 
ms.suite: sql
ms.technology: drivers
ms.tgt_pltfrm: 
ms.topic: article
apiname: SQLEndTran
apilocation: sqlsrv32.dll
apitype: dllExport
f1_keywords: SQLEndTran
helpviewer_keywords: SQLEndTran function [ODBC]
ms.assetid: ff375ce1-eb50-4693-b1e6-70181a6dbf9f
caps.latest.revision: "29"
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: Inactive
ms.openlocfilehash: c85e1102eb259f9ab1df342ab2ca0402fd68fa73
ms.sourcegitcommit: 7f8aebc72e7d0c8cff3990865c9f1316996a67d5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2017
---
# <a name="sqlendtran-function"></a>Функция SQLEndTran
**Соответствия**  
 Появился в версии: ODBC 3.0 нормативных требований: ISO-92  
  
 **Сводка**  
 **SQLEndTran** запрашивает операции фиксации или отката для всех активных операций для всех инструкций, ассоциированные с соединением. **SQLEndTran** можно также запросить выполнение операции фиксации или отката для всех подключений, связанный со средой.  
  
> [!NOTE]  
>  Дополнительные сведения о какой диспетчера драйверов преобразует эту функцию для при ODBC 3. *x* при работе с ODBC 2. *x* драйвера, в разделе [сопоставление замены функций для обеспечения обратной совместимости приложений](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLEndTran(  
     SQLSMALLINT   HandleType,  
     SQLHANDLE     Handle,  
     SQLSMALLINT   CompletionType);  
```  
  
## <a name="arguments"></a>Аргументы  
 *HandleType*  
 [Вход] Идентификатор дескриптора типа. Содержит либо SQL_HANDLE_ENV (если *обработки* является дескриптор среды) или SQL_HANDLE_DBC (если *обработки* представляет собой дескриптор соединения).  
  
 *Дескриптор*  
 [Вход] Дескриптор типа, указанного *HandleType*, указывающее область транзакции. Дополнительные сведения в разделе «Комментарии».  
  
 *CompletionType*  
 [Вход] Одно из следующих двух значений:  
  
 ПАРАМЕТРОМ SQL_COMMIT SQL_ROLLBACK  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR, SQL_INVALID_HANDLE или SQL_STILL_EXECUTING.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLEndTran** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с соответствующими *HandleType*и *обработки*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLEndTran** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|08003|Соединение не открыто|(DM) *HandleType* был SQL_HANDLE_DBC и *обработки* не находился в подключенном состоянии.|  
|08007|Сбой подключения во время транзакции.|*HandleType* был SQL_HANDLE_DBC, и соединение, связанный с *обработки* произошла ошибка при выполнении функции и не может быть определено ли запрошенный  **ЗАФИКСИРОВАТЬ** или **ОТКАТА** произошло до сбоя.|  
|25S01|Состояние транзакции неизвестно|Один или несколько соединений в *обработки* не удалось завершить транзакцию с результатом указано, и результат выполнения неизвестен.|  
|25S02|Транзакция все еще активна|Драйвер не может гарантировать, что атомарным образом удалось выполнить все действия в глобальную транзакцию, и транзакция все еще активна.|  
|25S03|Откат транзакции|Драйвер не может гарантировать, что атомарным образом удалось выполнить все действия в глобальную транзакцию, и все работы в транзакции, активной в *обработки* был выполнен откат.|  
|40001|Сбой сериализации|Транзакции выполнен откат из-за взаимоблокировку ресурсов в другой транзакции.|  
|40002|Нарушение ограничения целостности|*CompletionType* был параметром SQL_COMMIT и фиксации изменений, вызвавшим нарушение ограничения целостности. В результате выполнен откат транзакции.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в  *\*szMessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *ConnectionHandle*. Функция был вызван, и до завершения выполнения [функция SQLCancelHandle](../../../odbc/reference/syntax/sqlcancelhandle-function.md) был вызван для *ConnectionHandle*. Затем функция была вызвана снова на *ConnectionHandle*.<br /><br /> Функция был вызван, и до завершения выполнения **SQLCancelHandle** был вызван для *ConnectionHandle* из другого потока в многопоточных приложениях.|  
|HY010|Ошибка последовательности функций|(DM) был вызван асинхронно выполняемой функции для дескриптора инструкции, связанные с *ConnectionHandle* и еще выполнялась при **SQLEndTran** был вызван.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *ConnectionHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для дескриптора инструкции, связанные с *ConnectionHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *обработки* с *HandleType* значение SQL_HANDLE_DBC и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, или **SQLMoreResults** был вызван для одного из дескрипторов инструкций, связанных с *обработки* и Возвращаемый SQL_PARAM_DATA_AVAILABLE. До получения данных для всех параметров потоковой вызове этой функции.|  
|HY012|Недопустимый код операции транзакции|(DM) значение, указанное для аргумента *CompletionType* ни параметром SQL_COMMIT или SQL_ROLLBACK.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY092|Недопустимый атрибут идентификатор или параметра|(DM) значение, указанное для аргумента *HandleType* был SQL_HANDLE_ENV, ни SQL_HANDLE_DBC.|  
|HY115|SQLEndTran не разрешена для среду, которая содержит соединение с выполнением асинхронных функция включена|(DM) *HandleType* нельзя присвоить значение SQL_HANDLE_ENV, если включены асинхронное выполнение функции подключения для соединения в среде.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки, см. в разделе "Примечания" в этом разделе.|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает **ОТКАТА** операции.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|Драйвер (DM), связанные с *ConnectionHandle* не поддерживает функцию.|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
  
## <a name="comments"></a>Комментарии  
 Для ODBC 3. *x* драйвера, если *HandleType* — SQL_HANDLE_ENV и *обработки* является дескриптором допустимое окружение, а затем вызывает диспетчер драйверов **SQLEndTran**в каждый драйвер, связанное с данной средой. *Обработки* аргумент для вызова драйвер будет драйвера дескриптор среды. Для ODBC 2. *x* драйвера, если *HandleType* — SQL_HANDLE_ENV и *обработки* является дескриптором допустимое окружение и несколько подключений в подключенном состоянии в этой среде затем диспетчер драйверов вызывает **SQLTransact** в драйвере один раз для каждого соединения в подключенном состоянии в этой среде. *Обработки* аргумент в каждом вызове будет дескриптора соединения. В любом случае драйвер попытается выполнить фиксацию или откат транзакции, в зависимости от значения *CompletionType*, для всех подключений, которые находятся в подключенном состоянии в этой среде. Неактивные соединения не воздействовать на транзакцию.  
  
> [!NOTE]  
>  **SQLEndTran** не может использоваться для фиксации или отката транзакции в общей среде. SQLSTATE (равным hy092) (идентификатор недопустимый атрибута или параметра), будет возвращено в том случае, если **SQLEndTran** вызывается с *обработки* дескриптор среде с общим доступом или дескриптор подключения на общий Среда.  
  
 Диспетчер драйверов возвращает SQL_SUCCESS только в том случае, если он получает SQL_SUCCESS для каждого соединения. Если диспетчер драйверов получает значение SQL_ERROR на одно или несколько соединений, возвращает значение SQL_ERROR в приложение и диагностических сведений помещается в структуре диагностических данных в среде. Чтобы определить, какие соединения или соединения, сбой во время операции фиксации или отката, приложение может вызвать **SQLGetDiagRec** для каждого соединения.  
  
> [!NOTE]  
>  Диспетчер драйверов не имитировать глобальные транзакции через все подключения и поэтому не использует протоколы двухфазной фиксации.  
  
 Если *CompletionType* является параметром SQL_COMMIT, **SQLEndTran** выдает запрос на фиксацию для всех активных операций для любой инструкции, связанные с соединение уязвимой. Если *CompletionType* — SQL_ROLLBACK, **SQLEndTran** выдает запрос отката для всех активных операций для любой инструкции, связанные с соединение уязвимой. Если транзакции не являются активными, **SQLEndTran** возвращает SQL_SUCCESS не оказывает влияния на источников данных. Дополнительные сведения см. в разделе [Committing и отката транзакций](../../../odbc/reference/develop-app/committing-and-rolling-back-transactions.md).  
  
 Если драйвер находится в режиме ручной фиксации (путем вызова **SQLSetConnectAttr** атрибута набор SQL_ATTR_AUTOCOMMIT равным SQL_AUTOCOMMIT_OFF), новая транзакция неявно начинается, когда инструкция SQL, содержащиеся в транзакция выполняется в текущем источнике данных. Дополнительные сведения см. в разделе [режим фиксации](../../../odbc/reference/develop-app/commit-mode.md).  
  
 Чтобы определить влияние операций транзакций на курсоры, приложение вызывает **SQLGetInfo** параметры SQL_CURSOR_ROLLBACK_BEHAVIOR и SQL_CURSOR_COMMIT_BEHAVIOR. Дополнительные сведения см. в разделе ниже, а также просмотреть [влияние транзакций на курсоры и подготовленных инструкций](../../../odbc/reference/develop-app/effect-of-transactions-on-cursors-and-prepared-statements.md).  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR — SQL_CB_DELETE, **SQLEndTran** закрывает и удаляет все открытые курсоры во все отчеты, связанные с подключением и отменяет все ожидающие результаты. **SQLEndTran** оставляет любая инструкция, в выделенное состояние (неподготовленных); приложения можно повторно использовать их для последующих запросов SQL или вызвать **SQLFreeStmt** или **SQLFreeHandle** с *HandleType* значение sql_handle_stmt для их освобождения.  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR — SQL_CB_CLOSE, **SQLEndTran** закрывает все открытые курсоры для всех инструкций, связанный с подключением. **SQLEndTran** оставляет любая инструкция, присутствующих в подготовленном состоянии; приложение может вызвать **SQLExecute** для инструкции, связанные с подключением, без предварительного вызова функции **SQLPrepare** .  
  
 Если значение SQL_CURSOR_ROLLBACK_BEHAVIOR или SQL_CURSOR_COMMIT_BEHAVIOR — SQL_CB_PRESERVE, **SQLEndTran** не влияет на открытые курсоры, связанные с подключением. Курсоры остаются в строке, они, на который указывает до вызова **SQLEndTran**.  
  
 Для драйверов и источников данных, поддерживающие транзакции, вызвав **SQLEndTran** с параметром SQL_COMMIT или SQL_ROLLBACK при активной транзакции не возвращает SQL_SUCCESS (это означает, что нет заданий для быть фиксации или отката) и не оказывает влияния на источнике данных.  
  
 Если драйвер находится в режиме автоматической фиксации, диспетчер драйверов не вызывает **SQLEndTran** в драйвере. **SQLEndTran** всегда возвращает значение SQL_SUCCESS независимо от того, является ли он вызывается с *CompletionType* параметром SQL_COMMIT или SQL_ROLLBACK.  
  
 Драйверы или источников данных, не поддерживающие транзакции (**SQLGetInfo** *параметр* SQL_TXN_CAPABLE — SQL_TC_NONE) эффективно всегда находятся в режиме автоматической фиксации, поэтому всегда возвращает значение SQL_SUCCESS для **SQLEndTran** ли они вызываются с *CompletionType* параметром SQL_COMMIT или SQL_ROLLBACK. Такие драйверы и источники данных не выполнять откат фактически транзакции при запросе на это.  
  
## <a name="suspended-state"></a>Приостановленное состояние  
 В диспетчере драйвера, выпущенных до Windows 7, транзакция была активна при **SQLEndTran** возвращает значение SQL_ERROR в драйвере. Тем не менее можно было были успешно транзакции на сервере, что драйвер на клиенте не имели были уведомлены (например, из-за сетевой ошибки). Соединения будут выполняться в неверном состоянии. Начиная с Windows 7, когда **SQLEndTran** возвращает значение SQL_ERROR, соединение может быть в состоянии приостановки. В приостановленном состоянии можно вызывать функции только для чтения. В конечном счете, приложение должно вызывать **SQLDisconnect** для приостановленного соединения для освобождения ресурсов.  
  
 Если выполняются все следующие условия, соединение будет помещен в приостановленном состоянии:  
  
-   Драйвер возвращает значение SQL_ERROR из **SQLEndTran**.  
  
-   Драйвер не ODBC 3.8 или более поздней версии.  
  
-   Версия приложения 3.8 или более поздней версии; или перекомпилированной приложение ODBC 2.x и 3.x успешно отменяет **SQLEndTran** работать через **SQLCancelHandle**.  
  
-   Драйвер не возвращать одно из следующих сообщений, которые убедитесь, что транзакция не завершена.  
  
    -   25S03: выполняется откат транзакции  
  
    -   40001: Сбой сериализации  
  
    -   40002: ограничение целостности  
  
    -   HYC00: Дополнительная возможность не реализована  
  
 Если **SQLEndTran** был вызван в среде обработки и одного из подключений выполнены описанных выше условиях, все подключения, подключение к один драйвер будет помещен в приостановленном состоянии.  
  
 После приложение вызывает **SQLDisconnect** приостановленной соединения, соединение можно использовать для повторного подключения к источникам данных или тот же источник данных.  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Отмена функции работающего асинхронно на дескриптор соединения.|[Функция SQLCancelHandle](../../../odbc/reference/syntax/sqlcancelhandle-function.md)|  
|Возврат сведений о драйверу или источнику данных|[Функция SQLGetInfo](../../../odbc/reference/syntax/sqlgetinfo-function.md)|  
|Освобождение дескриптора|[Функция SQLFreeHandle](../../../odbc/reference/syntax/sqlfreehandle-function.md)|  
|Освобождение дескриптора инструкции|[Функция SQLFreeStmt](../../../odbc/reference/syntax/sqlfreestmt-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Асинхронное выполнение (метод опроса)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md)
