---
title: "Функция SQLGetData | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- drivers
ms.tgt_pltfrm: 
ms.topic: article
apiname:
- SQLGetData
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetData
helpviewer_keywords:
- SQLGetData function [ODBC]
ms.assetid: e3c1356a-5db7-4186-85fd-8b74633317e8
caps.latest.revision: 46
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.translationtype: MT
ms.sourcegitcommit: f7e6274d77a9cdd4de6cbcaef559ca99f77b3608
ms.openlocfilehash: 463a6b68149786cd9cc14ca913e3a2b2104a59e9
ms.contentlocale: ru-ru
ms.lasthandoff: 09/09/2017

---
# <a name="sqlgetdata-function"></a>Функция SQLGetData
**Соответствия**  
 Появился в версии: Полное соответствие стандартам 1.0 ODBC: ISO-92  
  
 **Сводка**  
 **SQLGetData** извлекает данные для одного столбца в результирующем наборе, или для одного параметра после **SQLParamData** возвращает SQL_PARAM_DATA_AVAILABLE. Он может быть вызван несколько раз для получения данных переменной длины в части.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
SQLRETURN SQLGetData(  
      SQLHSTMT       StatementHandle,  
      SQLUSMALLINT   Col_or_Param_Num,  
      SQLSMALLINT    TargetType,  
      SQLPOINTER     TargetValuePtr,  
      SQLLEN         BufferLength,  
      SQLLEN *       StrLen_or_IndPtr);  
```  
  
## <a name="arguments"></a>Аргументы  
 *StatementHandle*  
 [Вход] Дескриптор инструкции.  
  
 *Col_or_Param_Num*  
 [Вход] Для получения данных столбца, это номер столбца, для которого возвращаются данные. Столбцы результирующего набора нумеруются в порядке возрастания столбца, начиная с 1. Столбец закладок является столбцом номер 0; Это может быть указан, если включены закладки.  
  
 Для получения данных параметра, это порядковый номер параметра, который начинается с 1.  
  
 *TargetType*  
 [Вход] Идентификатор типа для типа данных C **TargetValuePtr* буфера. Список допустимых типов данных C и идентификаторы типов см. в разделе [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) раздел в типах данных приложение D:.  
  
 Если *TargetType* — SQL_ARD_TYPE, то драйвер использует идентификатор типа, указанного в поле SQL_DESC_CONCISE_TYPE Отменить. Если *TargetType* — SQL_APD_TYPE, **SQLGetData** будет использовать тот же тип данных C, который был указан в **SQLBindParameter**. В противном случае тип данных C, указанный в **SQLGetData** переопределения типа данных C в **SQLBindParameter**. Если SQL_C_DEFAULT, драйвер выбирает тип данных C по умолчанию, в зависимости от типа источника данных SQL.  
  
 Можно также указать расширенный тип данных C. Дополнительные сведения см. в разделе [типы данных C в ODBC](../../../odbc/reference/develop-app/c-data-types-in-odbc.md).  
  
 *TargetValuePtr*  
 [Выход] Указатель на буфер, в котором для возвращения данных.  
  
 *TargetValuePtr* не может иметь значение NULL.  
  
 *BufferLength*  
 [Вход] Длина **TargetValuePtr* буфера в байтах.  
  
 Драйвер использует *BufferLength* во избежание записи за пределами \* *TargetValuePtr* буфера при возврате данных переменной длины, например символьных или двоичных данных. Обратите внимание, что драйвер считается знак завершения null при возврате символьных данных \* *TargetValuePtr*. **TargetValuePtr* таким образом должна содержать место для символа конечное значение null, или драйвер будет выполнять усечение данных.  
  
 Когда драйвер возвращает данных фиксированной длины, например целое число или структура даты, драйвер пропускает *BufferLength* и предполагает буфер недостаточно велик для хранения данных. Поэтому важно для приложения, чтобы выделить достаточно большого размера буфера для данных фиксированной длины или драйвер будет записывать после конца буфера.  
  
 **SQLGetData** возвращает SQLSTATE HY090 (Недопустимая длина строки или буфера) при *BufferLength* имеет меньше 0 но не в том случае, когда *BufferLength* — 0.  
  
 *StrLen_or_IndPtr*  
 [Выход] Указатель на буфер, в котором для возвращения значения длины или индикатора. Если это является указателем null, возвращаемое значение длины или индикатора отсутствует. Возвращает сообщение об ошибке, при извлечении данных имеет значение NULL.  
  
 **SQLGetData** может возвращать следующие значения в буфер длины/индикатора:  
  
-   Длина данных, доступных для возврата  
  
-   SQL_NO_TOTAL  
  
-   SQL_NULL_DATA  
  
 Дополнительные сведения см. в разделе [использование значения длины/индикатора](../../../odbc/reference/develop-app/using-length-and-indicator-values.md) и «Комментарии» этого раздела.  
  
## <a name="returns"></a>Возвращает  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA, SQL_STILL_EXECUTING, значение SQL_ERROR или SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Диагностика  
 Когда **SQLGetData** возвращает значение SQL_ERROR или SQL_SUCCESS_WITH_INFO, соответствующее значение SQLSTATE можно получить, вызвав **SQLGetDiagRec** с *HandleType* из Значение SQL_HANDLE_STMT и *обработки* из *StatementHandle*. В следующей таблице перечислены значения SQLSTATE, обычно возвращаемые **SQLGetData** и описание каждого из них в контексте этой функции; нотации «(DM)» предшествует описания SQLSTATE, возвращаемых диспетчером драйверов. Код возврата, связанные с каждым из значений SQLSTATE — это SQL_ERROR, если не указано иное.  
  
|SQLSTATE|Ошибка|Description|  
|--------------|-----------|-----------------|  
|01000|Общее предупреждение|Информационное сообщение, относящиеся к драйверу. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|01004|Строка справа усечение данных|Не все данные для указанного столбца *Col_or_Param_Num*, может быть получен в рамках одного вызова функции. SQL_NO_TOTAL или длину данных, оставшихся в указанном столбце до текущего вызова к **SQLGetData** возвращается в \* *StrLen_or_IndPtr*. (Функция возвращает значение SQL_SUCCESS_WITH_INFO).<br /><br /> Дополнительные сведения об использовании нескольких вызовов **SQLGetData** один столбец, в разделе «Комментарии».|  
|01S07|Частичное усечение|Данные, возвращаемые для одного или нескольких столбцов были усечены. Для числовых типов данных был усечен, дробная часть числа. Время, отметка времени и интервальных типов данных, содержащего компонент времени дробная часть времени было усечено.<br /><br /> (Функция возвращает значение SQL_SUCCESS_WITH_INFO).|  
|07006|Нарушение атрибута ограниченного типа данных|Значение столбца в результирующем наборе невозможно преобразовать в тип данных C, указанного аргументом *TargetType*.|  
|07009|Недопустимый индекс дескриптора|Значение, указанное для аргумента *Col_or_Param_Num* было равно 0, и атрибут инструкции SQL_ATTR_USE_BOOKMARKS задано значение SQL_UB_OFF.<br /><br /> Значение, указанное для аргумента *Col_or_Param_Num* превышает количество столбцов в результирующем наборе.<br /><br /> *Col_or_Param_Num* значение не равно порядковый номер параметра, который доступен.<br /><br /> (DM) был привязан указанного столбца. Это описание не применяется к драйверам, которые возвращают SQL_GD_BOUND битовой маски для параметра SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> (DM) указанного столбца было меньше или равно числу наибольший привязанного столбца. Это описание не применяется к драйверам, которые возвращают SQL_GD_ANY_COLUMN битовой маски для параметра SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> (DM) приложение уже вызван **SQLGetData** для текущей строки; номер столбца, указанного в текущем вызове был меньше, чем номер столбца, указанного в предыдущем вызове; и драйвер не возвращает SQL_ Битовая маска GD_ANY_ORDER для параметра SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> (DM) *TargetType* аргумент был SQL_ARD_TYPE и *Col_or_Param_Num* записи дескриптора в Отменить не удалось выполнить проверку согласованности.<br /><br /> (DM) *TargetType* аргумент было SQL_ARD_TYPE, а значение в поле SQL_DESC_COUNT Отменить было меньше, чем *Col_or_Param_Num* аргумент.|  
|08S01|Сбой связи|Сбой в канале связи между драйвером и источника данных, к которому был подключен драйвер перед обработкой функции было завершено.|  
|22002|Индикатор обязательным, но не указано|*StrLen_or_IndPtr* является пустым указателем и получения данных значение NULL.|  
|22003|Численное значение вне допустимого диапазона|Возвращает числовое значение (как числовое или строковое) для столбца могло привести целиком (в отличие от доли) часть усекаемое число.<br /><br /> Дополнительные сведения см. в разделе [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22007|Формат недопустимые даты и времени|Символьный столбец в результирующем наборе был привязан к C даты, времени или структура отметки времени, а значение в столбце было неверной даты, времени или timestamp, соответственно. Дополнительные сведения см. в разделе [типы данных приложение D:](../../../odbc/reference/appendixes/appendix-d-data-types.md).|  
|22012|Деление на ноль|Возвращено значение на основе арифметического выражения, полученное при делении на ноль.|  
|22015|Переполнение поля интервала|Присвоение тип интервала C из точное числовое значение или интервал тип SQL привело к потере значащих разрядов в начале поля.<br /><br /> При возврате данных тип интервала C, возникла не представление значения в тип интервала C типа SQL.|  
|22018|Недопустимое символьное значение для спецификации приведения|Символьный столбец в результирующем наборе было возвращено в буфер символов C, а столбец содержится символ, для которого отсутствует в наборе символов буфера не представление.<br /><br /> Тип C был точное или Приблизительное числовое, datetime или тип интервала; тип SQL столбца был в символьный тип данных; и значение в столбце не является допустимым литералом связанного типа C.|  
|24000|Недопустимое состояние курсора|(DM), функция была вызвана без предварительного вызова функции **SQLFetch** или **SQLFetchScroll** для позиционирования курсора данные, необходимые в строке.<br /><br /> (DM) *StatementHandle* находился в состоянии выполнения, но результирующий набор не связан с *StatementHandle*.<br /><br /> Курсор был открыт на *StatementHandle* и **SQLFetch** или **SQLFetchScroll** бы была вызвана, но курсор был установлен перед началом результирующего набора или после конец результирующего набора.|  
|HY000|Общая ошибка|Произошла ошибка, для которой было нет определенных SQLSTATE и для которого был определен SQLSTATE не зависит от реализации. Сообщение об ошибке, возвращенные **SQLGetDiagRec** в *MessageText* буфера описывает ошибку и его причины.|  
|HY001|Ошибка выделения памяти|Драйверу не удалось выделить память, необходимую для поддержки выполнения или завершения функции.|  
|HY003 И СООБЩЕНИЕМ|Тип программы вне допустимого диапазона|(DM) аргумент *TargetType* не допустимый тип данных, SQL_C_DEFAULT, SQL_ARD_TYPE (в случае получение данных столбца) или SQL_APD_TYPE (в случае получения данных параметров).<br /><br /> (DM) аргумент *Col_or_Param_Num* был 0, а аргумент *TargetType* не SQL_C_BOOKMARK закладки фиксированной длины или SQL_C_VARBOOKMARK для закладки переменной длины.|  
|HY008|Операция отменена|Асинхронная обработка была включена для *StatementHandle*. Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle*, и затем вызова функции еще раз на *StatementHandle*.<br /><br /> Функция был вызван, и до выполнения, **SQLCancel** или **SQLCancelHandle** был вызван для *StatementHandle* из другого потока в многопоточные приложения, а функция была вызвана снова на *StatementHandle*.|  
|HY009|Недопустимое использование пустого указателя|(DM) аргумент *TargetValuePtr* является пустым указателем.|  
|HY010|Ошибка последовательности функций|(DM) указанного *StatementHandle* не находился в состоянии выполнения. Функция была вызвана без предварительного вызова функции **SQLExecDirect**, **SQLExecute** или функции каталога.<br /><br /> (DM) был вызван асинхронно выполняемой функции для дескриптора соединения, с которым связан *StatementHandle*. Выполняется при этом асинхронной функция **SQLGetData** была вызвана функция.<br /><br /> (DM) был вызван асинхронно выполняемой функции (не данный файл) для *StatementHandle* и все еще выполняется, при вызове этой функции.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, или **SQLSetPos** был вызван для * StatementHandle* и возвращается значение SQL_NEED_DATA. Эта функция был вызван перед отправкой данных для всех параметров с данными времени выполнения или столбцов.<br /><br /> (DM) *StatementHandle* находился в состоянии выполнения, но результирующий набор не связан с *StatementHandle*.<br /><br /> Вызов **SQLExeceute**, **SQLExecDirect**, или **SQLMoreResults** возвращается SQL_PARAM_DATA_AVAILABLE, но **SQLGetData** был вызван , а не **SQLParamData**.|  
|HY013|Ошибка управления памятью|Не удалось обработать вызов функции, поскольку базовые объекты памяти будет недоступен, возможно из-за нехватки памяти.|  
|HY090|Недопустимая длина строки или буфера|(DM) значение, указанное в аргументе *BufferLength* был меньше 0.<br /><br /> Значение, указанное в аргументе *BufferLength* был меньше, чем 4 *Col_or_Param_Num* аргумент имеет значение 0, а драйвер было ODBC 2*.x* драйвера.|  
|HY109|Недопустимое положение курсора|Курсор был установлен (по **SQLSetPos**, **SQLFetch**, **SQLFetchScroll**, или **SQLBulkOperations**) для строки, которая была удалена или не удалось извлечь.<br /><br /> Курсор был однонаправленного курсора, а размер набора строк было больше единицы.|  
|HY117|Соединение будет приостановлена из-за неизвестной транзакции состояния. Только отключиться и разрешены функции, доступные только для чтения.|(DM) Дополнительные сведения о состоянии приостановки см. в разделе [функция SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Дополнительная возможность не реализована|Драйвер или источник данных не поддерживает использование **SQLGetData** с несколькими строками в **SQLFetchScroll**. Это описание не применяется к драйверам, которые возвращают SQL_GD_BLOCK битовой маски для параметра SQL_GETDATA_EXTENSIONS в **SQLGetInfo**.<br /><br /> Драйвер или источник данных не поддерживает преобразование, определяется сочетанием *TargetType* аргументов и тип данных SQL соответствующего столбца. Эта ошибка применяется только в том случае, если тип данных SQL столбца был сопоставлен с типом данных SQL специфические для драйвера.<br /><br /> Драйвер поддерживает только ODBC 2*.x*и аргумент *TargetType* был одним из следующих:<br /><br /> SQL_C_NUMERIC SQL_C_SBIGINT SQL_C_UBIGINT<br /><br /> и любой из типов данных C интервал, перечисленных в [типы данных C](../../../odbc/reference/appendixes/c-data-types.md) в типах данных приложение D:.<br /><br /> Драйвер поддерживает только ODBC версий, предшествующих 3,50 и аргумента *TargetType* был SQL_C_GUID.|  
|HYT01|Время ожидания соединения истекло|Время ожидания соединения истекло раньше, чем ответил на запрос источника данных. Время ожидания задается с помощью **SQLSetConnectAttr**, sql_attr_connection_timeout не учитывается.|  
|IM001|Драйвер не поддерживает эту функцию|(DM) драйвер, соответствующий *StatementHandle* не поддерживает функцию.|  
|IM017|В режиме асинхронное уведомление отключена опроса|При использовании модели уведомление опроса отключен.|  
|IM018|**SQLCompleteAsync** не был вызван для завершения предыдущей асинхронной операции на этот дескриптор.|Если предыдущего вызова функции с дескриптором возвращает SQL_STILL_EXECUTING и уведомлений в режиме **SQLCompleteAsync** должен вызываться для этого после обработки и выполнения операции с дескриптором.|  
  
## <a name="comments"></a>Комментарии  
 **SQLGetData** возвращает данные в указанном столбце. **SQLGetData** может вызываться только в том случае, если выбраны один или несколько строк из результирующего набора по **SQLFetch**, **SQLFetchScroll**, или **SQLExtendedFetch** . Если данные переменной длины слишком велико, должны быть возвращены в рамках одного вызова **SQLGetData** (из-за ограничений в приложение), **SQLGetData** можно получить в частях. Можно привязать некоторые столбцы в строки и вызова **SQLGetData** для других пользователей, несмотря на то что некоторые ограничения. Дополнительные сведения см. в разделе [получения длинных данных](../../../odbc/reference/develop-app/getting-long-data.md).  
  
 Дополнительные сведения об использовании **SQLGetData** с потоковых выходных параметров, в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="using-sqlgetdata"></a>С помощью SQLGetData  
 Если драйвер не поддерживает расширения **SQLGetData**, функция может возвращать только данные для несвязанных столбцов с номером больше последнего связанного столбца. Кроме того, в строку данных, значение *Col_or_Param_Num* аргумента при каждом обращении к **SQLGetData** должен быть больше или равно значению *Col_or_Param_Num*в предыдущем вызове; то есть необходимо получить данные по возрастанию номера столбца. Наконец, если расширения не поддерживаются, **SQLGetData** не может вызываться, если размер набора строк больше 1.  
  
 Драйверы могут опускать любой из этих ограничений. Чтобы определить, какие ограничения ослабляет используемые драйвером, приложение вызывает **SQLGetInfo** с любым из следующих параметров SQL_GETDATA_EXTENSIONS:  
  
-   SQL_GD_OUTPUT_PARAMS = **SQLGetData** можно вызвать для получения значений выходных параметров. Дополнительные сведения см. в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
-   SQL_GD_ANY_COLUMN. Если этот параметр возвращается, **SQLGetData** может вызываться для любой несвязанного столбца, включая те, до последнего связанного столбца.  
  
-   SQL_GD_ANY_ORDER. Если этот параметр возвращается, **SQLGetData** может вызываться для несвязанных столбцов в любом порядке.  
  
-   SQL_GD_BLOCK. Если этот параметр, возвращаемый **SQLGetInfo** для свойство SQL_GETDATA_EXTENSIONS, драйвер поддерживает вызовы **SQLGetData** при размер набора строк больше 1, и приложение может вызвать **SQLSetPos** с параметром SQL_POSITION, поместите курсор на правильный строки перед вызовом метода **SQLGetData.**  
  
-   SQL_GD_BOUND. Если этот параметр возвращается, **SQLGetData** может вызываться для привязанных столбцов, а также для несвязанных столбцов.  
  
 Существует два исключения из этих ограничений, а драйвер, возможность опускать их. Во-первых, **SQLGetData** никогда не должен вызываться для однонаправленного курсора, при размер набора строк больше 1. Во-вторых, если драйвер поддерживает закладки, он всегда должен поддерживать возможность вызова **SQLGetData** для столбца 0, даже если он не позволяет приложениям вызывать **SQLGetData** для других столбцов перед удалением последней привязанного столбца. (Если приложение работа с ODBC 2*.x* драйвера, **SQLGetData** успешно возвращает закладку при вызове с *Col_or_Param_Num* равно 0 после вызова **SQLFetch**, так как **SQLFetch** сопоставлен с ODBC 3*.x* диспетчера драйверов для **SQLExtendedFetch** с * FetchOrientation* для SQL_FETCH_NEXT, и **SQLGetData** с *Col_or_Param_Num* 0 сопоставлен с ODBC 3*.x* диспетчера драйверов для **SQLGetStmtOption** с *fOption* из SQL_GET_BOOKMARK.)  
  
 **SQLGetData** не может использоваться для получения закладка для строки, только что вставленных путем вызова **SQLBulkOperations** с параметром sql_add, так как курсор не располагается в строке. Приложение может получать закладки для такую строку путем привязки столбец 0, перед вызовом метода **SQLBulkOperations** с SQL_ADD, в этом случае **SQLBulkOperations** возвращает закладки в буфере связанный. **SQLFetchScroll** затем может быть вызван с SQL_FETCH_BOOKMARK для изменения положения курсора в этой строке.  
  
 Если *TargetType* аргумент имеет тип данных интервал, начальные точности интервала по умолчанию (2) и точность секунд интервал по умолчанию (6), как указано в полях SQL_DESC_DATETIME_INTERVAL_PRECISION и SQL_DESC_PRECISION Отменить, соответственно, используются для данных. Если *TargetType* аргумент имеет тип данных SQL_C_NUMERIC точность по умолчанию (определяемые драйвером) и масштаб (0), по умолчанию, указанное на полях SQL_DESC_PRECISION и SQL_DESC_SCALE Отменить, используются для данных. Если любой по умолчанию точность или масштаб не подходит, приложение должно явно задать поля дескриптора соответствующие путем вызова **SQLSetDescField** или **SQLSetDescRec**. Его можно задать поля SQL_DESC_CONCISE_TYPE в SQL_C_NUMERIC и вызвать метод **SQLGetData** с *TargetType* аргумент SQL_ARD_TYPE, что вызовет точность и масштаб значения в поля дескриптора для использования.  
  
> [!NOTE]  
>  В ODBC 2*.x*, набор приложений *TargetType* SQL_C_DATE, SQL_C_TIME или SQL_C_TIMESTAMP, чтобы указать, что \* *TargetValuePtr* является типа date, time, или Структура отметки времени. В ODBC 3*.x*, набор приложений *TargetType* SQL_C_TYPE_DATE, SQL_C_TYPE_TIME или SQL_C_TYPE_TIMESTAMP. Диспетчер драйверов делает соответствующие сопоставления при необходимости в зависимости от версии приложений и драйверов.  
  
## <a name="retrieving-variable-length-data-in-parts"></a>Получение данных переменной длины в части  
 **SQLGetData** может использоваться для получения данных из столбца, содержащего данные переменной длины в части, когда идентификатор столбца типа данных SQL является SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_WCHAR, SQL_WVARCHAR, SQL_ WLONGVARCHAR, SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY или идентификатор драйвера для типов переменной длины.  
  
 Для получения данных из столбца в части, приложение вызывает **SQLGetData** несколько раз подряд этого столбца. При каждом вызове **SQLGetData** следующая часть данных. Это приложение должно повторно собрать части, участвующих удалите символ конечное значение null из промежуточного части символьных данных. При наличии дополнительных данных для возврата или не был выделен достаточно большого буфера для завершающего символа **SQLGetData** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01004 (данных). Если он возвращает последнюю часть данных, **SQLGetData** возвращает SQL_SUCCESS. SQL_NO_TOTAL ни ноль может быть возвращено при последнем вызове допустимым для извлечения данных из столбца, так как приложение будет иметь не может определить, какой объем данных в буфер приложения является допустимым. Если **SQLGetData** вызывается после этого он возвращает значение SQL_NO_DATA. Дополнительные сведения см. в разделе следующем разделе «Получение данных с SQLGetData».  
  
 Закладки переменной длины могут быть возвращены в элементы, указывая **SQLGetData**. Как и в случае с другими данными, вызов **SQLGetData** для возврата закладки переменной длины в частях вернет SQLSTATE 01004 (строковые данные, усечение справа) и SQL_SUCCESS_WITH_INFO, если больше данных, должны быть возвращены. Это отличается от случая при усечении закладки переменной длины с помощью вызова **SQLFetch** или **SQLFetchScroll**, который возвращает значение SQL_ERROR и SQLSTATE 22001 (строковые данные, усечение справа).  
  
 **SQLGetData** не может использоваться для возврата данных фиксированной длины в частях. Если **SQLGetData** — вызывается несколько раз подряд для столбца, содержащего данные фиксированной длины, будет возвращено SQL_NO_DATA для все вызовы после первого.  
  
## <a name="retrieving-streamed-output-parameters"></a>Получение потоковых выходных параметров  
 Если драйвер поддерживает потоковых выходных параметров, приложение может вызвать **SQLGetData** с небольшой буфера многократно для получения значения параметра большого объема. Дополнительные сведения о потоковой выходного параметра см. в разделе [получение выходных параметров с помощью метода SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md).  
  
## <a name="retrieving-data-with-sqlgetdata"></a>Извлечение данных с SQLGetData  
 Для возврата данных для указанного столбца **SQLGetData** выполняет следующие действия:  
  
1.  Возвращает значение SQL_NO_DATA, если он уже вернул все данные для столбца.  
  
2.  Наборы \* *StrLen_or_IndPtr* значение SQL_NULL_DATA, если данные имеют значение NULL. Если данные имеют значение NULL и *StrLen_or_IndPtr* является пустым указателем, **SQLGetData** возвращает SQLSTATE 22002 (индикатор требуется, но не указано).  
  
     Если данные для столбца не равно NULL, **SQLGetData** переходит к шагу 3.  
  
3.  Если атрибут инструкции sql_attr_max_length параметра задано ненулевое значение, если столбец содержит символьных или двоичных данных, а **SQLGetData** ранее не был вызван для этого столбца, то данные будут усечены sql_attr_max_length параметра байт.  
  
    > [!NOTE]  
    >  Атрибут sql_attr_max_length параметра инструкции предназначены для сокращения сетевого трафика. Обычно она реализуется источника данных, которое производит усечение данных перед возвращением по сети. Драйверы и источники данных не требуется для его поддержки. Таким образом, чтобы гарантировать, что данные будут усечены до определенного размера, приложение должно выделить буфер указанного размера и укажите размер в *BufferLength* аргумент.  
  
4.  Преобразует данные в тип, указанный в *TargetType*. Данные присваивается по умолчанию точность и масштаб для этого типа данных. Если *TargetType* — SQL_ARD_TYPE, данные в поле SQL_DESC_CONCISE_TYPE Отменить используется. Если *TargetType* не SQL_ARD_TYPE, данных содержится в SQL_DESC_DATETIME_INTERVAL_PRECISION, SQL_DESC_PRECISION, точность и масштаб и поля SQL_DESC_SCALE Отменить, в зависимости от данных SQL_DESC_CONCISE _Введите поле. Если любой по умолчанию точность или масштаб не подходит, приложение должно явно задать поля дескриптора соответствующие путем вызова **SQLSetDescField** или **SQLSetDescRec**.  
  
5.  Если данные был преобразован в тип данных переменной длины, например символьный или двоичный файл, **SQLGetData** проверяет, является ли длина данных превышает *BufferLength*. Если длина символьных данных (включая символ завершения null) превышает *BufferLength*, **SQLGetData** усекает данные *BufferLength* меньше длины Конечное значение null-символа. Он затем null прерывает данные. Если длина двоичных данных превышает длину буфера данных **SQLGetData** усекает его *BufferLength* байт.  
  
     Если буфер данных слишком мал для размещения символа конечное значение null, **SQLGetData** возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01004.  
  
     **SQLGetData** никогда не усекает данные преобразовать типы данных фиксированной длины; всегда предполагается, что длина **TargetValuePtr* — это размер типа данных.  
  
6.  Помещает данные в преобразованный (и возможно усеченное) \* *TargetValuePtr*. Обратите внимание, что **SQLGetData** не могут возвращать данные из строки.  
  
7.  Устанавливает длину данных в \* *StrLen_or_IndPtr*. Если *StrLen_or_IndPtr* является пустым указателем, **SQLGetData** не возвращает длину.  
  
    -   Для символьных или двоичных данных, это длина данных после преобразования и перед усечение из-за *BufferLength*. Если драйвер не может определить длину данных после преобразования, как иногда в случае с большие объемы данных, он возвращает значение SQL_SUCCESS_WITH_INFO и устанавливает длину, равную SQL_NO_TOTAL. (Последнего вызова **SQLGetData** всегда должны возвращать длину данных, не нулевой или SQL_NO_TOTAL.) Если данные были усечены из-за инструкции sql_attr_max_length параметра атрибута, значение этого атрибута, а не фактическую длину — помещается в \* *StrLen_or_IndPtr*. Это потому, что этот атрибут предназначен для усечения данных на сервере перед преобразованием, поэтому драйвер не имеет способа выяснить, фактическая длина:. Когда **SQLGetData** — вызывается несколько раз подряд для одного столбца, это длина данных в начале текущего вызова; то есть, длина уменьшается при каждом последующем вызове.  
  
    -   Для всех других типов данных это длина данных после преобразования; он является размер тип, к которому был преобразован данные.  
  
8.  Если данные усекаются без потери значимости при преобразовании (например, вещественное число 1,234 усекается при преобразовании в целочисленное значение 1) или из-за *BufferLength* слишком мал (например, строка «abcdef» помещается в буфере 4-байтовое) **SQLGetData** возвращает SQLSTATE 01004 (данных) и SQL_SUCCESS_WITH_INFO. Если данные усекаются без потери значимости, из-за инструкции атрибут значения SQL_ATTR_MAX_LENGTH **SQLGetData** возвращает SQL_SUCCESS и не возвращает SQLSTATE 01004 (данных).  
  
 Содержимое буфера привязанного к данным (если **SQLGetData** вызывается для связанного столбца) и буфер длины/индикатора не определены, если **SQLGetData** не возвращает значение SQL_SUCCESS или SQL_SUCCESS_WITH_INFO.  
  
 Последующие вызовы **SQLGetData** получает данные из последнего столбца, запрашиваются; предыдущие смещения становятся недействительными. Например, если выполняется следующую последовательность:  
  
```  
SQLGetData(icol=n), SQLGetData(icol=m), SQLGetData(icol=n)  
```  
  
 Второй вызов SQLGetData(icol=n) извлекает данные из начала n столбца. Смещения в данных из-за предыдущих вызовов **SQLGetData** для столбца, больше не является допустимым.  
  
## <a name="descriptors-and-sqlgetdata"></a>Дескрипторы и SQLGetData  
 **SQLGetData** не взаимодействует непосредственно с полями дескриптора.  
  
 Если *TargetType* — SQL_ARD_TYPE, данные в поле SQL_DESC_CONCISE_TYPE Отменить используется. Если *TargetType* SQL_ARD_TYPE или SQL_C_DEFAULT, данных содержится в SQL_DESC_DATETIME_INTERVAL_PRECISION, SQL_DESC_PRECISION, точности и масштаба и типа поля SQL_DESC_SCALE Отменить, в зависимости от данных в поле SQL_DESC_CONCISE_TYPE.  
  
## <a name="code-example"></a>Пример кода  
 В следующем примере приложение выполняет **ВЫБЕРИТЕ** инструкцию, чтобы вернуть результирующий набор клиента идентификаторов, имен и телефонных номеров, отсортированных по имени, идентификатор и номер телефона. Для каждой строки данных, он вызывает **SQLFetch** для позиционирования курсора на следующую строку. Он вызывает **SQLGetData** для получения данных выборки; буферов данных и возвращенное число байтов, указанного в вызове **SQLGetData**. Наконец он выводит имя каждого сотрудника, идентификатор и номер телефона.  
  
```  
#define NAME_LEN 50  
#define PHONE_LEN 50  
  
SQLCHAR      szName[NAME_LEN], szPhone[PHONE_LEN];  
SQLINTEGER   sCustID, cbName, cbAge, cbBirthday;  
SQLRETURN    retcode;  
SQLHSTMT     hstmt;  
  
retcode = SQLExecDirect(hstmt,  
   "SELECT CUSTID, NAME, PHONE FROM CUSTOMERS ORDER BY 2, 1, 3",  
   SQL_NTS);  
  
if (retcode == SQL_SUCCESS) {  
   while (TRUE) {  
      retcode = SQLFetch(hstmt);  
      if (retcode == SQL_ERROR || retcode == SQL_SUCCESS_WITH_INFO) {  
         show_error();  
      }  
      if (retcode == SQL_SUCCESS || retcode == SQL_SUCCESS_WITH_INFO){  
  
         /* Get data for columns 1, 2, and 3 */  
  
         SQLGetData(hstmt, 1, SQL_C_ULONG, &sCustID, 0, &cbCustID);  
         SQLGetData(hstmt, 2, SQL_C_CHAR, szName, NAME_LEN, &cbName);  
         SQLGetData(hstmt, 3, SQL_C_CHAR, szPhone, PHONE_LEN,  
            &cbPhone);  
  
         /* Print the row of data */  
  
         fprintf(out, "%-5d %-*s %*s", sCustID, NAME_LEN-1, szName,   
            PHONE_LEN-1, szPhone);  
      } else {  
         break;  
      }  
   }  
}  
```  
  
## <a name="related-functions"></a>Связанные функции  
  
|Сведения о|См.|  
|---------------------------|---------|  
|Назначение хранилища для столбца в результирующем наборе|[SQLBindCol](../../../odbc/reference/syntax/sqlbindcol-function.md)|  
|Выполнения массовых операций, которые не связаны с позицией курсора блока|[SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md)|  
|Отмена обработки инструкции|[SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Выполнение инструкции SQL|[SQLExecDirect](../../../odbc/reference/syntax/sqlexecdirect-function.md)|  
|Выполнения подготовленной инструкции SQL|[SQLExecute](../../../odbc/reference/syntax/sqlexecute-function.md)|  
|Выборка блока данных или прокрутке результирующего набора|[SQLFetchScroll](../../../odbc/reference/syntax/sqlfetchscroll-function.md)|  
|Выборка одной строки данных или блок данных в направлении только вперед|[SQLFetch](../../../odbc/reference/syntax/sqlfetch-function.md)|  
|Отправка данных параметра во время выполнения|[SQLPutData](../../../odbc/reference/syntax/sqlputdata-function.md)|  
|Позиционирование курсора, обновление данных в наборе строк или удаления данных в наборе строк|[SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md)|  
  
## <a name="see-also"></a>См. также:  
 [Справочник по API-интерфейса ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Файлы заголовка ODBC](../../../odbc/reference/install/odbc-header-files.md)   
 [Извлечение параметров вывода с помощью SQLGetData](../../../odbc/reference/develop-app/retrieving-output-parameters-using-sqlgetdata.md)
