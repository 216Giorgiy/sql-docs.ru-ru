---
title: "Создав поиск операторы | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: odbc
ms.reviewer: 
ms.suite: sql
ms.technology: drivers
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- searched statements [ODBC]
- ODBC cursor library [ODBC], statement processing
- ODBC cursor library [ODBC], searched statements
- SQL statements [ODBC], cursor library
- cursor library [ODBC], statement processing
- cursor library [ODBC], searched statements
- SQL statements [ODBC], searched statements
ms.assetid: e429254c-c43f-4fbf-98b2-5f1ed53501ff
caps.latest.revision: "8"
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: Inactive
ms.openlocfilehash: 713f020261d4d2365061247603de72fa31787696
ms.sourcegitcommit: cc71f1027884462c359effb898390c8d97eaa414
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="constructing-searched-statements"></a>Создав поиск инструкций
> [!IMPORTANT]  
>  Этот компонент будет удален в будущих версиях Windows. Избегайте использования этой возможности в новых разработках и запланируйте изменение приложений, которые сейчас ее используют. Корпорация Майкрософт рекомендует использовать функциональность курсора драйвера.  
  
 Для поддержки позиционированного обновления и удаления, библиотеку курсоров создает поисковое **обновление** или **удалить** инструкции от позиционированной инструкции. Для поддержки вызовов в **SQLGetData** в блок данных библиотеку курсоров создает поисковое **ВЫБЕРИТЕ** инструкцию, чтобы создать результирующий набор, содержащий текущей строке данных. В каждом из этих инструкций **ГДЕ** предложение перечисляет значения, хранящиеся в кэше для каждого привязанного столбца, возвращает значение идентификатора поля SQL_DESC_SEARCHABLE в SQL_PRED_SEARCHABLE или SQL_PRED_BASIC  **SQLColAttribute**.  
  
> [!CAUTION]  
>  **ГДЕ** предложение, создаваемых библиотеку курсоров для идентификации текущей строки не удается определить все строки, определить другую строку или определить более одной строки.  
  
 Если оператор позиционированного обновления или удаления затрагивает более одной строки, библиотеку курсоров обновляет массив состояния строк только для строк, на котором находится курсор и возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01001 (конфликт операции курсора). Если инструкция не определяет все строки, библиотеку курсоров не обновляет массив состояния строк и возвращает SQL_SUCCESS_WITH_INFO и SQLSTATE 01001 (конфликт операции курсора). Приложение может вызвать **SQLRowCount** для определения числа строк, которые были обновлены или удалены.  
  
 Если **ВЫБЕРИТЕ** предложение позиционировать курсор для вызова **SQLGetData** идентифицирует более чем одной строке **SQLGetData** не обязательно возвращают правильные данные. Если он не может определить все строки **SQLGetData** не вернет значение SQL_NO_DATA.  
  
 Если приложение соответствует следующим правилам **ГДЕ** предложение составить библиотекой курсоров должен однозначно определять текущей строки, кроме случаев, когда это невозможно, например, если источник данных содержит повторяющийся строки.  
  
-   **Привязка столбцов, которые однозначно определяют строку.** Если привязанные столбцы, не определяет уникально строку **ГДЕ** составить библиотекой курсоров предложение можно определить более одной строки. В позиционированного обновления или инструкции delete такое предложение может привести к более чем одной строке обновить или удалить. При обращении к **SQLGetData**, такое предложение может вызвать драйвер для возврата данных для строки неправильный. Привязка всех столбцов в уникальный ключ гарантирует уникальной идентификации каждой строки.  
  
-   **Выделите буферы данных достаточно велик, усечение не происходит.** Библиотека курсоров кэша является копией значения в буферы строк, привязанный к результирующему набору с **SQLBindCol**. Если данные будут усечены, когда он помещается в буфер, он будет усечен также в кэше. Объект **ГДЕ** предложение, построенным на основе усеченные значения не может правильно определить базовой строки в источнике данных.  
  
-   **Укажите ненулевой длины буферов для двоичных данных C.** Библиотека курсоров выделяет буферы длины в его кэша, только если *StrLen_or_IndPtr* аргумент в **SQLBindCol** отлично от null. Когда *TargetType* аргумент SQL_C_BINARY, библиотека курсоров требуется длина двоичных данных для создания **ГДЕ** предложения из данных. Если имеется не буфер длины для столбца SQL_C_BINARY и приложение вызывает **SQLGetData** или пытается выполнить позиционированного обновления или delete, инструкция возвращает библиотеки курсоров SQL_ERROR и SQLSTATE SL014 (позиционированные запрос был выдан и были буфер не все поля число столбцов).  
  
-   **Укажите буферы ненулевой длины для столбцов со значением NULL.** Библиотека курсоров выделяет буферы длины в его кэша, только если *StrLen_or_IndPtr* аргумент в **SQLBindCol** отлично от null. Поскольку SQL_NULL_DATA хранится в буфер длины, библиотеку курсоров считает любой столбец, буфер задается для длина не допускают значение NULL. Если столбец не длину задан для столбца значения NULL, создает библиотеку курсоров **ГДЕ** предложение, которое использует значение данных для столбца. Это предложение не будет правильно идентифицировать строку.
