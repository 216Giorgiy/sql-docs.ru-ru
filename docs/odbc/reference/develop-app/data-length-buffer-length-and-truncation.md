---
title: "Длина данных, длина буфера и усечение | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- drivers
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- data buffers [ODBC], length
- data length [ODBC]
- truncating data [ODBC]
- length of data buffers [ODBC]
- buffers [ODBC], length
ms.assetid: 2825c6e7-b9ff-42fe-84fc-7fb39728ac5d
caps.latest.revision: 6
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.translationtype: MT
ms.sourcegitcommit: f7e6274d77a9cdd4de6cbcaef559ca99f77b3608
ms.openlocfilehash: 616dc403fdd23f3233bde4a5db19dd58b6d94cf1
ms.contentlocale: ru-ru
ms.lasthandoff: 09/09/2017

---
# <a name="data-length-buffer-length-and-truncation"></a>Длина данных, длина буфера и усечения
*Длина данных* является байт данных, как он будет храниться в буфере данных приложения, не в том случае, когда он помещается в источнике данных. Это различие важно, так как данные часто хранятся в различных типов в буфере данных и в источнике данных. Поэтому для данных, отправляемых в источнике данных, это байтовая длина данных перед преобразованием в тип источника данных. Для данных, извлекаемых из источника данных это байтовая длина данных после преобразования тип буфера данных, и перед выполнением любой усечение.  
  
 Для данных фиксированной длины, например целое число или структура даты байтовая длина данных всегда равно размеру типа данных. В общем случае приложения выделить буфер данных такого размера, типа данных. Если приложение выделяет меньшего размера буфера, последствия не определено, так как драйвер предполагает буфера данных — это размер типа данных, а не удаляет данные для помещения в меньший буфер. Если приложение выделяет буфер большего размера, никогда не используется дополнительное пространство.  
  
 Данные переменной длины, например символьных или двоичных данных важно понять, что байтовая длина данных является отдельно от и часто отличается от байтовая длина буфера. Описывается связью эти два значения длины в [буферы](../../../odbc/reference/develop-app/buffers.md) раздела. Если байтовая длина данных больше, чем длина буфера байт, драйвер производит усечение данных выборки для байтовая длина буфера и возвращает значение SQL_SUCCESS_WITH_INFO с кодом SQLSTATE 01004 (данных). Однако длина возвращаемого байтового является длина неусеченный данных.  
  
 Например предположим, что приложение выделяет 50 байт для буфера двоичных данных. Если драйвер имеет 10 байт для возврата двоичных данных, он возвращает эти 10 байт в буфере. Байтовая длина данных — 10, а байтовая длина буфера — 50. Если драйвер 60 байтов двоичных данных для возврата, усечение данных до 50 байт, возвращает этих байтов в буфере и возвращает значение SQL_SUCCESS_WITH_INFO. Байтовая длина данных 60 (длиной до усечения), а байтовая длина буфера, по-прежнему равно 50.  
  
 Для каждого столбца, усекается создается запись диагностики. Поскольку нужно время для драйвера создать эти записи и приложения для их обработки, усечение может ухудшить производительность. Как правило, приложение этой проблемы можно избежать путем выделения достаточно большие буферы, несмотря на то, что это может оказаться невозможным при работе с длинных данных. При усечении данных, приложение может иногда увеличьте размер буфера и получить данные; Это не так, во всех случаях. Если происходит усечение при получении данных с помощью вызовов **SQLGetData**, приложения не должны вызывать **SQLGetData** данные, которые уже были возвращены; Дополнительные сведения см. [начало Длинные данные](../../../odbc/reference/develop-app/getting-long-data.md).
