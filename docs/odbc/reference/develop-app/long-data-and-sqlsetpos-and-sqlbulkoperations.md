---
title: "Большие объемы данных и SQLSetPos и SQLBulkOperations | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: reference
ms.reviewer: 
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- long data [ODBC]
- SQLSetPos function [ODBC], long data and SQLBulkOperations
- data updates [ODBC], long data
- updating data [ODBC], long data
- SQLBulkOperations function [ODBC], long data
ms.assetid: e2fdf842-5e4c-46ca-bb21-4625c3324f28
caps.latest.revision: 5
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: Inactive
ms.translationtype: MT
ms.sourcegitcommit: f7e6274d77a9cdd4de6cbcaef559ca99f77b3608
ms.openlocfilehash: 308e1ad6f2d99a0a6b7e73d8a82ac62362fea9a2
ms.contentlocale: ru-ru
ms.lasthandoff: 09/09/2017

---
# <a name="long-data-and-sqlsetpos-and-sqlbulkoperations"></a>Большие объемы данных и SQLSetPos и SQLBulkOperations
Как и в случае с параметрами в инструкции SQL, большие объемы данных могут отправляться при обновлении строки со **SQLBulkOperations** или **SQLSetPos** или при вставке строк с **SQLBulkOperations**. Данные отправляются в частях с несколькими вызовами в **SQLPutData**. Столбцы, для которых данные передаются во время выполнения, называются *столбцов данных времени выполнения*.  
  
> [!NOTE]  
>  Приложение фактически можно отправлять данные любого типа во время выполнения с помощью **SQLPutData**, несмотря на то, что в частях могут отправляться только символьных и двоичных данных. Тем не менее, если данные помещаются в один буфер, обычно есть причин использовать **SQLPutData**. Гораздо проще привязать буфер и разрешить драйверу извлечения данных из буфера.  
  
 Так как столбцы длинных данных обычно не связаны, приложение необходимо привязать столбец перед вызовом **SQLBulkOperations** или **SQLSetPos** и отмены привязки значения после вызова **SQLBulkOperations**  или **SQLSetPos**. Столбец должен быть привязан, так как **SQLBulkOperations** или **SQLSetPos** действует только для связанных столбцов и должна быть отменена, чтобы **SQLGetData** может использоваться для получения данных в столбце.  
  
 Для отправки данных во время выполнения, приложение выполняет следующие задачи.  
  
1.  32-разрядное значение помещается в буфер строк вместо значения данных. Это значение будет возвращаться в приложение более поздней версии, поэтому приложение должно задать значимое значение, например номер столбца или дескриптор файла, содержащего данные.  
  
2.  Задает значение в буфер длины/индикатора к результату SQL_LEN_DATA_AT_EXEC (*длина*) макрос. Это значение указывает драйверу, будут отправляться данные для параметра с **SQLPutData**. *Длина* значение используется при отправке данных long в источник данных, необходимо знать, сколько байтов больших объемов данных, которые будут отправлены, чтобы его можно заранее выделите место. Чтобы определить, требуется ли источник данных это значение, приложение вызывает **SQLGetInfo** с параметром SQL_NEED_LONG_DATA_LEN. Все драйверы должны поддерживать этот макрос; Если источник данных не требует байтовая длина, драйвер может пропустить.  
  
3.  Вызовы **SQLBulkOperations** или **SQLSetPos**. Драйвер обнаруживает, что буфер длины/индикатора содержит результат SQL_LEN_DATA_AT_EXEC (*длина*) макрос и возвращает SQL_NEED_DATA как возвращаемое значение функции.  
  
4.  Вызовы **SQLParamData** в ответ на SQL_NEED_DATA возвращаемое значение. Если данные большой длины должен быть отправлен, **SQLParamData** возвращает SQL_NEED_DATA. В буфере, на который указывает *ValuePtrPtr* аргумент, драйвер возвращает уникальное значение, которое приложение помещаются в буфер строк. Если имеется более одного столбца данных во время выполнения, приложение использует это значение для определения, какой столбец для отправки данных; драйвер не требуется для запроса данных для столбцов данных времени выполнения в любом порядке.  
  
5.  Вызовы **SQLPutData** для отправки данных в столбце драйвер. Если столбец данных не помещается в один буфер, как это часто бывает в случае с большие объемы данных, приложение вызывает **SQLPutData** несколько раз, чтобы отправить данные в частях; возлагается драйвер и источник данных собрать данные. Если приложение передает данные в строку, завершающуюся значением null, драйвер или источник данных необходимо удалить символ завершения null как часть процесса сборки.  
  
6.  Вызовы **SQLParamData** еще раз, чтобы указать, что он отправил всех данных для столбца. Если имеются какие-либо столбцы данных времени выполнения, для которых не были отправлены данные, драйвер возвращает SQL_NEED_DATA и уникальное значение для следующего столбца данных во время выполнения; приложение возвращается к шагу 5. Если отправки данных для всех столбцов данных времени выполнения данные для строки отправляется к источнику данных. **SQLParamData** возвращает SQL_SUCCESS или SQL_SUCCESS_WITH_INFO и может возвращать любой SQLSTATE **SQLBulkOperations** или **SQLSetPos** может возвращать.  
  
 После **SQLBulkOperations** или **SQLSetPos** возвращает SQL_NEED_DATA и перед данных полностью отправлен для последнего столбца данных во время выполнения, инструкция находится в состоянии необходимые данные. В этом состоянии, приложение может вызвать только **SQLPutData**, **SQLParamData**, **SQLCancel**, **SQLGetDiagField**, или **SQLGetDiagRec**; все остальные функции возвращают SQLSTATE HY010 (функция ошибка последовательности). Вызов **SQLCancel** отменяет выполнение инструкции и возвращает его предыдущее состояние. Дополнительные сведения см. в разделе [приложение б: ODBC состояния перехода таблицы](../../../odbc/reference/appendixes/appendix-b-odbc-state-transition-tables.md).

