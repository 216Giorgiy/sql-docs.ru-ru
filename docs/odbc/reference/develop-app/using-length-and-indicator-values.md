---
title: "С помощью длины и значения индикатора | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- drivers
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- data buffers [ODBC], length
- length/indicator buffers [ODBC]
- length of data buffers [ODBC]
- buffers [ODBC], length
ms.assetid: 849792f1-cb1e-4bc2-b568-c0aff0b66199
caps.latest.revision: 6
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.translationtype: MT
ms.sourcegitcommit: f7e6274d77a9cdd4de6cbcaef559ca99f77b3608
ms.openlocfilehash: f615aa92da79c391e84539fdf5cf402d523ab690
ms.contentlocale: ru-ru
ms.lasthandoff: 09/09/2017

---
# <a name="using-length-and-indicator-values"></a>С помощью длины и значения индикатора
Буфер длины/индикатора используется для передачи байт данных в буфере данных или специальные индикатор, например SQL_NULL_DATA, который указывает, что данные имеют значение NULL. В зависимости от того, в котором используется функция буфер длины/индикатора определяется как SQLINTEGER или SQLSMALLINT. Таким образом для ее описания требуется один аргумент. Если буфер данных nondeferred входного буфера, этот аргумент содержит байтовая длина данных или значение индикатора. Часто называется *StrLen_or_Ind* или же именем. Например, следующий код вызывает **SQLPutData** для передачи буфера full данных; байт (*ValueLen*) передается непосредственно, так как буфер данных (*ValuePtr*) — Входной буфер.  
  
```  
SQLCHAR      ValuePtr[50];  
SQLINTEGER   ValueLen;  
  
// Call local function to place data in ValuePtr. In ValueLen, return the  
// number of bytes of data placed in ValuePtr. If there is not enough  
// data, this will be less than 50.  
FillBuffer(ValuePtr, sizeof(ValuePtr), &ValueLen);  
  
// Call SQLPutData to send the data to the driver.  
SQLPutData(hstmt, ValuePtr, ValueLen);  
```  
  
 Если буфер данных отложенное входного буфера nondeferred выходного буфера и выходной буфер, аргумент содержит адрес в буфер длины/индикатора. Часто называется *StrLen_or_IndPtr* или же именем. Например, следующий код вызывает **SQLGetData** для извлечения данных; полный буфер байтовая длина возвращается к приложению в буфер длины/индикатора (*ValueLenOrInd*), с адресом передаваемый **SQLGetData** поскольку соответствующего буфера данных (*ValuePtr*) является nondeferred выходного буфера.  
  
```  
SQLCHAR      ValuePtr[50];  
SQLINTEGER   ValueLenOrInd;  
SQLGetData(hstmt, 1, SQL_C_CHAR, ValuePtr, sizeof(ValuePtr), &ValueLenOrInd);  
```  
  
 Если он запрещен в частности аргументом буфер длины/индикатора может быть равен 0 (если nondeferred входных данных) или указатель null (если отложенного ввода). Входной буфер в результате драйверу игнорировать байт данных. Возвращает сообщение об ошибке при передаче данных переменной длины, но проявляется при передаче данных, отличных от null, фиксированной длины, поскольку требуется ни длины, ни значение индикатора. Выходной буфер это заставляет драйвер возвращает байтовая длина данных или значение индикатора. Это ошибка, если данные, возвращенные драйвер имеет значение NULL, но проявляется при извлечении данных фиксированной длины, не допускающий значений NULL, поскольку требуется ни длины, ни значение индикатора.  
  
 Как при передаче адрес буфера отложенное данных к драйверу адрес буфера отложенное длины/индикатора должен оставаться действительным до отменяется привязка буфера.  
  
 Следующие значения длины могут использоваться в качестве значения длины/индикатора:  
  
-   *n*, где * n * > 0.  
  
-   0.  
  
-   SQL_NTS. Строки, отправляемой в буфере данных, соответствующий драйвер символом null; Это удобный способ для программистов передавать строки без необходимости вычисления длина в байтах. Это значение является допустимым только в том случае, когда приложение отправляет данных к драйверу. Когда драйвер возвращает данные в приложение, она всегда возвращает фактический байтовая длина данных.  
  
 Следующие значения могут использоваться в качестве значения длины/индикатора. SQL_NULL_DATA хранится в поле дескриптора SQL_DESC_INDICATOR_PTR; все остальные значения хранятся в поле дескриптора SQL_DESC_OCTET_LENGTH_PTR.  
  
-   SQL_NULL_DATA. Данные значения данных NULL, и значение в соответствующий буфер данных учитывается. Это значение является допустимым только для данных SQL переданы или получены от драйвера.  
  
-   ЗНАЧЕНИЕ SQL_DATA_AT_EXEC. Буфер данных не содержит данных. Вместо этого данные будут отправлены с **SQLPutData** при выполнении инструкции или **SQLBulkOperations** или **SQLSetPos** вызывается. Это значение является допустимым только для данных SQL, передаваемых в драйвере. Дополнительные сведения см. в разделе [SQLBindParameter](../../../odbc/reference/syntax/sqlbindparameter-function.md), [SQLBulkOperations](../../../odbc/reference/syntax/sqlbulkoperations-function.md), и [SQLSetPos](../../../odbc/reference/syntax/sqlsetpos-function.md).  
  
-   Результат SQL_LEN_DATA_AT_EXEC (*длина*) макрос. Это значение аналогично значение SQL_DATA_AT_EXEC. Дополнительные сведения см. в разделе [отправки длинных данных](../../../odbc/reference/develop-app/sending-long-data.md).  
  
-   SQL_NO_TOTAL. Драйвер не удается определить число байтов больших объемов данных по-прежнему доступен для возврата в выходной буфер. Это значение является допустимым только для данных SQL, полученных от драйвера.  
  
-   ЗНАЧЕНИЕ SQL_DEFAULT_PARAM. Процедура — Чтобы использовать значение по умолчанию для входного параметра в процедуре вместо значения в соответствующий буфер данных.  
  
-   SQL_COLUMN_IGNORE. **SQLBulkOperations** или **SQLSetPos** позволяет не учитывать значение в буфер данных. При обновлении строки данных с помощью вызова **SQLBulkOperations** или **SQLSetPos,** значение столбца не изменяется. При вставке новой строки данных с помощью вызова **SQLBulkOperations**, значение столбца установлено в значение по умолчанию или, если столбец имеет значение по умолчанию, значение NULL.
