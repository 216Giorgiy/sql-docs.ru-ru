---
title: Влияние транзакций на курсоры и подготовленных инструкций | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- rolling back transactions [ODBC]
- committing transactions [ODBC]
- transactions [ODBC], rolling back
- cursors [ODBC], transaction commits or roll backs
- prepared statements [ODBC]
- transactions [ODBC], cursors
ms.assetid: 523e22a2-7b53-4c25-97c1-ef0284aec76e
caps.latest.revision: 6
author: MightyPen
ms.author: genemi
manager: craigg
ms.workload: Inactive
ms.openlocfilehash: 23ba65d28ad9a40028ca5e02daeea11607e0c3c8
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="effect-of-transactions-on-cursors-and-prepared-statements"></a>Влияние транзакций на курсоры и подготовленных инструкций
Фиксация или откат транзакции приведет к следующим последствиям на курсоры и планы доступа:  
  
-   Все курсоры закрываются и удаляются планы доступа для подготовленных инструкций для этого соединения.  
  
-   Все курсоры закрываются и планы доступа для подготовленных инструкций для этого соединения остаются без изменений.  
  
-   Все курсоры остаются открытыми и планы доступа для подготовленных инструкций для этого соединения остаются без изменений.  
  
 Например предположим, что источник данных поведение первой в этом списке, наиболее строгие из этих поведений. Теперь предположим, что приложение делает следующее:  
  
1.  Задает режим фиксации для ручной фиксации.  
  
2.  Создает результирующий набор заказов на продажу в отчете 1.  
  
3.  Создает результирующий набор строк в заказ на продажу в инструкции 2, когда пользователь выделяет в указанном порядке.  
  
4.  Вызовы **SQLExecute** для выполнения инструкции позиционированного обновления, который был подготовлен на инструкции 3, когда пользователь обновляет строку.  
  
5.  Вызовы **SQLEndTran** зафиксировать инструкции позиционированного обновления.  
  
 В связи с источника данных вызова **SQLEndTran** на шаге 5 вызывает закрытие курсоров в инструкциях 1 и 2 и удалить план доступа для всех инструкций. Приложение должно был повторно исполнить наборов инструкций 1 и 2 для повторного создания результата и reprepare инструкцию в инструкцию 3.  
  
 В режиме автоматической фиксации, функций, кроме **SQLEndTran** фиксации транзакции:  
  
-   **SQLExecute** или **SQLExecDirect** в предыдущем примере вызов **SQLExecute** на шаге 4 фиксирует транзакцию. В этом случае источник данных для закрытия курсора инструкции 1 и 2 и удалить план доступа для всех инструкций для этого соединения.  
  
-   **SQLBulkOperations** или **SQLSetPos** в предыдущем примере, предположим, что на шаге 4 приложение вызывает **SQLSetPos** с параметром sql_update инструкции 2, вместо выполнения позиционированные инструкции update на инструкцию 3. Это фиксирует транзакции вызывает закрытие курсоров в инструкциях 1 и 2 источника данных и отменяет все планы доступа для этого соединения.  
  
-   **SQLCloseCursor** в предыдущем примере, предположим, что когда пользователь выделяет другой заказ на продажу, приложение вызывает **SQLCloseCursor** на инструкцию 2 перед созданием результат строки для новых продаж порядок. Вызов **SQLCloseCursor** фиксирует **ВЫБЕРИТЕ** инструкцию создал результирующий набор строк и вызывает источника данных закрыть курсор на инструкцию 1, а затем удаляет все планы доступ на этот соединение.  
  
 Приложения, особенно на экране в которых пользователь прокручивает вокруг результирующего набора и обновления или удаляются строки, должна быть указана в код решения этой проблемы.  
  
 Чтобы определить, как источник данных ведет себя при фиксации или отката транзакции, приложение вызывает **SQLGetInfo** параметры SQL_CURSOR_COMMIT_BEHAVIOR и SQL_CURSOR_ROLLBACK_BEHAVIOR.
