---
title: Вызовы процедур | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- escape sequences [ODBC], procedure calls
- procedure calls [ODBC]
ms.assetid: 145130cc-40e7-4722-8417-dff131084752
caps.latest.revision: 7
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 6327ef340fe5fbd712ad9237bb6749d20bbd69af
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="procedure-calls"></a>Вызовы процедур
Объект *процедура* представляет собой исполняемый объект, хранящиеся в источнике данных. Обычно процедурой является одна или несколько заранее скомпилированных инструкций SQL. Escape-последовательность для вызова процедуры  
  
 **{**[**? =**]**вызвать** *имя процедуры*[**(**[*параметр*] [**,**[*параметр*]]... **)**]**}**  
  
 где *имя процедуры* указывает имя процедуры и *параметр* указывает параметр процедуры.  
  
 Дополнительные сведения об escape-последовательность вызова процедуры см. в разделе [процедуры Escape-последовательность Call](../../../odbc/reference/appendixes/procedure-call-escape-sequence.md) в грамматику SQL приложение C:.  
  
 Процедура может иметь параметры или не иметь их. Он также может возвращать значение, что указывает необязательный маркер параметра **? =** в начале синтаксиса. Если *параметр* является входным или входным или выходным параметром, это может быть литералом или маркер параметра. Тем не менее взаимодействующие приложения следует всегда использовать маркеры параметров, так как некоторые источники данных не принимают значения параметров literal. Если *параметр* является выходным параметром, он должен быть маркером параметра. Маркеры параметров должен быть связан с **SQLBindParameter** до вызова процедуры выполнения инструкции.  
  
 Входные и входные-выходные параметры в вызовах процедуры могут быть пропущены. Если процедура вызывается со скобками, но без параметров, таких как {вызвать *имя процедуры*()}, драйвер указывает, что источник данных, следует использовать значение по умолчанию для первого параметра. Если процедура не имеет параметров, это может привести к сбою процедуры. Если процедура вызывается без скобок, таких как {вызвать *имя процедуры*}, драйвер не отправляет значений параметров.  
  
 В вызовах процедур можно задавать литералы для входных или входных-выходных параметров. Например, предположим, что процедура **InsertOrder** имеет пять входных параметров. В следующем вызове **InsertOrder** пропущен первый параметр и предоставляет литерал для второго параметра используется маркер параметра для третьего, четвертого и пятого параметров:  
  
```  
{call InsertOrder(, 10, ?, ?, ?)}   // Not interoperable!  
```  
  
 Обратите внимание, что если параметр пропущен, запятая, отделяющая его от других параметров, должна присутствовать. Если пропущен входной или входной-выходной параметр, процедура использует значение по умолчанию. Другой способ указать значение по умолчанию параметра ввода или ввода вывода является установка значение буфера длины и индикатора, привязанное к параметру процедуры SQL_DEFAULT_PARAM.  
  
 Если входной или выходной параметр указан или является литералом, указанное для параметра, драйвер отбрасывает выходное значение. Аналогичным образом, если пропущен маркер параметра для значения, возвращаемого процедурой, драйвер отбрасывает возвращаемое значение. Наконец, если в приложении задан параметр возвращаемого значения для процедуры, которая не возвращает значение, драйвер задает значение буфера длины и индикатора, привязанное к параметру процедуры SQL_NULL_DATA.  
  
 Предположим, что процедура PARTS_IN_ORDERS создает результирующий набор, содержащий список заказов, которые содержат номер конкретного компонента. Следующий код вызывает эту процедуру для номер части 544:  
  
```  
SQLUINTEGER   PartID;  
SQLINTEGER    PartIDInd = 0;  
  
// Bind the parameter.  
SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0,  
                  &PartID, 0, PartIDInd);  
  
// Place the department number in PartID.  
PartID = 544;  
  
// Execute the statement.  
SQLExecDirect(hstmt, "{call PARTS_IN_ORDERS(?)}", SQL_NTS);  
```  
  
 Чтобы определить, поддерживает ли источник данных процедуры, приложение вызывает **SQLGetInfo** с параметром SQL_PROCEDURES.  
  
 Дополнительные сведения о процедурах см. в разделе [процедуры](../../../odbc/reference/develop-app/procedures-odbc.md).
