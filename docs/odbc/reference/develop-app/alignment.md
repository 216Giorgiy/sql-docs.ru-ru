---
title: "Выравнивание | Документы Microsoft"
ms.custom: 
ms.date: 01/19/2017
ms.prod: sql-non-specified
ms.prod_service: drivers
ms.service: 
ms.component: odbc
ms.reviewer: 
ms.suite: sql
ms.technology: drivers
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
caps.latest.revision: "8"
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.workload: Inactive
ms.openlocfilehash: 527e8d47d4d352a0fad579d3c12c5ef3768c402b
ms.sourcegitcommit: cc71f1027884462c359effb898390c8d97eaa414
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="alignment"></a>Выравнивание
Проблемы выравнивания в приложении ODBC обычно не отличаются от они находятся в другом приложении. То есть большинство приложений ODBC имеют несколько или проблем с выравниванием. Штрафов за не выравнивание адреса зависит от оборудования и операционной системы и может быть как значительные как небольшое уменьшение производительности или как фатальной ошибкой во время выполнения. Таким образом приложения ODBC и переносимого приложения ODBC в частности, следует внимательно выравнивание данных должным образом.  
  
 Один пример когда приложения ODBC обнаруживают проблемы выравнивания: они выделить большой блок памяти и привязать различные части памяти со столбцами в результирующий набор. Это наиболее вероятно при универсального приложения необходимо определить форму результирующего набора во время выполнения и выделить, так и привязать памяти соответствующим образом.  
  
 Предположим, что приложение выполняет **ВЫБЕРИТЕ** инструкции, введенные пользователем и извлекает результаты из этой инструкции. Поскольку форма этот результирующий набор неизвестен при записи программы, приложение необходимо определить тип каждого столбца, после создания результирующего набора и привяжите памяти соответствующим образом. Самый простой способ сделать это — выделить большой блок памяти и связать разные адреса в соответствующем блоке каждого столбца. Для доступа к данным в столбце, приложение приводит памяти, привязанного к этому столбцу.  
  
 В примере ниже показан пример результирующий набор и как блок памяти может быть привязан к ней, используя тип данных C по умолчанию для каждого типа данных SQL. Каждый «X» представляет один байт памяти. (Этот пример буферов данных, привязанных к столбцам. Это делается для простоты. В фактический код буфер длины/индикатора тоже должны быть выровнены.)  
  
 ![Привязка по умолчанию тип данных C к типу данных SQL](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 При условии, что связанные адреса хранятся в *адрес* массива, приложение использует следующие выражения для доступа к памяти, связанный с каждым столбцом:  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 Обратите внимание, что адреса, привязанные к второй и третий столбцы запустить на нечетных байт не делится на четыре, соответствующего размеру SDWORD, адрес привязан в третий столбец. На некоторых компьютерах это не будет проблемы; в других версиях это приведет к появлению небольшое уменьшение производительности; на по-прежнему других он вызовет Неустранимая ошибка во время выполнения. Лучшим решением будет выровнять каждый привязан адрес на его естественной границе выравнивания. При условии, что это-1 для UCHAR, 2 для SWORD и 4 для SDWORD это даст результат показан на следующем рисунке, где «X» представляет байт памяти, который используется и «O» представляет байт памяти, который не используется.  
  
 ![Привязка по естественной границе выравнивания](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 Это решение не использует всю память приложения, он не обрабатывает проблемы выравнивания. К сожалению он принимает большого объема кода для реализации этого решения, как каждый столбец должен быть выровнен по отдельности с точки зрения его типа. Простым решением является применение выравнивание всех столбцов на размер наиболее широкой границе выравнивания, равно 4 в примере, показанном на рисунке ниже.  
  
 ![Привязка по наиболее широкой границе выравнивания](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 Несмотря на то, что это решение оставляет больше уязвимости, код для реализации его относительно простой и быстрый. В большинстве случаев это смещения штраф оплачено неиспользуемую память. Пример использования этого метода см. в разделе [с помощью SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md).
