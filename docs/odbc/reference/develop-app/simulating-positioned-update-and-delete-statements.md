---
title: Имитация располагается инструкции Update и Delete | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- positioned deletes [ODBC]
- data updates [ODBC], positioned update or delete
- row identifiers [ODBC]
- positioned updates [ODBC]
- updating data [ODBC], positioned update or delete
ms.assetid: b24ed59f-f25b-4646-a135-5f3596abc1a4
caps.latest.revision: 5
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 1448481938ff0ef8e20ba4e6a85801b65024cbcc
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "32913889"
---
# <a name="simulating-positioned-update-and-delete-statements"></a>Имитация позиционированного обновления и инструкций Delete
Если источник данных не поддерживает позиционированного обновления и удаления, драйвер можно смоделировать эти. Например библиотека курсоров ODBC имитирует позиционированного обновления и удаления инструкций. Общая стратегия для имитации позиционированного обновления и инструкций delete — преобразование позиционированные инструкции для поиска из них. Это делается путем замены **WHERE CURRENT OF** предложение, с которой выполняется поиск **ГДЕ** предложение, определяющее текущую строку.  
  
 Например так как столбец CustID однозначно идентифицирует каждую строку в таблице Customers, позиционированные инструкции удаления  
  
```  
DELETE FROM Customers WHERE CURRENT OF CustCursor  
```  
  
 могут быть преобразованы  
  
```  
DELETE FROM Customers WHERE (CustID = ?)  
```  
  
 Драйвер может использовать один из следующих *идентификаторами строк* в **ГДЕ** предложения:  
  
-   Столбцы, значения которых служат для идентификации однозначно каждой строки в таблице. Например, вызов **SQLSpecialColumns** SQL_BEST_ROWID возвращает оптимальный столбец или набор столбцов, служащих этой цели.  
  
-   Псевдостолбцов, предоставляемые некоторые источники данных для уникальной идентификации каждой строки. Это может также быть извлекаемые путем вызова **SQLSpecialColumns**.  
  
-   Уникальный индекс, если он доступен.  
  
-   Все столбцы в результирующем наборе.  
  
 Только столбцы следует использовать драйвер в **ГДЕ** предложение, он создает зависит от драйвера. Для некоторых данных источников, определение идентификатора строки может потребовать значительных затрат. Тем не менее он быстрее выполнить и гарантирует, что имитацию инструкция обновляет или удаляет в одну строку. В зависимости от возможностей базовой СУБД может оказаться затратным для настройки с помощью идентификатора строки. Тем не менее он быстрее выполнить и гарантирует, что имитацию инструкция обновляет или удаляет только одну строку. Возможность использовать все столбцы в результирующем наборе обычно гораздо проще настроить. Тем не менее работает медленнее для выполнения, и, если столбцы не однозначно идентифицировать строку, может привести к строки обновляемой или удаляемой непреднамеренно, особенно если список выборки для получения результата значение не содержит все столбцы, существующие в базовой таблице.  
  
 В зависимости от того, какой из предыдущего стратегии драйвер поддерживает, приложение можно выбрать стратегию, ему драйвер для использования с атрибутом SQL_ATTR_SIMULATE_CURSOR инструкции. Хотя может показаться странным для приложения риск случайного обновления или удаления строки, приложение можно удалить этот риск, гарантируя, что столбцы в результирующем наборе для уникальной идентификации каждой строки в результирующем наборе. Это экономит драйвер объем работ по необходимости делать это.  
  
 Если драйвер решает использовать идентификатор строки, он перехватывает **SELECT FOR UPDATE** инструкцию, которая создает результирующий набор. Если столбцы в списке выбора, не определяют эффективно строки, драйвер добавляет необходимые столбцы в конец списка выбора. Некоторые источники данных имеют один столбец, который всегда однозначно определяет строку, например столбец ROWID в Oracle; Если такой столбец доступен, драйвер использует его. В противном случае драйвер вызывает **SQLSpecialColumns** для каждой таблицы в **FROM** предложений, чтобы получить список столбцов, которые однозначно определяют каждую строку. Общие ограничения, полученный в результате этого метода — что имитации курсора не выполняется, если имеется более одной таблицы в **FROM** предложения.  
  
 Независимо от того, как драйвер определяет строки, обычно удаляются **FOR UPDATE OF** предложение off **SELECT FOR UPDATE** инструкции перед его отправкой в источнике данных. **Для обновления из** предложение используется только для позиционировать update и delete. Источники данных, которые не поддерживают позиционирован обновления и инструкций delete обычно не поддерживают его.  
  
 Когда приложение отправляет позиционированного обновления или удаления инструкции для выполнения, драйвер заменяет **WHERE CURRENT OF** предложение with **ГДЕ** предложение, содержащее идентификатор строки. Значения этих столбцов извлекаются из кэша поддерживается драйвером для каждого столбца в нем в **ГДЕ** предложения. После заменил драйвер **ГДЕ** предложение, он отправляет инструкцию в источник данных для выполнения.  
  
 Например предположим, что приложение отправляет следующую инструкцию, чтобы создать результирующий набор:  
  
```  
SELECT Name, Address, Phone FROM Customers FOR UPDATE OF Phone, Address  
```  
  
 Если приложение установило SQL_ATTR_SIMULATE_CURSOR для запроса гарантирует уникальность и если источник данных предоставляет псевдо столбец, который всегда однозначно определяет строку, драйвер вызывает **SQLSpecialColumns** для Таблицы Customers, видит, что CustID — ключ к таблице Customers и добавляет его в список выбора и удаляет **FOR UPDATE OF** предложения:  
  
```  
SELECT Name, Address, Phone, CustID FROM Customers  
```  
  
 Если приложение не запросило гарантии уникальности, драйвер удаляет только **FOR UPDATE OF** предложения:  
  
```  
SELECT Name, Address, Phone FROM Customers  
```  
  
 Предположим, что приложение выполняет прокрутку результирующем наборе отправляет инструкцию позиционированного обновления для выполнения, где Cust — имя курсора на результирующем наборе:  
  
```  
UPDATE Customers SET Address = ?, Phone = ? WHERE CURRENT OF Cust  
```  
  
 Если приложение не запросило гарантии уникальности, драйвер заменяет **ГДЕ** предложения и связывает параметр CustID переменной в своем кэше:  
  
```  
UPDATE Customers SET Address = ?, Phone = ? WHERE (CustID = ?)  
```  
  
 Если приложение не запросило гарантии уникальности, драйвер заменяет **ГДЕ** предложения и связывает имя, адрес и телефон параметров в это предложение для переменных в своем кэше:  
  
```  
UPDATE Customers SET Address = ?, Phone = ?  
   WHERE (Name = ?) AND (Address = ?) AND (Phone = ?)  
```
