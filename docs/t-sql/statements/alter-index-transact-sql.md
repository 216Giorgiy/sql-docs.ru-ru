---
title: "Инструкция ALTER INDEX (Transact-SQL) | Документы Microsoft"
ms.custom: 
ms.date: 08/07/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- database-engine
ms.tgt_pltfrm: 
ms.topic: language-reference
f1_keywords:
- ALTER INDEX
- ALTER_INDEX_TSQL
dev_langs:
- TSQL
helpviewer_keywords:
- indexes [SQL Server], reorganizing
- ALTER INDEX statement
- indexes [SQL Server], disabling
- online index operations
- index reorganization [SQL Server]
- ALLOW_ROW_LOCKS option
- ALL keyword
- reorganizing indexes
- constraints [SQL Server], indexes
- row locks [SQL Server]
- index rebuilding [SQL Server]
- rebuilding indexes
- locking [SQL Server], indexes
- partitioned indexes [SQL Server], rebuilding
- defragmenting indexes
- disabling indexes
- XML indexes [SQL Server], modifying
- index modifications [SQL Server]
- indexes [SQL Server], modifying
- index options [SQL Server]
- modifying indexes
- index disabling [SQL Server]
- MAXDOP index option, ALTER INDEX statement
- spatial indexes [SQL Server], modifying
- indexes [SQL Server], options
- ALLOW_PAGE_LOCKS option
- page locks [SQL Server]
ms.assetid: b796c829-ef3a-405c-a784-48286d4fb2b9
caps.latest.revision: 222
author: BYHAM
ms.author: rickbyh
manager: jhubbard
ms.workload: Active
ms.translationtype: MT
ms.sourcegitcommit: 96ec352784f060f444b8adcae6005dd454b3b460
ms.openlocfilehash: f61b6469e40ba303cbff14db9bde15161b225ca7
ms.contentlocale: ru-ru
ms.lasthandoff: 09/27/2017

---
# <a name="alter-index-transact-sql"></a>ALTER INDEX (Transact-SQL)
[!INCLUDE[tsql-appliesto-ss2008-all_md](../../includes/tsql-appliesto-ss2008-all-md.md)]

  Изменяет существующий индекс таблицы или представления (реляционного или XML) посредством отключения, перестройки или реорганизации либо посредством настройки индексных параметров.  
  
 ![Значок ссылки на раздел](../../database-engine/configure-windows/media/topic-link.gif "Значок ссылки на раздел") [Синтаксические обозначения в Transact-SQL](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```  
-- Syntax for SQL Server and SQL Database
  
ALTER INDEX { index_name | ALL } ON <object>  
{  
      REBUILD {  
            [ PARTITION = ALL ] [ WITH ( <rebuild_index_option> [ ,...n ] ) ]   
          | [ PARTITION = partition_number [ WITH ( <single_partition_rebuild_index_option> ) [ ,...n ] ]  
      }  
    | DISABLE  
    | REORGANIZE  [ PARTITION = partition_number ] [ WITH ( <reorganize_option>  ) ]  
    | SET ( <set_index_option> [ ,...n ] )   
    | RESUME [WITH (<resumable_index_options>,[…n])]
    | PAUSE
    | ABORT
}  
[ ; ]  
  
<object> ::=   
{  
    [ database_name. [ schema_name ] . | schema_name. ]   
    table_or_view_name  
}  
  
<rebuild_index_option > ::=  
{  
      PAD_INDEX = { ON | OFF }  
    | FILLFACTOR = fillfactor   
    | SORT_IN_TEMPDB = { ON | OFF }  
    | IGNORE_DUP_KEY = { ON | OFF }  
    | STATISTICS_NORECOMPUTE = { ON | OFF }  
    | STATISTICS_INCREMENTAL = { ON | OFF }  
    | ONLINE = {   
          ON [ ( <low_priority_lock_wait> ) ]   
        | OFF } 
    | RESUMABLE = { ON | OFF } 
    | MAX_DURATION = <time> [MINUTES}     
    | ALLOW_ROW_LOCKS = { ON | OFF }  
    | ALLOW_PAGE_LOCKS = { ON | OFF }  
    | MAXDOP = max_degree_of_parallelism  
    | COMPRESSION_DELAY = {0 | delay [Minutes]}  
    | DATA_COMPRESSION = { NONE | ROW | PAGE | COLUMNSTORE | COLUMNSTORE_ARCHIVE }   
        [ ON PARTITIONS ( {<partition_number> [ TO <partition_number>] } [ , ...n ] ) ]  
}  
  
<single_partition_rebuild_index_option> ::=  
{  
      SORT_IN_TEMPDB = { ON | OFF }  
    | MAXDOP = max_degree_of_parallelism  
    | RESUMABLE = { ON | OFF } 
    | MAX_DURATION = <time> [MINUTES}     
    | DATA_COMPRESSION = { NONE | ROW | PAGE | COLUMNSTORE | COLUMNSTORE_ARCHIVE} }  
    | ONLINE = { ON [ ( <low_priority_lock_wait> ) ] | OFF }  
}  
  
<reorganize_option>::=  
{  
       LOB_COMPACTION = { ON | OFF }  
    |  COMPRESS_ALL_ROW_GROUPS =  { ON | OFF}  
}  
  
<set_index_option>::=  
{  
      ALLOW_ROW_LOCKS = { ON | OFF }  
    | ALLOW_PAGE_LOCKS = { ON | OFF }  
    | IGNORE_DUP_KEY = { ON | OFF }  
    | STATISTICS_NORECOMPUTE = { ON | OFF }  
    | COMPRESSION_DELAY= {0 | delay [Minutes]}  
}  

<resumable_index_option> ::=
 { 
    MAXDOP = max_degree_of_parallelism
    | MAX_DURATION =<time> [MINUTES]
    | <low_priority_lock_wait>  
 }
 
<low_priority_lock_wait>::=  
{  
    WAIT_AT_LOW_PRIORITY ( MAX_DURATION = <time> [ MINUTES ] ,   
                          ABORT_AFTER_WAIT = { NONE | SELF | BLOCKERS } )  
}  

```  
  
```  
-- Syntax for SQL Data Warehouse and Parallel Data Warehouse  
  
ALTER INDEX { index_name | ALL }  
    ON   [ schema_name. ] table_name  
{  
      REBUILD {  
            [ PARTITION = ALL [ WITH ( <rebuild_index_option> ) ] ] 
          | [ PARTITION = partition_number [ WITH ( <single_partition_rebuild_index_option> )] ] 
      }  
    | DISABLE  
    | REORGANIZE [ PARTITION = partition_number ]  
}  
[;]  

<rebuild_index_option > ::=   
{  
    DATA_COMPRESSION = { COLUMNSTORE | COLUMNSTORE_ARCHIVE }
        [ ON PARTITIONS ( {<partition_number> [ TO <partition_number>] } [ , ...n ] ) ]   
}

<single_partition_rebuild_index_option > ::=   
{  
    DATA_COMPRESSION = { COLUMNSTORE | COLUMNSTORE_ARCHIVE }  
}  
  
```    
## <a name="arguments"></a>Аргументы  
 *index_name*  
 Имя индекса. Имена индексов должны быть уникальными в пределах таблицы или представления, но необязательно должны быть уникальными в пределах базы данных. Имена индексов должны соответствовать правилам [идентификаторы](../../relational-databases/databases/database-identifiers.md).  
  
 ALL  
 Указывает все индексы, связанные с таблицей или представлением, независимо от типа индекса. Если указывается ключевое слово ALL, то инструкция не будет выполнена, если один или несколько индексов находятся вне сети или предназначенной только для чтения файловой группе или указанная операция запрещена для одного или нескольких типов индекса. В следующей таблице перечислены операции с индексами и запрещенные типы индексов.  
  
|С помощью ключевого слова ALL с этой операцией|Отказывает, если в таблице имеется один или несколько|  
|----------------------------------------|----------------------------------------|  
|REBUILD WITH ONLINE = ON|XML-индекс<br /><br /> Пространственный индекс<br /><br /> Индекс ColumnStore: **применяется к:** (начиная с SQL Server 2012) SQL Server и базы данных SQL Azure.|  
|REBUILD PARTITION = *partition_number*|Несекционированный, пространственный, отключенный индекс или XML-индекс|  
|REORGANIZE|Индексы с параметром ALLOW_PAGE_LOCKS, равным OFF|  
|РЕОРГАНИЗАЦИЯ РАЗДЕЛА = *partition_number*|Несекционированный, пространственный, отключенный индекс или XML-индекс|  
|IGNORE_DUP_KEY = ON|XML-индекс<br /><br /> Пространственный индекс<br /><br /> Индекс ColumnStore: **применяется к:** (начиная с SQL Server 2012) SQL Server и базы данных SQL Azure.|  
|ONLINE = ON|XML-индекс<br /><br /> Пространственный индекс<br /><br /> Индекс ColumnStore: **применяется к:** (начиная с SQL Server 2012) SQL Server и базы данных SQL Azure.|
| ВОЗОБНОВЛЯЕМЫЕ = ON  | Возобновляемые индексы не поддерживаются с **все** ключевое слово. <br /><br /> **Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии) |   
  
> [!WARNING]
>  Дополнительные сведения об операциях с индексами, которые можно выполнить в сети см. в разделе [рекомендации по сети с индексами](../../relational-databases/indexes/guidelines-for-online-index-operations.md).

 Если все указывается вместе с PARTITION = *partition_number*, все индексы должны быть выровнены. Следовательно, они секционируются на основе эквивалентных функций секционирования. Использование ALL вместе с PARTITION приводит все индексные секции с одинаковым *partition_number* будут перестроены или реорганизованы. Дополнительные сведения о секционированных индексах см. в разделе [Partitioned Tables and Indexes](../../relational-databases/partitions/partitioned-tables-and-indexes.md).  
  
 *database_name*  
 Имя базы данных.  
  
 *schema_name*  
 Имя схемы, которой принадлежит таблица или представление.  
  
 *представления table_or_view_name*  
 Имя таблицы или представления, связанного с индексом. Чтобы отобразить отчет по индексам объекта, используйте [sys.indexes](../../relational-databases/system-catalog-views/sys-indexes-transact-sql.md) представления каталога.  
  
 База данных SQL поддерживает формат трехкомпонентного имени database_name. [schema_name] .table_or_view_name, если database_name — текущая база данных или database_name — база данных tempdb и представления table_or_view_name начинается со знака #.  
  
 ПЕРЕСТРОИТЬ [WITH **(**\<rebuild_index_option > [ **,**... *n*]**)** ]  
 Указывает, что индекс будет перестроен с использованием тех же столбцов, типов индекса, атрибута уникальности и порядка сортировки. Это предложение эквивалентно [DBCC DBREINDEX](../../t-sql/database-console-commands/dbcc-dbreindex-transact-sql.md). REBUILD включает отключенный индекс. При перестройке кластеризованного индекса не перестраиваются ассоциированные некластеризованные индексы, если только не указано ключевое слово ALL. Если параметры индекса не указаны, существующий параметр индекса, значений, хранимых в [sys.indexes](../../relational-databases/system-catalog-views/sys-indexes-transact-sql.md) применяются. Для любого параметра индекса, значение которого не хранится в **sys.indexes**, применяется значение по умолчанию, указанные в определении аргумент параметра.  
  
 Если указано ключевое слово ALL, а базовая таблица реализована в виде кучи, операция перестроения не воздействует на таблицу. Перестраиваются все некластеризованные индексы, ассоциированные с таблицей.  
  
 Возможно минимальное протоколирование операции перестроения, если модель восстановления базы данных настроена на массовый или простой режим.  
  
> [!NOTE]
>  При перестроении первичного XML-индекса индексированная пользовательская таблица недоступна в течение действия операции с индексами.  
  
**Применяется к**: SQL Server (начиная с SQL Server 2012) и базы данных SQL Azure.
  
 Для индексов columnstore, то операция перестроения  
  
1.  Не использует порядок сортировки.  
  
2.  Приобретает монопольную блокировку на таблице или секции на то время, как происходит перестроение.  Во время перестройки данные находятся в автономном режиме и недоступны даже при использовании NOLOCK, RCSI или SI.  
  
3.  Повторно сжимает все данные в columnstore. Во время перестроения существуют две копии индекса columnstore. После завершения перестроения [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] удаляет исходный индекс columnstore.  
  
 Дополнительные сведения о перестроении индексов columnstore см. в разделе [для дефрагментации индексов Columnstore -](../../relational-databases/indexes/columnstore-indexes-defragmentation.md)  
  
PARTITION  

**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.  
  
 Указывает, что только одна секция индекса будет перестроена или реорганизована. СЕКЦИИ не может быть указан, если *index_name* не секционированного индекса.  
  
 PARTITION = ALL, перестроение всех секций.  
  
> [!WARNING]
>  Создание и перестройка невыровненных индексов для таблицы, количество секций в которой превышает 1000, возможны, но не поддерживаются. Это может привести к снижению производительности или чрезмерному потреблению памяти во время таких операций. Если количество секций превышает 1000, рекомендуется использовать только выровненные индексы.  
  
 *partition_number*  
   
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.
  
 Количество секций секционированного индекса, который необходимо перестроить или реорганизовать. *partition_number* является константным выражением, которое может ссылаться на переменные. К ним относятся переменные определяемых пользователем типов или функции и определяемые пользователем функции, но не ссылки на инструкции языка [!INCLUDE[tsql](../../includes/tsql-md.md)]. *partition_number* должен существовать или выполнение инструкции завершается неудачно.  
  
 С **(**\<single_partition_rebuild_index_option >**)**  
   
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.  
  
 Параметр SORT_IN_TEMPDB, MAXDOP и DATA_COMPRESSION — параметры, могут быть указаны при перестроении одиночной секции (СЕКЦИИ =  *n* ). XML-индексы не могут быть указаны в операции перестроения одиночной секции.  
  
 DISABLE  
 Помечает индекс как отключенный и недоступный для использования компонентом [!INCLUDE[ssDE](../../includes/ssde-md.md)]. Любой индекс может быть отключен. Определение отключенного индекса остается в системном каталоге без базовых индексных данных. Отключение кластеризованного индекса блокирует доступ пользователя к данным базовой таблицы. Чтобы активировать индекс, следует использовать инструкцию ALTER INDEX REBUILD или CREATE INDEX WITH DROP_EXISTING. Дополнительные сведения см. в разделе [отключение индексов и ограничений](../../relational-databases/indexes/disable-indexes-and-constraints.md) и [Enable Indexes and Constraints](../../relational-databases/indexes/enable-indexes-and-constraints.md).  
  
 РЕОРГАНИЗАЦИЯ индекса rowstore  
 РЕОРГАНИЗАЦИЯ индексов rowstore, задает для реорганизации конечный уровень индекса.  Операция РЕОРГАНИЗАЦИИ является:  
  
-   Всегда выполняются в сети. Это означает, что долгосрочные блокировки таблицы не удерживаются и запросы или обновления базовой таблицы могут продолжаться во время выполнения транзакции ALTER INDEX REORGANIZE.  
  
-   Не допускается для отключенного индекса  
  
-   Не допускается, если ALLOW_PAGE_LOCKS установлен в OFF  
  
-   Не откатывается она выполняется в рамках транзакции и происходит откат транзакции.  
  
REORGANIZE С **(** LOB_COMPACTION = { **ON** | {OFF} **)**  
 Применяется к индексами rowstore.  
  
LOB_COMPACTION = ON  
  
-   Указывает для сжатия всех страниц, содержащих данные из этих типов данных больших объектов (LOB): изображения, text, ntext, varchar(max), nvarchar(max), varbinary(max) и xml. Сжатие этих данных можно уменьшить размер данных на диске.  
  
-   Для кластеризованного индекса это сжимает все столбцы LOB, содержащиеся в таблице.  
  
-   Для некластеризованного индекса это сжимает все столбцы LOB, являющиеся неключевыми (включенными) столбцами в индексе.  
  
-   РЕОРГАНИЗОВАТЬ все выполняет LOB_COMPACTION всех индексов. Для каждого индекса это сжимает все столбцы LOB в кластеризованном индексе, базовой таблицей или включенные столбцы в некластеризованный индекс.  
  
LOB_COMPACTION = OFF  
  
-   Все страницы, содержащие данные большого объекта, не сжимаются.  
  
-   Параметр OFF не влияет на кучу.  
  
РЕОРГАНИЗАЦИЯ индекса columnstore  
REORGANIZE выполняются в сети.  
  
Для индексов columnstore РЕОРГАНИЗАЦИЯ сжимает каждый ЗАКРЫТОЙ разностной группы строк в columnstore в сжатую группу строк.  
  
-   РЕОРГАНИЗАЦИЯ не требуется для перемещения ЗАКРЫТЫХ разностных групп строк в сжатые группы строк. Фоновый процесс кортежей (TM) периодически активирующийся для сжатия ЗАКРЫТОЙ разностной группы строк. Мы рекомендуем использовать REORGANIZE, когда успевают кортежей. REORGANIZE можно сжать rowgroups более агрессивно.  
  
-   Чтобы сжать все группы строк OPEN и ЗАКРЫТО, появившееся РЕОРГАНИЗОВАТЬ с (COMPRESS_ALL_ROW_GROUPS) в этом разделе.  
  
Для индексов columnstore в SQL Server (начиная с 2016) и базы данных SQL инструкция REORGANIZE выполняет следующие дополнительные дефрагментации оптимизации сети:  
  
-   Физически удаляет строки из группы строк, если были логически удалены 10% или более строк. Удаленные байты освобождают место на физическом носителе. Например если сжатая строка группы 1 миллион строк 100 тысяч строк, удаленных, SQL Server будет удаляет удаленные строки и повторное сжатие группы строк с 900 тысяч строк. Она сохраняет в хранилище путем удаления удаленных строк.  
  
-   Объединяет один или несколько сжатых группах строк для увеличения числа строк для rowgroup, самое большее 1,024,576 строк. Например при массовом импорте 5 пакетов 102 400 строк вы получите 5 сжатых группах строк. При запуске REORGANIZE этих групп строк будет объединить в 1 сжатую группу строк, размер 512,000 строк. Предполагается, что словарь размер или нехватка памяти.  
  
-   Для групп строк, в котором 10% или несколько строк были логически удалены SQL Server попытается объединить этой группы строк с одной или нескольких групп строк.    Например 1 группа строк сжимается с 500 000 строк и группы строк 21 сжимается более 1 048 576 строк.  Группы строк 21 имеет 60% удаляемых строк, который оставляет 409,830 строк. SQL Server поддерживает объединение этих двух групп строк для сжатия новой группы строк, у которого 909,830 строк.  
  
РЕОРГАНИЗОВАТЬ СТРАНИЦЫ С ИСПОЛЬЗОВАНИЕМ (COMPRESS_ALL_ROW_GROUPS = {ON | **OFF** })  
 В SQL Server (начиная с 2016) и базы данных SQL COMPRESS_ALL_ROW_GROUPS позволяет принудительно разностных групп строк OPEN или CLOSED в columnstore. Этот параметр не понадобится перестроить индекс columnstore, чтобы очистить разностных групп строк.  Сочетании с других удаления и слияния дефрагментации компонентов делает его более не является необходимым для перестроения индекса в большинстве случаев.    
-   ON принудительно отправить все группы строк в columnstore независимо от размера и состояние ("ЗАКРЫТ" или "ОТКРЫТЬ").  
  
-   ОТКЛЮЧЕНИЕ заставляет все группы строк CLOSED в columnstore.  
  
ЗАДАТЬ **(** \<set_index параметр > [ **,**... *n*] **)**  
 Указывает параметры индекса без перестройки или реорганизации индекса. SET нельзя указать для отключенного индекса.  
  
PAD_INDEX = { ON | OFF }  
   
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.  
  
 Определяет разреженность индекса. Значение по умолчанию — OFF.  
  
 ON  
 Процент свободного места, определяемый параметром FILLFACTOR, применяется к страницам индекса промежуточного уровня. Если FILLFACTOR не указан одновременно PAD_INDEX установлен в ON, значение коэффициента заполнения, хранящиеся в [sys.indexes](../../relational-databases/system-catalog-views/sys-indexes-transact-sql.md) используется.  
  
 ОТКЛЮЧЕНИЕ или *fillfactor* не указан  
 Страницы промежуточного уровня заполняются почти полностью. При этом остается достаточно места по крайней мере для одной строки максимального размера, которого может достигать индекс, в зависимости от набора ключей в промежуточных страницах.  
  
 Дополнительные сведения см. в разделе [CREATE INDEX (Transact-SQL)](../../t-sql/statements/create-index-transact-sql.md).  
  
FILLFACTOR = *fillfactor*  
 
 **Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.
  
 Определяет величину в процентах, показывающую насколько должен компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] заполнять конечный уровень каждой страницы индекса во время его создания и изменения. *значение коэффициента заполнения* должно быть целым числом от 1 до 100. Значение по умолчанию равно 0. Значения коэффициентов заполнения 0 и 100 идентичны.  
  
 Явный параметр FILLFACTOR применяется, только если индекс создается впервые или перестраивается. Компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] не сохраняет динамически указанный процентный объем свободного места на страницах. Дополнительные сведения см. в разделе [CREATE INDEX (Transact-SQL)](../../t-sql/statements/create-index-transact-sql.md).  
  
 Для просмотра коэффициента заполнения, используйте **sys.indexes**.  
  
> [!IMPORTANT]
>  Создание или замена кластеризованного индекса со значением FILLFACTOR влияет на пространство памяти, занимаемое данными, так как компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] перераспределяет данные при создании кластеризованного индекса.  
  
 ПАРАМЕТР SORT_IN_TEMPDB = {ON | **OFF** }  
 

**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.  
  
 Указывает, следует ли сохранять результаты сортировки в **tempdb**. Значение по умолчанию — OFF.  
  
 ON  
 Промежуточные результаты сортировки, используемые для построения индекса, хранятся в **tempdb**. Если **tempdb** находится на разных наборах дисков пользовательской базы данных, это может уменьшить время, необходимое для создания индекса. Однако это увеличивает использование места на диске, которое используется при индексировании.  
  
 OFF  
 Промежуточные результаты сортировки хранятся в той же базе данных, где и индекс.  
  
 Если выполнение сортировки не требуется или если сортировка может быть выполнена в памяти, параметр SORT_IN_TEMPDB пропускается.  
  
 Дополнительные сведения см. в разделе [параметр SORT_IN_TEMPDB для индексов](../../relational-databases/indexes/sort-in-tempdb-option-for-indexes.md).  
  
 IGNORE_DUP_KEY  **=**  {ON | {OFF}  
 Определяет ответ на ошибку, случающуюся, когда операция вставки пытается вставить в уникальный индекс повторяющиеся значения ключа. Параметр IGNORE_DUP_KEY применяется только к операциям вставки, производимым после создания или перестроения индекса. Значение по умолчанию — OFF.  
  
 ON  
 Если в уникальный индекс вставляются повторяющиеся значения ключа, выводится предупреждающее сообщение. С ошибкой завершаются только строки, нарушающие ограничение уникальности.  
  
 OFF  
 Если в уникальный индекс вставляются повторяющиеся значения ключа, выводится сообщение об ошибке. Будет выполнен откат всей операции INSERT.  
  
 IGNORE_DUP_KEY не может быть присвоено значение ON для индексов, созданных на представлении, неуникальных индексов, XML-индексы, Пространственные индексы и отфильтрованных индексов.  
  
 Для просмотра значения IGNORE_DUP_KEY используйте [sys.indexes](../../relational-databases/system-catalog-views/sys-indexes-transact-sql.md).  
  
 Для обратной совместимости синтаксиса аргумент WITH IGNORE_DUP_KEY эквивалентен аргументу WITH IGNORE_DUP_KEY = ON.  
  
 STATISTICS_NORECOMPUTE  **=**  {ON | {OFF}  
 Указывает, выполнялся ли перерасчет статистики распределения. Значение по умолчанию — OFF.  
  
 ON  
 Устаревшие статистики не пересчитываются автоматически.  
  
 OFF  
 Автоматическое обновление статистических данных включено.  
  
 Чтобы восстановить автоматическое обновление статистики, следует установить STATISTICS_NORECOMPUTE в значение OFF или выполнить UPDATE STATISTICS без предложения NORECOMPUTE.  
  
> [!IMPORTANT]
>  Отключение автоматического перерасчета статистики распределения может помешать оптимизатору запросов выбрать оптимальные планы выполнения запросов, обращенных к таблице.  
  
 STATISTICS_INCREMENTAL = {ON | **OFF** }  
 Когда **ON**, являются статистики создаются как статистики отдельно по секциям. Когда **OFF**, дерево статистик удаляется и [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] повторно вычисляет статистики. Значение по умолчанию — **OFF**.  
  
 Если статистики по секциям не поддерживаются, параметр пропускается и выводится предупреждение. Добавочные статистики не поддерживаются для следующих типов статистических данных.  
  
-   Статистики, созданные с индексами, не выровненными по секциям для базовой таблицы.  
  
-   Статистики, созданные в доступных для чтения базах данных-получателях AlwaysOn.  
  
-   Статистики, созданные в базах данных, доступных только для чтения.  
  
-   Статистики, созданные по фильтрованным индексам.  
  
-   Статистика, созданная по представлениям.  
  
-   Статистики, созданные по внутренним таблицам.  
  
-   Статистики, созданные с пространственными индексами или XML-индексами.  
  
 
**Применяется к**: SQL Server (начиная с SQL Server 2014) и базы данных SQL Azure.  
  
 ONLINE  **=**  {ON | **OFF** } \<применяемое к rebuild_index_option >  
 Определяет, будут ли базовые таблицы и связанные индексы доступны для запросов и изменения данных во время операций с индексами. Значение по умолчанию — OFF.  
  
 Для XML-индекса или пространственного индекса поддерживается только значение ONLINE = OFF; при ONLINE = ON возникает ошибка.  
  
> [!NOTE]
>  Операции с индексами в сети доступны не во всех выпусках [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Сведения о функциях, поддерживаемых различными выпусками [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], см. в статье [Возможности, поддерживаемые различными выпусками SQL Server 2016](../../sql-server/editions-and-supported-features-for-sql-server-2016.md).  
  
 ON  
 Долгосрочные блокировки таблицы не поддерживаются во время операций с индексами. Во время главной фазы операций с индексами только блокировка с намерением совмещаемого доступа (IS) удерживается в исходной таблице. Это позволяет продолжить выполнение запросов или обновлений для базовых таблиц и индексов. В начале операции совмещаемая блокировка (S) исходного объекта поддерживается в течение очень короткого времени. Если создается некластеризованный индекс, то по завершении операции на короткое время создается блокировка типа S (совмещаемая) для источника. Блокировка типа SCH-M (изменения схемы) запрашивается, если кластеризованный индекс создается или удаляется в режиме в сети либо, происходит перестроение кластеризованного или некластеризованного индекса. При создании индекса для временной локальной таблицы параметр ONLINE не может принимать значение ON.  
  
 OFF  
 Блокировки таблиц применяются во время выполнения операций с индексами. Операция с индексами в режиме «вне сети», которая создает, перестраивает или удаляет кластеризованный, пространственный или XML-индекс либо перестраивает или удаляет некластеризованный индекс, получает блокировку изменения схемы (Sch-M) для этой таблицы. Это предотвращает доступ к базовой таблице всех пользователей во время операции. Операция с индексами вне сети, создающая некластеризованный индекс, получает совмещаемую блокировку (S) в таблице. Это запрещает проводить обновления базовой таблицы, но разрешает проводить операции чтения, например инструкции SELECT.  
  
 Дополнительные сведения см. в разделе [как Online операциях с индексом](../../relational-databases/indexes/how-online-index-operations-work.md).  
  
 Индексы, в том числе индексы глобальных временных таблиц, могут быть перестроены в режиме в сети со следующими исключениями:  
  
-   XML-индексы  
  
-   индексы локальных временных таблиц;  
  
-   подмножество секционированного индекса (секционированный индекс можно целиком перестроить в сети).  

-  База данных SQL до версии 12 и SQL Server до SQL Server 2012, не допускают `ONLINE` параметр для построения кластеризованного индекса или перестроить операций, если базовая таблица содержит **varchar(max)** или **varbinary(max)**  столбцов.

ВОЗОБНОВЛЯЕМЫЕ  **=**  {ON | **OFF**}

**Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии)  

 Указывает, является ли операция с индексами возобновляемые.

 В индексе операции возобновляемые.

 ОТКЛЮЧЕНИЕ индекса операция не возобновляемые.

MAX_DURATION  **=**  *время* [**МИНУТ**] используется с **RESUMABLE = ON** (требует **ONLINE = ON**).
 
**Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии)  

Показывает время (целочисленное значение, указанное в минутах), возобновляемые сети операцию index выполняется до приостановки. 

ALLOW_ROW_LOCKS  **=**  { **ON** | {OFF}  
 
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.  
  
 Указывает, разрешена ли блокировка строк. Значение по умолчанию — ON.  
  
 ON  
 Блокировки строк допустимы при доступе к индексу. Компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] определяет, когда используются блокировки строки.  
  
 OFF  
 Блокировки строк не используются.  
  
ALLOW_PAGE_LOCKS  **=**  { **ON** | {OFF}  
  
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.
  
 Указывает, разрешена ли блокировка страниц. Значение по умолчанию — ON.  
  
 ON  
 Блокировки страниц допустимы при доступе к индексу. Компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] определяет, когда используются блокировки страниц.  
  
 OFF  
 Блокировки страниц не используются.  
  
> [!NOTE]
>  Индекс не может быть реорганизован, если ALLOW_PAGE_LOCKS установлен в состояние OFF.  
  
 MAXDOP  **=**  max_degree_of_parallelism  
 
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.  
  
 Переопределяет **максимальная степень параллелизма** параметр конфигурации в течение операции с индексами. Дополнительные сведения см. в разделе [Настройка параметра конфигурации сервера max degree of parallelism](../../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option.md). MAXDOP можно использовать для ограничения числа процессоров, используемых при параллельном выполнении планов. Максимальное число процессоров — 64.  
  
> [!IMPORTANT]
>  Хотя параметр MAXDOP синтаксически поддерживается для всех индексов XML, для пространственного или первичного XML-индекса инструкция ALTER INDEX в настоящее время использует только один процессор.  
  
 *max_degree_of_parallelism* может быть:  
  
 1  
 Подавляет формирование параллельных планов.  
  
 \>1  
 Ограничивает указанным значением максимальное число процессоров, используемых для параллельных операций с индексами.  
  
 0 (по умолчанию)  
 В зависимости от текущей рабочей нагрузки системы использует реальное или меньшее число процессоров.  
  
 Дополнительные сведения см. в статье [Настройка параллельных операций с индексами](../../relational-databases/indexes/configure-parallel-index-operations.md).  
  
> [!NOTE]
>  Параллельные операции с индексами доступны не во всех выпусках [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Сведения о функциях, поддерживаемых различными выпусками [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], см. в статье [Возможности, поддерживаемые различными выпусками SQL Server 2016](../../sql-server/editions-and-supported-features-for-sql-server-2016.md).  
  
 COMPRESSION_DELAY  **=**  { **0** |*длительность [минут]* }  
 Эта функция доступна начиная с SQL Server 2016  
  
 Для таблицы на диске задержка задает минимальное количество минут, которые должны оставаться в состоянии CLOSED разностную группу строк в разностную группу строк, до SQL Server можно сжать в сжатую группу строк. Так как не отслеживания вставки и обновления таблиц на диске время в отдельных строках, SQL Server применяет задержка разностных групп строк в состояние CLOSED.  
Значение по умолчанию — 0 минут.  
  
 Значение по умолчанию — 0 минут.  
  
 Рекомендации о том, когда использовать COMPRESSION_DELAY см индексы Columnstore для операционной аналитики в реальном времени.  
  
 DATA_COMPRESSION  
 Задает режим сжатия данных для указанного индекса, номера секции или диапазона секций. Существуют следующие параметры выбора.  
  
 None  
 Индекс или заданные секции не сжимаются. Это не относится к индексам columnstore.  
  
 ROW  
 Для индекса или заданных секций производится сжатие строк. Это не относится к индексам columnstore.  
  
 PAGE  
 Для индекса или заданных секций производится сжатие страниц. Это не относится к индексам columnstore.  
  
 COLUMNSTORE  
   
**Применяется к**: SQL Server (начиная с SQL Server 2014) и базы данных SQL Azure.
  
 Применяется только к индексам columnstore, включая некластеризованные и кластеризованные индексы columnstore. COLUMNSTORE указывает, что должны быть распакованы индекс или конкретные секции, которые были упакованы с помощью параметра COLUMNSTORE_ARCHIVE. При восстановлении данных сжатие будет продолжаться с применением сжатия columnstore, предусмотренного для всех индексов columnstore.  
  
 COLUMNSTORE_ARCHIVE  
  
**Применяется к**: SQL Server (начиная с SQL Server 2014) и базы данных SQL Azure.
  
 Применяется только к индексам columnstore, включая некластеризованные и кластеризованные индексы columnstore. Параметр COLUMNSTORE_ARCHIVE обеспечивает дальнейшее сжатие указанной секции до еще меньшего размера. Это может использоваться для архивации или в других ситуациях, где требуется уменьшение объема пространства и допускается увеличение затрат времени на сохранение и выборку  
  
 Дополнительные сведения о сжатии см. в разделе [сжатие данных](../../relational-databases/data-compression/data-compression.md).  
  
 В СЕКЦИЯХ **(** { \<выражение_номера_секции > | \<диапазона >} [**,**... n] **)**  
    
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure. 
  
 Указывает секции, к которым применяется параметр DATA_COMPRESSION. Если индекс не секционирован, аргумент ON PARTITIONS создаст ошибку. Если не указано предложение ON PARTITIONS, то параметр DATA_COMPRESSION применяется ко всем секциям секционированного индекса.  
  
 \<выражение_номера_секции > можно указать одним из следующих способов:  
  
-   Указать номер секции, например ON PARTITIONS (2).  
  
-   Указать номера нескольких секций через запятые, например ON PARTITIONS (1, 5).  
  
-   Указать диапазоны и отдельные секции: ON PARTITIONS (2, 4, 6 TO 8).  
  
 \<диапазон > можно указать как номера секций, разделенные словом TO, например: ON PARTITIONS (6 – 8).  
  
 Чтобы для разных секций задать разные типы сжатия данных, укажите параметр DATA_COMPRESSION несколько раз, например следующим образом.  
  
```tsql  
REBUILD WITH   
(  
DATA_COMPRESSION = NONE ON PARTITIONS (1),   
DATA_COMPRESSION = ROW ON PARTITIONS (2, 4, 6 TO 8),   
DATA_COMPRESSION = PAGE ON PARTITIONS (3, 5)  
);  
```  
  
 ONLINE  **=**  {ON | **OFF** } \<применяемое к single_partition_rebuild_index_option >  
 Указывает, является ли секция индекса базовой таблицы или индекса могут быть перестроены в интерактивном или автономном режиме. Если **ПЕРЕСТРОИТЬ** выполняются в сети (**ON**) в этой таблице становятся доступными для запросов и изменения данных во время обработки индекса.  Значение по умолчанию — **OFF**.  
  
 ON  
 Долгосрочные блокировки таблицы не поддерживаются во время операций с индексами. Во время главной фазы операций с индексами только блокировка с намерением совмещаемого доступа (IS) удерживается в исходной таблице. S-блокировки таблицы является обязательным в начале перестройки индекса и блокировка Sch-M на таблице в конце перестроения индекса в сети. Обе блокировки являются короткими блокировками метаданных, но при этом блокировка изменения схемы (Sch-M) должна ожидать завершения всех блокирующих транзакций. Во время ожидания Sch-M блокирует все другие транзакции, ожидающие за этой блокировкой доступа к одной таблице.  
  
> [!NOTE]
>  Перестроение индекса в сети можно задать *low_priority_lock_wait* параметров, описанных далее в этом разделе.  
  
 OFF  
 Блокировки таблиц применяются во время выполнения операций с индексами. Это предотвращает доступ к базовой таблице всех пользователей во время операции.  
  
 Использовать WAIT_AT_LOW_PRIORITY с **ONLINE = ON** только.  
 
**Применяется к**: SQL Server (начиная с SQL Server 2014) и базы данных SQL Azure.
  
 Перестроение индекса в режиме «в сети» должно ожидать операции блокировки в этой таблице. **WAIT_AT_LOW_PRIORITY** указывает, что операция перестроения индекса в сети будет ожидать блокировки с низким приоритетом, позволяя другим операциям продолжить, время ожидания операции оперативного построения индекса. Пропуск **WAIT AT LOW PRIORITY** параметр эквивалентен `WAIT_AT_LOW_PRIORITY (MAX_DURATION = 0 minutes, ABORT_AFTER_WAIT = NONE)`. Дополнительные сведения см. в разделе [WAIT_AT_LOW_PRIORITY](alter-index-transact-sql.md). 
  
 MAX_DURATION = *время* [**МИНУТ**]  
  
**Применяется к**: SQL Server (начиная с SQL Server 2014) и базы данных SQL Azure.
  
 Время ожидания (целочисленное значение, указанное в минутах) в течение которого блокировки для операции перестроения индекса в режиме «в сети» будут ожидать с низким приоритетом при выполнении команды DDL. Если операция будет заблокирована для **MAX_DURATION** время один из **ABORT_AFTER_WAIT** будут выполняться действия. **MAX_DURATION** времени всегда находится в минутах и слово **МИНУТ** можно опустить.  
 
 ABORT_AFTER_WAIT = [**NONE** | **SELF** | **ПРЕПЯТСТВИЯ** }]  
   
**Применяется к**: SQL Server (начиная с SQL Server 2014) и базы данных SQL Azure.
  
 None  
 Продолжить ожидание блокировки с обычным приоритетом.  
  
 SELF  
 Прекратить операцию DDL по перестроению индекса в режиме «в сети», выполняемую в данный момент без выполнения какого-либо действия.  
  
 BLOCKERS  
 Остановить все пользовательские транзакции, в данный момент блокирующие операцию DDL по перестроению индекса в режиме «в сети», чтобы можно было продолжить данную операцию. **BLOCKERS** параметр требует имени входа **разрешение ALTER ANY CONNECTION** разрешение.  
 
 RESUME 
 
**Применяется к**: начиная с SQL Server 2017 г. (компонент находится в общедоступной предварительной версии)

Возобновите операции индекса, приостановлена вручную или из-за сбоя.

Использовать MAX_DURATION с **RESUMABLE = ON**

 
**Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии)

Время (целочисленное значение, указанное в минутах) возобновляемые индексами при выполнении после возобновления. После истечения этого срока, возобновление операции приостановлена, если оно все еще выполняется.

Использовать WAIT_AT_LOW_PRIORITY с **RESUMABLE = ON** и **ONLINE = ON**.  
  
**Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии)
  
 Возобновление перестроения индекса в сети после паузы должно ожидать операции блокировки в этой таблице. **WAIT_AT_LOW_PRIORITY** указывает, что операция перестроения индекса в сети будет ожидать блокировки с низким приоритетом, позволяя другим операциям продолжить, время ожидания операции оперативного построения индекса. Пропуск **WAIT AT LOW PRIORITY** параметр эквивалентен `WAIT_AT_LOW_PRIORITY (MAX_DURATION = 0 minutes, ABORT_AFTER_WAIT = NONE)`. Дополнительные сведения см. в разделе [WAIT_AT_LOW_PRIORITY](alter-index-transact-sql.md). 


ПРИОСТАНОВКА
 
**Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии)
  
Приостановите операцию восстановления возобновляемые индексами в сети.

ПРЕРЫВАНИЕ

**Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии)   

Прерывания работы или приостановки операции с индексами, объявленного как возобновляемые. Необходимо явно выполнить **ПРЕРВАТЬ** операция перестроения возобновляемые индекс прекращение выполнения команды. Сбой или приостановка и операции с индексами возобновляемые не прекращает его выполнения. Вместо этого он сохраняет Пауза неопределенное состояние операции.
  
## <a name="remarks"></a>Замечания  
 Инструкция ALTER INDEX не может использоваться для повторного секционирования индекса или его перемещения в другую файловую группу. Эта инструкция не может использоваться для изменения определения индекса, в том числе добавления или удаления столбцов или изменения порядка столбцов. Для выполнения этих операций следует использовать инструкцию CREATE INDEX с предложением DROP_EXISTING.  
  
 Если параметр не указан явно, то применяется текущий параметр. Например, если параметр FILLFACTOR не указан в предложении REBUILD, то коэффициент заполнения, сохраненный в системном каталоге, будет использоваться в процессе перестроения. Для просмотра текущего параметра индекса, используйте [sys.indexes](../../relational-databases/system-catalog-views/sys-indexes-transact-sql.md).  
  
> [!NOTE]
>  Значения для параметров ONLINE, MAXDOP и SORT_IN_TEMPDB не хранятся в системном каталоге. Если значение некоторого параметра не указано в инструкции индекса, то используется значение по умолчанию.
  
 В компьютерах с несколькими процессорами инструкция ALTER INDEX REBUILD, как и другие запросы, использует больше процессоров для операций просмотра и сортировки, связанных с изменением индекса. При выполнении инструкции ALTER INDEX REORGANIZE, с предложением LOB_COMPACTION или без **максимальная степень параллелизма** значение является однопотоковой операцией. Дополнительные сведения см. в статье [Настройка параллельных операций с индексами](../../relational-databases/indexes/configure-parallel-index-operations.md).  
  
 Индекс нельзя реорганизовать или перестроить, если файловая группа, в которой он находится, размещена вне сети или предназначена только для чтения. Если указывается ключевое слово ALL, а один или несколько индексов находятся в файловой группе, которая размещена вне сети или предназначена только для чтения, то выполнить инструкцию не удастся.  
  
## <a name="rebuilding-indexes"></a>Перестроение индексов  
 При перестроении старый индекс удаляется, и создается новый. Таким образом, устраняется фрагментация, восстанавливается место на диске путем сжатия страниц с учетом указанного или существующего коэффициента заполнения, переупорядочиваются индексные строки в последовательных страницах. Если указывается ключевое слово ALL, то все индексы для таблицы удаляются и перестраиваются в одной транзакции. Ограничения FOREIGN KEY не обязательно отменять заранее. Если перестраиваются индексы с 128 или большим числом экстентов, то компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] откладывает процедуры освобождения страниц и связанные с ними блокировки до фиксации транзакции.  
  
 Перестроение или реорганизация малых индексов часто не приводит к уменьшению фрагментации. Страницы индексов малого размера хранятся в смешанных экстентах. Смешанные экстенты могут находиться в общем пользовании у восьми объектов, поэтому фрагментацию в малом индексе нельзя уменьшить путем его реорганизации или перестроения.  
  
 Начиная с выпуска [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]статистические данные не создаются путем сканирования всех строк таблицы при создании или перестроении секционированного индекса. Вместо этого оптимизатор запросов использует для создания статистики алгоритм выборки по умолчанию. Для получения статистики по секционированным индексам путем сканирования всех строк таблицы используйте инструкции CREATE STATISTICS или UPDATE STATISTICS с предложением FULLSCAN.  
  
 В предыдущих версиях [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] иногда можно было перестроить некластеризованный индекс, чтобы исправить несоответствия, вызванные отказами оборудования. В [!INCLUDE[ssKatmai](../../includes/sskatmai-md.md)] и более поздних версиях по-прежнему можно скорректировать такие несоответствия между индексом и кластеризованным индексом, перестроив некластеризованный индекс в режиме «вне сети». Однако нельзя устранить несоответствия некластеризованного индекса, перестроив индекс в режиме в сети, потому что механизм перестроения в этом режиме будет использовать существующий некластеризованный индекс в качестве основы для перестроения и тем самым закрепит несоответствие. При автономном перестроении индекса иногда может принудительно запускаться проверка кластеризованного индекса (или кучи), и в результате устраняются несоответствия. Чтобы обеспечить перестроение из кластеризованного индекса, удалите и повторно создайте некластеризованный индекс. В предыдущих версиях рекомендованным методом устранения несоответствий было восстановление неправильных данных из резервных копий, однако исправить несоответствия индекса можно, перестроив некластеризованный индекс в режиме «вне сети». Дополнительные сведения см. в разделе [DBCC CHECKDB (Transact-SQL)](../../t-sql/database-console-commands/dbcc-checkdb-transact-sql.md).  
  
 Перестроение кластеризованного индекса columnstore, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]:  
  
1.  Приобретает монопольную блокировку на таблице или секции на то время, как происходит перестроение. Во время перестроения данные находятся в режиме «вне сети» и недоступны.  
  
2.  Дефрагментирует таблицу columnstore, физически удаляя строки, которые были логически удалены из таблиц; удаленные байты освобождают место на физическом носителе.  
  
3.  Считывает все данные из исходного индекса columnstore, включая deltastore. Объединяет данные в новые группы строк и сжимает columnstore в группы строк.  
  
4.  Требует места на физическом носителе для хранения двух копий индекса columnstore, пока происходит его перестроение. После завершения перестроения [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] удаляет исходный кластеризованный индекс columnstore.  
  
## <a name="reorganizing-indexes"></a>Реорганизация индексов  
 Для реорганизации индекса требуется минимальный объем системных ресурсов. При реорганизации концевой уровень кластеризованных и некластеризованных индексов на таблицах и представлениях дефрагментируется путем физической реорганизации страниц конечного уровня, в результате чего они выстраиваются в соответствии с логическим порядком конечных узлов (слева направо). Кроме того, реорганизация сжимает страницы индекса. Их сжатие производится в соответствии с текущим значением коэффициента заполнения. Для просмотра коэффициента заполнения, используйте [sys.indexes](../../relational-databases/system-catalog-views/sys-indexes-transact-sql.md).  
  
 Если указывается ключевое слово ALL, то реляционные индексы, как кластеризованные, так и некластеризованные, и XML-индексы для таблицы реорганизуются. Существуют некоторые ограничения при указании ключевого слова ALL, см. определение ALL в разделе «Аргументы».  
  
 Дополнительные сведения см. в статье [Реорганизация и перестроение индексов](../../relational-databases/indexes/reorganize-and-rebuild-indexes.md).  
  
## <a name="disabling-indexes"></a>Отключение индексов  
 Отключение индексов предотвращает доступ пользователя к индексам в случае использования кластеризованных индексов к данным базовой таблицы. Определение индекса остается в системном каталоге. Отключение некластеризованных индексов или кластеризованных индексов в представлении физически удаляет данные индекса. При отключении кластеризованного индекса блокируется доступ к данным, но данные остаются необслуживаемыми в сбалансированном дереве до тех пор, пока индекс не будет удален или перестроен. Для просмотра состояния включенного или отключенного индекса запрос **is_disabled** столбца в **sys.indexes** представления каталога.  
  
 Если таблица входит в публикацию репликации транзакций, то нельзя отключить никакие индексы, связанные с первичными ключевыми столбцами. Эти индексы необходимы для репликации. Чтобы отключить индексы, сначала необходимо удалить таблицу из публикации. Дополнительные сведения см. в статье [Публикация данных и объектов базы данных](../../relational-databases/replication/publish/publish-data-and-database-objects.md).  
  
 Для активизации индекса следует использовать инструкцию ALTER INDEX REBUILD или инструкцию CREATE INDEX WITH DROP_EXISTING. Перестроить отключенный кластеризованный индекс нельзя, если параметр ONLINE установлен в ON. Дополнительные сведения см. в статье [Отключение индексов и ограничений](../../relational-databases/indexes/disable-indexes-and-constraints.md).  
  
## <a name="setting-options"></a>Настройка параметров  
 Можно установить параметры ALLOW_ROW_LOCKS, ALLOW_PAGE_LOCKS, IGNORE_DUP_KEY и STATISTICS_NORECOMPUTE для конкретного индекса без перестройки или реорганизации этого индекса. Измененные значения немедленно применяются к индексу. Чтобы просмотреть эти параметры, используйте **sys.indexes**. Дополнительные сведения см. в разделе [Установка параметров индекса](../../relational-databases/indexes/set-index-options.md).  
  
### <a name="row-and-page-locks-options"></a>Параметры блокировок строк и страниц  
 Когда присвоены значения ALLOW_ROW_LOCKS = ON и ALLOW_PAGE_LOCK = ON, при доступе к индексу допустимы блокировки на уровне строк, уровне страниц и уровне таблиц. Компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] выбирает соответствующую блокировку и может повышать уровень с блокировки строки или страницы до блокировки таблицы.  
  
 Если присвоены значения ALLOW_ROW_LOCKS = OFF и ALLOW_PAGE_LOCK = OFF, при доступе к индексу допустима только блокировка на уровне таблиц.  
  
 Если при установке параметров блокировки строки или страницы указывается ключевое слово ALL, то установки применяются ко всем индексам. Если базовая таблица представляет собой кучу, установки применяются следующими способами:  
  
|||  
|-|-|  
|ALLOW_ROW_LOCKS = ON или OFF|Для кучи и любых соответствующих некластеризованных индексов.|  
|ALLOW_PAGE_LOCKS = ON|Для кучи и любых соответствующих некластеризованных индексов.|  
|ALLOW_PAGE_LOCKS = OFF|Полностью для некластеризованных индексов. Это означает, что все блокировки страниц запрещаются для некластеризованных индексов. В куче запрещены только общая блокировка (S), блокировка обновления (U) и монопольная блокировка (X) для страниц. Компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] может запросить намеренную блокировку страницы (IS, IU или IX) для внутренних целей.|  
  
## <a name="online-index-operations"></a>Операции с индексами в сети  
 Если при перестройке индекса параметр ONLINE установлен в значение ON, то базовые объекты, таблицы и связанные с ними индексы доступны для запросов и изменения данных. Можно также перестроить в режиме «в сети» часть индекса, находящегося в одной секции. Монопольные блокировки таблиц удерживаются лишь на очень короткое время в процессе изменения.  
  
 Реорганизация индекса всегда выполняется в режиме в сети. Процесс не удерживает блокировку в течение долгого времени и поэтому не блокирует выполняемые запросы и обновления.  
  
 Параллельные операции с индексами в режиме «в сети» для одной таблицы или секции можно выполнять лишь при выполнении следующих действий:  
  
-   создание нескольких некластеризованных индексов;  
  
-   реорганизация различных индексов в одной таблице;  
  
-   реорганизация различных индексов при перестройке неперекрывающихся индексов в одной таблице.  
  
 Все остальные попытки выполнения операций с индексами в сети завершаются ошибкой. Например, нельзя одновременно перестроить два или несколько индексов в одной таблице или создать новый индекс в процессе перестройки существующего индекса для этой таблицы.  

### <a name="resumable-index-operations"></a>Возобновляемые индекса

**Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии)

ПЕРЕСТРОЕНИЕ ИНДЕКСА ONLINE указывается как возобновляемые с помощью RESUMABLE = на параметр. 
-  ВОЗОБНОВЛЯЕМЫЕ параметр не сохраняется в метаданных для указанного индекса и применяется только к на время выполнения текущей инструкции DDL. Таким образом, RESUMABLE = ON предложения должен быть явно указан для включения resumability.

-  Обратите внимание два различных варианта MAX_DURATION. Один относится к low_priority_lock_wait и другой связана с RESUMABLE = на параметр.
   -  Значение параметра MAX_DURATION поддерживается для RESUMABLE = на параметр или **low_priority_lock_wait** аргумент параметра. 
   MAX_DURATION ВОЗОБНОВЛЯЕМЫЕ параметр задает интервал времени для выполняется перестроение индекса. После этого времени используется перестроения индекса либо приостановлена или завершении его выполнения. Пользователь решает, когда rebuild для приостановленного индекса может быть продолжено. **Время** в минутах, MAX_DURATION должно быть больше, чем 0 минут и меньше или равно 1 неделя (7 x 24 x 60 = 10080 минут). Наличие длиннее для операций с индексами могут повлиять на производительность DML для конкретной таблицы, а также емкость диска базы данных, поскольку оба индексирует оригинального и только что созданной требуется место на диске и необходимо обновить во время операций DML. Если указано значение параметра MAX_DURATION, операции с индексами продолжится до его завершения или до момента возникновения сбоя. 
-   \<Low_priority_lock_wait > аргумент позволяет решить, как операции с индексами можно продолжить при блокировке на блокировку SCH-M.
 
-  Повторное выполнение первоначальной инструкции ALTER INDEX REBUILD с теми же параметрами возобновляет приостановленное перестроение индекса. Также можно возобновить приостановленный перестроение индекса, выполнив инструкцию ALTER INDEX ВОЗОБНОВИТЬ.
-  Параметр SORT_IN_TEMPDB = ON не поддерживается для возобновляемой индекса 
-  Команда DDL с RESUMABLE = ON не может быть выполнена внутри явной транзакции (не может быть частью begin tran... блок фиксации).
-  Только операции с индексами, которые приостановлены возобновляемые.
-   При возобновлении операции индекса, приостановлен, можно изменить значение MAXDOP для него новое значение.  Если MAXDOP не указан при возобновлении операции индекса, приостановлен, берется последнее значение MAXDOP. Если параметр MAXDOP вообще не указан для операции перестроения индекса, берется значение по умолчанию.
- Чтобы приостановить немедленно операции с индексами, можно остановить текущую команду (Ctrl-C) или можно выполнить команду ALTER INDEX ПРИОСТАНОВКИ или выполнения инструкции KILL *session_id* команды. После приостановки команда его можно возобновить с помощью параметра RESUME.
-  Команда ПРЕРЫВАНИЯ разрывает сеанс, размещенных исходное перестроение индекса и прерывает выполнение операции с индексами  
-  Нет дополнительных ресурсов необходимы для перестроения индекса в возобновляемой, за исключением
   -    Дополнительное место для сохранения индекс создающимся, необходимо, включая время, когда индекс будет приостановлена
   -    Состояние DDL, предотвращая каких-либо изменений DDL
-  Процесс очистки фантомных записей, которые будут выполняться во время фазы Пауза индекса, но он будет приостановлен во время выполнения индекса   
Следующие функциональные возможности отключена для операции перестроения индекса возобновляемые
   -    Перестроение индекса, которая отключена не поддерживается с RESUMABLE = ON
   -    Инструкция ALTER INDEX REBUILD ALL команды
   -    ALTER TABLE с помощью перестроение индекса  
   -    Команда DDL с «RESUMEABLE = ON» не может быть выполнена внутри явной транзакции (не может быть частью begin tran... блок фиксации)
   -    Повторное построение индекса, который содержит вычисляемые или столбцы отметок времени в качестве ключевых столбцов.
-   В случае, если базовая таблица содержит столбцы возобновляемые кластеризованный перестроение индекса требуется блокировка Sch-M в начале этой операции
   -    Параметр SORT_IN_TEMPDB = ON не поддерживается для возобновляемой индекса 

> [!NOTE]
> Команда DDL выполняется до завершения, приостанавливается или сбоя. В случае, если команда приостанавливает, возникнет ошибка, указывающее, что операция была приостановлена и что не удалось завершить создание индекса. Дополнительные сведения о текущем состоянии индекса можно получить из [sys.index_resumable_operations](../../relational-databases/system-catalog-views/sys-index-resumable-operations.md). Как перед в случае сбоя ошибки будут выдаваться также. 

  
 Дополнительные сведения см. в статье [Perform Index Operations Online](../../relational-databases/indexes/perform-index-operations-online.md).  
  
 ### <a name="waitatlowpriority-with-online-index-operations"></a>WAIT_AT_LOW_PRIORITY с операций с индексами  
  
 Для выполнения инструкции DDL для перестроения индекса в режиме «в сети» все активные блокирующие транзакции, выполняемые для конкретной таблицы, должны быть завершены. Если выполняется перестроение индекса в режиме «в сети», то все новые транзакции, готовые к выполнению на данной таблице, блокируются. Хотя продолжительность блокировки для перестроения индекса в режиме «в сети» очень коротка, ожидание завершения всех открытых транзакций на данной таблице и блокировка новых запускаемых транзакций может значительно отразиться на пропускной способности и времени выполнения операции, а также значительно ограничить доступ к базовой таблице. **WAIT_AT_LOW_PRIORITY** параметр позволяет администратору базы данных управлять S-lock и Sch-M блокировками, необходимыми для индекса в сети перестраивает и их можно выбрать один из трех значений. Во всех 3 случаях, если во время ожидания ( `(MAX_DURATION = n [minutes])` ), блокирующих действий нет, перестроение индекса в сети выполняется немедленно, без ожидания и завершения инструкции DDL.  
  
## <a name="spatial-index-restrictions"></a>Ограничения пространственного индекса  
 При перестроении пространственного индекса базовая пользовательская таблица недоступна на протяжении выполнения операции с индексом, поскольку пространственный индекс блокирует схему.  
  
 Ограничение PRIMARY KEY в пользовательской таблице не может быть изменено, пока для столбца этой таблицы определен пространственный индекс. Для изменения ограничения PRIMARY KEY сначала необходимо удалить все пространственные индексы таблицы. После изменения ограничения PRIMARY KEY все пространственные индексы можно создать повторно.  
  
 В отдельной операции перестроения секции невозможно указать пространственные индексы. Однако пространственные индексы можно указать при полном перестроении секции.  
  
 Чтобы изменить параметры, характерные для пространственного индекса (такие как BOUNDING_BOX или GRID), необходимо либо применить инструкцию CREATE SPATIAL INDEX с параметром DROP_EXISTING = ON, либо удалить пространственный индекс и создать новый. Пример см. в разделе [CREATE SPATIAL INDEX (Transact-SQL)](../../t-sql/statements/create-spatial-index-transact-sql.md).  
  
## <a name="data-compression"></a>Data Compression  
 Дополнительную информацию о сжатии данных см. в разделе [Сжатие данных](../../relational-databases/data-compression/data-compression.md).  
  
 Чтобы оценить, как изменение сжатия PAGE и ROW повлияет на таблицы, индекса или секции, использовать [sp_estimate_data_compression_savings](../../relational-databases/system-stored-procedures/sp-estimate-data-compression-savings-transact-sql.md) хранимой процедуры.  
  
 На секционированные индексы налагаются следующие ограничения.  
  
-   При использовании `ALTER INDEX ALL ...`, невозможно изменить настройку сжатия отдельной секции Если у таблицы есть невыровненные индексы.  
  
-   ALTER INDEX \<index >... Инструкция REBUILD PARTITION ... производит перестроение указанной секции индекса.  
  
-   ALTER INDEX \<index >... Инструкция REBUILD WITH ... производит перестроение всех секций индекса.  
  
## <a name="statistics"></a>Statistics  
 При выполнении **инструкция ALTER INDEX ALL...** в таблице обновляются только статистические данные связаны с индексами. Автоматические или созданные вручную статические данные таблицы (вместо индекса) не обновляются.  
  
## <a name="permissions"></a>Permissions  
 Для выполнения ALTER INDEX необходимо иметь как минимум разрешение ALTER для таблицы или представления.  
  
## <a name="version-notes"></a>Заметки о версии  
  
-   База данных SQL не использует параметры файловой группы и filestream.  
  
-   Индексы ColumnStore недоступны до версии SQL Server 2012. 

-  Операции с индексами возобновляемые доступных в 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии) |   
  
## <a name="basic-syntax-example"></a>Пример простого синтаксиса:   
  
```tsql 
ALTER INDEX index1 ON table1 REBUILD;  
  
ALTER INDEX ALL ON table1 REBUILD;  
  
ALTER INDEX ALL ON dbo.table1 REBUILD;  
```

## <a name="examples-columnstore-indexes"></a>Примеры: Индексы Columnstore  
 В этих примерах применяется к индексам columnstore.  
  
### <a name="a-reorganize-demo"></a>A. РЕОРГАНИЗАЦИЯ demo  
 Этот пример демонстрирует, как работает команда ALTER INDEX REORGANIZE.  Он создает таблицу, которая имеет несколько групп строк и показано, как РЕОРГАНИЗОВАТЬ объединяет эти группы строк.  
  
```  
-- Create a database   
CREATE DATABASE [ columnstore ];  
GO  
  
-- Create a rowstore staging table  
CREATE TABLE [ staging ] (  
     AccountKey              int NOT NULL,  
     AccountDescription      nvarchar (50),  
     AccountType             nvarchar(50),  
     AccountCodeAlternateKey     int  
     )  
  
-- Insert 10 million rows into the staging table.   
DECLARE @loop int  
DECLARE @AccountDescription varchar(50)  
DECLARE @AccountKey int  
DECLARE @AccountType varchar(50)  
DECLARE @AccountCode int  
  
SELECT @loop = 0  
BEGIN TRAN  
    WHILE (@loop < 300000)   
      BEGIN  
        SELECT @AccountKey = CAST (RAND()*10000000 as int);  
        SELECT @AccountDescription = 'accountdesc ' + CONVERT(varchar(20), @AccountKey);  
        SELECT @AccountType = 'AccountType ' + CONVERT(varchar(20), @AccountKey);  
        SELECT @AccountCode =  CAST (RAND()*10000000 as int);  
  
        INSERT INTO  staging VALUES (@AccountKey, @AccountDescription, @AccountType, @AccountCode);  
  
        SELECT @loop = @loop + 1;  
    END  
COMMIT  
  
-- Create a table for the clustered columnstore index  
  
CREATE TABLE cci_target (  
     AccountKey              int NOT NULL,  
     AccountDescription      nvarchar (50),  
     AccountType             nvarchar(50),  
     AccountCodeAlternateKey int  
     )  
  
-- Convert the table to a clustered columnstore index named inxcci_cci_target;  
```tsql
CREATE CLUSTERED COLUMNSTORE INDEX idxcci_cci_target ON cci_target;  
```  
  
 Используйте параметр TABLOCK для вставки строк в параллельном режиме. Начиная с SQL Server 2016, операция INSERT INTO могут выполняться параллельно при использовании TABLOCK.  
  
```tsql  
INSERT INTO cci_target WITH (TABLOCK) 
SELECT TOP 300000 * FROM staging;  
```  
  
 Выполните следующую команду для просмотра ОТКРЫТЫХ разностных групп строк. Количество групп строк зависит от степени параллелизма.  
  
```tsql  
SELECT *   
FROM sys.dm_db_column_store_row_group_physical_stats   
WHERE object_id  = object_id('cci_target');  
```  
  
 Выполните эту команду можно принудительно отправить все ЗАКРЫТО и групп строк OPEN в columnstore.  
  
```tsql  
ALTER INDEX idxcci_cci_target ON cci_target REORGANIZE WITH (COMPRESS_ALL_ROW_GROUPS = ON);  
```  
  
 Снова выполнить эту команду, и вы увидите, что небольших групп строк объединяются в одну сжатую группу строк.  
  
```tsql  
ALTER INDEX idxcci_cci_target ON cci_target REORGANIZE WITH (COMPRESS_ALL_ROW_GROUPS = ON);  
```  
  
### <a name="b-compress-closed-delta-rowgroups-into-the-columnstore"></a>Б. Сжатие ЗАКРЫТЫЕ разностные группы строк в columnstore  
 В этом примере используется REORGANIZE для параметра сжимает каждый ЗАКРЫТОЙ разностной группы строк в columnstore в сжатую группу строк.   Это не является обязательным, но полезно, когда задача переноса кортежей не сжимает ЗАКРЫТЫЕ группы строк достаточно быстро.  
  
```tsql  
-- Uses AdventureWorksDW  
-- REORGANIZE all partitions  
ALTER INDEX cci_FactInternetSales2 ON FactInternetSales2 REORGANIZE;  
  
-- REORGANIZE a specific partition  
ALTER INDEX cci_FactInternetSales2 ON FactInternetSales2 REORGANIZE PARTITION = 0;  
```  
  
### <a name="c-compress-all-open-and-closed-delta-rowgroups-into-the-columnstore"></a>В. Сжатие всех ОТКРЫТЫХ и ЗАКРЫТЫ разностных групп строк в columnstore  
 Не применяется к: SQL Server 2012 и 2014  
  
 Начиная с SQL Server 2016, можно выполнить REORGANIZE WITH (COMPRESS_ALL_ROW_GROUPS = ON) для сжатия каждого ОТКРЫТИЯ и ЗАКРЫТО разностную группу строк; в качестве сжатая группа строк columnstore.    Это очищает таблиц deltastore и перемещает все строки, чтобы получить сжатия в columnstore. Это полезно особенно после выполнения многих операций insert, так как эти операции хранения строк в одну или несколько deltastore.  
  
 REORGANIZE объединяет группы строк для заполнения группы строк до максимального числа строк \<= 1,024,576. Таким образом после сжатия всех групп строк OPEN» и «ЗАКРЫТО вы не получаете большое количество сжатых группах строк, которые имеют только небольшое число строк в них. Вы хотите rowgroups как полными максимально сократить размер в сжатом виде и повысить производительность запросов.  
  
```tsql  
-- Uses AdventureWorksDW2016  
-- Move all OPEN and CLOSED delta rowgroups into the columnstore.  
ALTER INDEX cci_FactInternetSales2 ON FactInternetSales2 REORGANIZE WITH (COMPRESS_ALL_ROW_GROUPS = ON);  
  
-- For a specific partition, move all OPEN AND CLOSED delta rowgroups into the columnstore  
ALTER INDEX cci_FactInternetSales2 ON FactInternetSales2 REORGANIZE PARTITION = 0 WITH (COMPRESS_ALL_ROW_GROUPS = ON);  
```  
  
### <a name="d-defragment-a-columnstore-index-online"></a>Г. Дефрагментация индекса columnstore в оперативном режиме  
 Не применяется к: SQL Server 2012 и 2014.  
  
 Начиная с SQL Server 2016, РЕОРГАНИЗАЦИЯ более сжатие разностных групп строк в columnstore. Он также выполняет оперативной дефрагментации. Во-первых он уменьшает размер хранилища столбцов путем физического удаления удаленных строк при удалении 10% или более строк в группе строк.  Затем он объединяет группы строк вместе для формирования больших групп строк, необходимо более 1,024,576 строк на группы строк.  Все группы строк, измененных повторно сжиматься.  
  
> [!NOTE]
>  Начиная с SQL Server 2016, перестройка индекса columnstore нет необходимости в большинстве случаев после РЕОРГАНИЗАЦИИ физически удаляет удаленные строки и объединяет групп строк. Параметр COMPRESS_ALL_ROW_GROUPS принудительно все OPEN или CLOSED разностных групп строк в columnstore, который ранее может осуществляться только с повторной сборки.   РЕОРГАНИЗАЦИЯ находится в оперативном режиме и происходит в фоновом режиме, поэтому запросы могут выполняться так, как операция выполняется.  
  
```tsql  
-- Uses AdventureWorks  
-- Defragment by physically removing rows that have been logically deleted from the table, and merging rowgroups.  
ALTER INDEX cci_FactInternetSales2 ON FactInternetSales2 REORGANIZE;  
```  
  
### <a name="e-rebuild-a-clustered-columnstore-index-offline"></a>Д. Перестроить кластеризованный индекс в автономном режиме  
 Применяется к: SQL Server 2012, SQL Server 2014  
  
 Начиная с SQL Server 2016 и в [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)], мы рекомендуем использовать вместо инструкции ALTER INDEX REBUILD инструкции ALTER INDEX REORGANIZE.  
  
> [!NOTE]
>  В SQL Server 2012 и 2014 РЕОРГАНИЗАЦИИ используется только для сжатия группы строк CLOSED в columnstore. Для перестроения индекса является единственным способом для выполнения операций Дефрагментация и принудительно все разностные группы строк в columnstore.  
  
 В этом примере показано, как перестроить кластеризованный индекс и принудительно все разностные группы строк в columnstore. В этом первом шаге подготавливается таблица FactInternetSales2 с кластеризованным индексом columnstore и происходит вставка данных из первых четырех столбцов.  
  
```tsql  
-- Uses AdventureWorksDW  
  
CREATE TABLE dbo.FactInternetSales2 (  
    ProductKey [int] NOT NULL,   
    OrderDateKey [int] NOT NULL,   
    DueDateKey [int] NOT NULL,   
    ShipDateKey [int] NOT NULL);  
  
CREATE CLUSTERED COLUMNSTORE INDEX cci_FactInternetSales2  
ON dbo.FactInternetSales2;  
  
INSERT INTO dbo.FactInternetSales2  
SELECT ProductKey, OrderDateKey, DueDateKey, ShipDateKey  
FROM dbo.FactInternetSales;  
  
SELECT * FROM sys.column_store_row_groups;  
```  
  
 Результаты показывают, имеется одна группа строк OPEN, это означает [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] будет ожидать больше строк, добавляемый перед закроет группу строк и перемещает данные в ColumnStore. Эта следующая инструкция перестраивает кластеризованный индекс, который перемещает все строки в columnstore.  
  
```tsql  
ALTER INDEX cci_FactInternetSales2 ON FactInternetSales2 REBUILD;  
SELECT * FROM sys.column_store_row_groups;  
```  
  
 Результаты инструкции SELECT показывают, что группа строк имеет атрибут COMPRESSED, а это означает, что сегменты столбца этой группы строк теперь упакованы и хранятся в columnstore.  
  
### <a name="f-rebuild-a-partition-of-a-clustered-columnstore-index-offline"></a>Е. Перестроение секции кластеризованный индекс в автономном режиме  
 Используйте его для: SQL Server 2012, SQL Server 2014  
  
 Для перестроения секции большого кластеризованного индекса columnstore, используйте инструкцию ALTER INDEX REBUILD с параметром секции. В этом примере перестраивается секции 12. Начиная с SQL Server 2016, мы рекомендуем, заменив REBUILD с параметром REORGANIZE.  
  
```tsql  
ALTER INDEX cci_fact3   
ON fact3  
REBUILD PARTITION = 12;  
```  
  
### <a name="g-change-a-clustered-columstore-index-to-use-archival-compression"></a>Ж. Изменить кластеризованный индекс для использования архивного сжатия  
 Не применяется к: SQL Server 2012  
  
 Вы можете уменьшить размер еще больше в кластеризованном индексе, используя параметр сжатия данных COLUMNSTORE_ARCHIVE. Это целесообразно для более старых данных, которые будут храниться в хранилище дешевле. Мы рекомендуем только с помощью распаковки это данные, которые не имеет доступа к часто, поскольку выполняется медленнее, чем обычные сжатием COLUMNSTORE.  
  
 В следующем примере перестраивается кластеризованный индекс columnstore в целях применения архивного сжатия, затем показано, как удалить архивное сжатие. Конечным результатом становится использование только сжатия columnstore.  
  
```tsql  
--Prepare the example by creating a table with a clustered columnstore index.  
CREATE TABLE SimpleTable (  
    ProductKey [int] NOT NULL,   
    OrderDateKey [int] NOT NULL,   
    DueDateKey [int] NOT NULL,   
    ShipDateKey [int] NOT NULL  
);  
  
CREATE CLUSTERED INDEX cci_SimpleTable ON SimpleTable (ProductKey);  
  
CREATE CLUSTERED COLUMNSTORE INDEX cci_SimpleTable  
ON SimpleTable  
WITH (DROP_EXISTING = ON);  
  
--Compress the table further by using archival compression.  
ALTER INDEX cci_SimpleTable ON SimpleTable  
REBUILD  
WITH (DATA_COMPRESSION = COLUMNSTORE_ARCHIVE);  
  
--Remove the archive compression and only use columnstore compression.  
ALTER INDEX cci_SimpleTable ON SimpleTable  
REBUILD  
WITH (DATA_COMPRESSION = COLUMNSTORE);  
GO  
```  
  
## <a name="examples-rowstore-indexes"></a>Примеры: Индексы Rowstore  
  
### <a name="a-rebuilding-an-index"></a>A. Перестроение индекса  
 В следующем примере показано, как перестроить единственный индекс на таблице `Employee` базы данных [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)].  
  
```tsql  
ALTER INDEX PK_Employee_EmployeeID ON HumanResources.Employee REBUILD;  
```  
  
### <a name="b-rebuilding-all-indexes-on-a-table-and-specifying-options"></a>Б. Перестроение всех индексов по таблице и указание параметров  
 В нижеследующем примере указывается ключевое слово `ALL`. Это приводит к перестроению всех индексов, связанных с таблицей Production.Product базы данных [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)]. Указываются три параметра.  
  
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.  
  
```tsql  
ALTER INDEX ALL ON Production.Product  
REBUILD WITH (FILLFACTOR = 80, SORT_IN_TEMPDB = ON, STATISTICS_NORECOMPUTE = ON);  
```  
  
 В следующем примере добавляется параметр ONLINE, содержащий параметры блокировки с низким приоритетом, и добавляется параметр сжатия строк.  
  
**Применяется к**: SQL Server (начиная с SQL Server 2014) и базы данных SQL Azure.  
  
```tsql  
ALTER INDEX ALL ON Production.Product  
REBUILD WITH   
(  
    FILLFACTOR = 80,   
    SORT_IN_TEMPDB = ON,  
    STATISTICS_NORECOMPUTE = ON,  
    ONLINE = ON ( WAIT_AT_LOW_PRIORITY ( MAX_DURATION = 4 MINUTES, ABORT_AFTER_WAIT = BLOCKERS ) ),   
    DATA_COMPRESSION = ROW  
);  
```  
  
### <a name="c-reorganizing-an-index-with-lob-compaction"></a>В. Реорганизация индекса со сжатием данных LOB  
 В следующем примере показано, как реорганизовать единственный кластеризованный индекс в базе данных [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)]. Поскольку индекс содержит тип данных LOB на конечном уровне, инструкция также подвергает сжатию все страницы, в которых содержатся данные больших объектов. Следует отметить, что указывать параметр WITH (LOB_COMPACTION) не требуется, так как значение по умолчанию — ON.  
  
```tsql  
ALTER INDEX PK_ProductPhoto_ProductPhotoID ON Production.ProductPhoto REORGANIZE WITH (LOB_COMPACTION);  
```  
  
### <a name="d-setting-options-on-an-index"></a>Г. Установка параметров для индекса  
 В следующем примере задается несколько параметров индекса `AK_SalesOrderHeader_SalesOrderNumber` в базе данных [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)].  
  
**Применяется к**: SQL Server (начиная с SQL Server 2008) и базы данных SQL Azure.  
  
```tsql  
ALTER INDEX AK_SalesOrderHeader_SalesOrderNumber ON  
    Sales.SalesOrderHeader  
SET (  
    STATISTICS_NORECOMPUTE = ON,  
    IGNORE_DUP_KEY = ON,  
    ALLOW_PAGE_LOCKS = ON  
    ) ;  
GO
```  
  
### <a name="e-disabling-an-index"></a>Д. Отключение индекса  
 В следующем примере показано отключение некластеризованного индекса на таблице `Employee` базы данных [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)].  
  
```tsql  
ALTER INDEX IX_Employee_ManagerID ON HumanResources.Employee DISABLE;
```  
  
### <a name="f-disabling-constraints"></a>Е. Отключение ограничений  
 В следующем примере отключается ограничение PRIMARY KEY путем отключения индекса PRIMARY KEY в [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)] базы данных. Ограничение FOREIGN KEY в базовой таблице автоматически отключается, и выводится предупредительное сообщение.  
  
```tsql  
ALTER INDEX PK_Department_DepartmentID ON HumanResources.Department DISABLE;  
```  
  
 Результирующий набор возвращает это предупреждающее сообщение.  
  
 ```tsql  
 Warning: Foreign key 'FK_EmployeeDepartmentHistory_Department_DepartmentID'  
 on table 'EmployeeDepartmentHistory' referencing table 'Department'  
 was disabled as a result of disabling the index 'PK_Department_DepartmentID'.
 ```  
  
### <a name="g-enabling-constraints"></a>Ж. Включение ограничений  
 В следующем примере активируются ограничения PRIMARY KEY и FOREIGN KEY, снятые в примере Е.  
  
 Ограничение PRIMARY KEY активируется путем перестройки индекса PRIMARY KEY.  
  
```tsql  
ALTER INDEX PK_Department_DepartmentID ON HumanResources.Department REBUILD;  
```  
  
 Затем активируется ограничение FOREIGN KEY.  
  
```tsql  
ALTER TABLE HumanResources.EmployeeDepartmentHistory  
CHECK CONSTRAINT FK_EmployeeDepartmentHistory_Department_DepartmentID;  
GO  
```  
  
### <a name="h-rebuilding-a-partitioned-index"></a>З. Перестроение секционированного индекса  
 В следующем примере перестраивается единственная секция с номером `5` секционированного индекса `IX_TransactionHistory_TransactionDate` в базе данных [!INCLUDE[ssSampleDBnormal](../../includes/sssampledbnormal-md.md)]. Секция 5 перестраивается в сети, 10 минут времени ожидания для блокировки с низким приоритетом применяется отдельно к каждой полученной блокировке операции перестроения индекса. Если в течение этого времени не удается получить блокировку для завершения перестроения индекса, инструкция по перестроению прерывается.  
  
**Применяется к**: SQL Server (начиная с SQL Server 2014) и базы данных SQL Azure.  
  
```tsql  
-- Verify the partitioned indexes.  
SELECT *  
FROM sys.dm_db_index_physical_stats (DB_ID(),OBJECT_ID(N'Production.TransactionHistory'), NULL , NULL, NULL);  
GO  
--Rebuild only partition 5.  
ALTER INDEX IX_TransactionHistory_TransactionDate  
ON Production.TransactionHistory  
REBUILD Partition = 5   
   WITH (ONLINE = ON (WAIT_AT_LOW_PRIORITY (MAX_DURATION = 10 minutes, ABORT_AFTER_WAIT = SELF)));  
GO  
```  
  
### <a name="i-changing-the-compression-setting-of-an-index"></a>И. Изменение настроек сжатия индекса  
 В следующем примере перестраивается индекс на несекционированной таблице rowstore.  
  
```tsql
ALTER INDEX IX_INDEX1   
ON T1  
REBUILD   
WITH (DATA_COMPRESSION = PAGE);  
GO  
```  
  
 Дополнительные примеры сжатия данных, в разделе [сжатие данных](../../relational-databases/data-compression/data-compression.md).  
 
### <a name="j-online-resumable-index-rebuild"></a>К. Перестроение индекса в сети возобновляемые

**Применяется к**: начиная с 2017 и Azure SQL базы данных SQL Server (компонент находится в общедоступной предварительной версии)    

 Следующие примеры показывают, как использовать перестроение индекса в сети возобновляемые. 

1. Выполнить перестроение индекса в сети в качестве возобновляемые операцию с MAXDOP = 1.

   ```tsql
   ALTER INDEX test_idx on test_table REBUILD WITH (ONLINE=ON, MAXDOP=1, RESUMABLE=ON) ;
   ```

2. Выполнение же команду еще раз (см. выше) после операции индекса было приостановлено, возобновляется автоматически операции перестроения индекса.

3. Выполните перестроение индекса в сети в качестве возобновляемые операции с MAX_DURATION равным 240 минут.

   ```tsql
   ALTER INDEX test_idx on test_table REBUILD WITH (ONLINE=ON, RESUMABLE=ON, MAX_DURATION=240) ; 
   ```
4. Приостановите перестроения выполняется возобновляемые индексами в сети.

   ```tsql
   ALTER INDEX test_idx on test_table PAUSE ;
   ```   
5. Возобновите перестроения индекса в сети для перестроения индекса, выполненного как возобновляемые операцию, указав новое значение для MAXDOP значение 4.

   ```tsql
   ALTER INDEX test_idx on test_table RESUME WITH (MAXDOP=4) ;
   ```
6. Возобновите операции перестроения индекса в сети для сети перестроения индекса, который был выполнен как возобновляемые. MAXDOP, равным 2, установите время выполнения индекса, запущена как resmumable до 240 минут и в случае индекса блокируется на время ожидания блокировки 10 минут и после этого остановите все препятствия. 

   ```tsql
      ALTER INDEX test_idx on test_table  
         RESUME WITH (MAXDOP=2, MAX_DURATION= 240 MINUTES, 
         WAIT_AT_LOW_PRIORITY (MAX_DURATION=10, ABORT_AFTER_WAIT=BLOCKERS)) ;
   ```      
7. Прерывание операции перестроения индекса возобновляемой, которая воспроизводится или приостановлена.

   ```tsql
   ALTER INDEX test_idx on test_table ABORT ;
   ``` 
  
## <a name="see-also"></a>См. также:  
 [CREATE INDEX (Transact-SQL)](../../t-sql/statements/create-index-transact-sql.md)   
 [Создание ПРОСТРАНСТВЕННОГО ИНДЕКСА &#40; Transact-SQL &#41;](../../t-sql/statements/create-spatial-index-transact-sql.md)   
 [СОЗДАТЬ XML-индекс &#40; Transact-SQL &#41;](../../t-sql/statements/create-xml-index-transact-sql.md)   
 [DROP INDEX &#40; Transact-SQL &#41;](../../t-sql/statements/drop-index-transact-sql.md)   
 [Отключение индексов и ограничений](../../relational-databases/indexes/disable-indexes-and-constraints.md)   
 [XML-индексы (SQL Server)](../../relational-databases/xml/xml-indexes-sql-server.md)   
 [Выполнение операции с индексами в сети](../../relational-databases/indexes/perform-index-operations-online.md)   
 [Реорганизация и перестроение индексов](../../relational-databases/indexes/reorganize-and-rebuild-indexes.md)   
 [sys.dm_db_index_physical_stats (Transact-SQL)](../../relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql.md)   
 [EVENTDATA (Transact-SQL)](../../t-sql/functions/eventdata-transact-sql.md)  
  
  



