---
title: Вызов хранимой процедуры | Документация Майкрософт
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.suite: ''
ms.technology: native-client
ms.tgt_pltfrm: ''
ms.topic: reference
helpviewer_keywords:
- calling stored procedures
- ODBC, stored procedures
- stored procedures [ODBC], calling
- SQL Server Native Client ODBC driver, stored procedures
- ODBC CALL escape sequence
- escape sequences [SQL Server]
- CALL statement
ms.assetid: d13737f4-f641-45bf-b56c-523e2ffc080f
caps.latest.revision: 40
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 3ec1897886a968f15eb67210f060399225317b55
ms.sourcegitcommit: c8f7e9f05043ac10af8a742153e81ab81aa6a3c3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/17/2018
ms.locfileid: "39083417"
---
# <a name="calling-a-stored-procedure"></a>Вызов хранимой процедуры
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Драйвер ODBC для собственного клиента поддерживает оба управляющая последовательность ODBC CALL и [!INCLUDE[tsql](../../includes/tsql-md.md)] [EXECUTE](/sql/t-sql/language-elements/execute-transact-sql) инструкции для выполнения хранимых процедур; предпочтительным методом является управляющая последовательность ODBC CALL. Использование синтаксиса ODBC позволяет приложению получать коды возврата хранимых процедур, а драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] оптимизирован в целях использования протокола, первоначально разработанного для отправки вызовов удаленных процедур (RPC) между компьютерами, на которых выполняется [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. Этот протокол RPC повышает производительность, устраняя большую часть обработки параметров и синтаксической проверки инструкций на сервере.  
  
> [!NOTE]  
>  При вызове [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] хранимые процедуры с именованными параметрами ODBC (Дополнительные сведения см. в разделе [привязка параметров по имени (именованные параметры)](http://go.microsoft.com/fwlink/?LinkID=209721)), имена параметров должны начинаться с "\@" символов. Это ограничение, характерное для [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. В драйвере ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] это ограничение контролируется строже, чем в компонентах доступа к данным MDAC.  
  
 Управляющая последовательность ODBC CALL для вызова процедуры такова:  
  
 {[**? =**]**вызов ***procedure_name*[([*параметр*] [**, **[* параметра *]]...)]}  
  
 где *имя_процедуры* указывает имя процедуры и *параметр* указывает параметр процедуры. Именованные параметры поддерживаются только в инструкциях, использующих escape-последовательности ODBC CALL.  
  
 Процедура может иметь параметры или не иметь их. Она также может возвращать значение (на что указывает необязательный маркер параметра «?=» в начале синтаксической конструкции). Если параметр является входным или входным-выходным, то может представлять собой литерал или маркер параметра. Если параметр является выходным, то должен быть маркером параметра, поскольку выходной параметр неизвестен. Маркеры параметров должен быть привязан с [SQLBindParameter](../../relational-databases/native-client-odbc-api/sqlbindparameter.md) до вызова процедуры выполнения инструкции.  
  
 Входные и входные-выходные параметры в вызовах процедуры могут быть пропущены. Если процедура вызывается со скобками, но без параметров, то драйвер передает источнику данных указание, что для первого параметра должно использоваться значение по умолчанию. Пример:  
  
 {**вызвать** * procedure_name ***()**}  
  
 Если процедура не имеет ни одного параметра, ее вызов завершается ошибкой. Если процедура вызывается без скобок, драйвер не передает какие-либо значения параметров. Пример:  
  
 {**вызвать** *procedure_name*}  
  
 В вызовах процедур можно задавать литералы для входных или входных-выходных параметров. Например, процедура InsertOrder имеет пять входных параметров. В следующем вызове процедуры InsertOrder пропущен первый параметр, указан литерал для второго параметра и используется маркер параметра для третьего, четвертого и пятого параметра. (Параметры нумеруются последовательно, начиная с 1.)  
  
```  
{call InsertOrder(, 10, ?, ?, ?)}  
```  
  
 Обратите внимание, что даже если параметр пропущен, запятая, отделяющая его от других параметров, должна присутствовать. Если пропущен входной или входной-выходной параметр, процедура использует значение по умолчанию. Другие способы задать значение по умолчанию для входного или входного-выходного параметра таковы: присвоить значение буфера длины и индикатора, привязанное к параметру процедуры SQL_DEFAULT_PARAM, или использовать ключевое слово DEFAULT.  
  
 Если входной-выходной параметр пропущен или в качестве параметра выступает литерал, то драйвер отбрасывает выходное значение. Аналогичным образом, если пропущен маркер параметра для значения, возвращаемого процедурой, драйвер отбрасывает возвращаемое значение. Наконец, если в приложении задан параметр возвращаемого значения для процедуры, которая не возвращает значение, драйвер задает значение буфера длины и индикатора, привязанное к параметру процедуры SQL_NULL_DATA.  
  
## <a name="delimiters-in-call-statements"></a>Разделители в инструкциях CALL  
 Драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] по умолчанию поддерживает также параметр совместимости для управляющей последовательности ODBC { CALL }. Он принимает инструкции CALL только с одним набором двойных кавычек, ограничивающих все имя хранимой процедуры:  
  
```  
{ CALL "master.dbo.sp_who" }  
```  
  
 По умолчанию драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] принимает также инструкции CALL, которые соответствуют правилам ISO, и заключает каждый идентификатор в двойные кавычки:  
  
```  
{ CALL "master"."dbo"."sp_who" }  
```  
  
 Но при выполнении с настройками по умолчанию драйвер ODBC для собственного клиента [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] не поддерживает использование ни одной из форм представления идентификаторов, заключенных в кавычки, применительно к идентификаторам, которые содержат символы, не указанные как допустимые в стандарте ISO. Например, драйвер не может получить доступ к хранимую процедуру с именем **«My.Proc»** с помощью инструкции CALL с заключенные в кавычки идентификаторы:  
  
```  
{ CALL "MyDB"."MyOwner"."My.Proc" }  
```  
  
 Эта инструкция интерпретируется драйвером следующим образом:  
  
```  
{ CALL MyDB.MyOwner.My.Proc }  
```  
  
 Сервер выдает ошибку, связанный сервер с именем **MyDB** не существует.  
  
 При использовании идентификаторов, заключенных в квадратные скобки, эта инструкция интерпретируется правильно:  
  
```  
{ CALL [MyDB].[MyOwner].[My.Table] }  
```  
  
## <a name="see-also"></a>См. также  
 [Выполнение хранимых процедур](../../relational-databases/native-client-odbc-stored-procedures/running-stored-procedures.md)  
  
  
