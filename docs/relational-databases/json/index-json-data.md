---
title: "Индексирование данных JSON | Документация Майкрософт"
ms.custom:
- SQL2016_New_Updated
ms.date: 06/01/2016
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology:
- dbe-json
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- JSON, indexing JSON data
- indexing JSON data
ms.assetid: ced241e1-ff09-4d6e-9f04-a594a9d2f25e
caps.latest.revision: 9
author: douglaslMS
ms.author: douglasl
manager: jhubbard
ms.translationtype: Human Translation
ms.sourcegitcommit: 439b568fb268cdc6e6a817f36ce38aeaeac11fab
ms.openlocfilehash: 3ed7a51b28d2b17b3239f971d0f4f684bec145cd
ms.contentlocale: ru-ru
ms.lasthandoff: 06/09/2017

---
# <a name="index-json-data"></a>Индексирование данных JSON
[!INCLUDE[tsql-appliesto-ss2016-asdb-xxxx-xxx_md](../../includes/tsql-appliesto-ss2016-asdb-xxxx-xxx-md.md)]

В SQL Server 2016 JSON не является встроенным типом данных и SQL Server не имеет пользовательских индексов JSON. Можно оптимизировать запросы к документам JSON, однако с помощью обычных индексов. 

Индексы баз данных повысить производительность операции фильтрации и сортировки. Без индексов SQL Server пришлось бы сканировать всю таблицу при каждом запросе данных.  
  
## <a name="index-json-properties-by-using-computed-columns"></a>Индексация свойств JSON с помощью вычисляемых столбцов  
При хранении данных JSON в SQL Server, обычно нужно фильтровать или сортировать результаты запроса по одному или нескольким *свойства* документов JSON.  

### <a name="example"></a>Пример 
В этом примере предполагается, что AdventureWorks `SalesOrderHeader` таблица имеет `Info` столбец, содержащий различные сведения в формате JSON о заказах на продажу. Например он содержит сведения о клиента, менеджер по продажам, адресам доставки и выставления счетов и т. д. Вы хотите использовать значения из `Info` столбец для фильтрации заказов на продажу по клиенту.

### <a name="query-to-optimize"></a>Запрос для оптимизации
Ниже приведен пример типа запроса, который вы хотите оптимизировать с помощью индекса.  
  
```sql  
SELECT SalesOrderNumber,
    OrderDate,
    JSON_VALUE(Info, '$.Customer.Name') AS CustomerName
FROM Sales.SalesOrderHeader
WHERE JSON_VALUE(Info, '$.Customer.Name') = N'Aaron Campbell' 
```  

### <a name="example-index"></a>Пример индекса
Если вы хотите ускорить фильтры или `ORDER BY` предложений к свойству в документе JSON, можно использовать те же индексы, которые вы уже используете по другим столбцам. Тем не менее, вы не можете *непосредственно* ссылки на свойства в документах JSON.
    
1.  Во-первых, необходимо создать «виртуальный столбец», возвращающий значения, которые вы хотите использовать для фильтрации.
2.  а затем создать индекс в этом виртуальном столбце.  
  
В следующем примере создается вычисляемый столбец, который может использоваться для индексирования. Затем он создает индекс на новый вычисляемый столбец. В этом примере создается столбец, который предоставляет имя клиента, который хранится в `$.Customer.Name` пути в данные JSON. 
  
```sql  
ALTER TABLE Sales.SalesOrderHeader
ADD vCustomerName AS JSON_VALUE(Info,'$.Customer.Name')

CREATE INDEX idx_soh_json_CustomerName
ON Sales.SalesOrderHeader(vCustomerName)  
```  
### <a name="more-info-about-the-computed-column"></a>Дополнительные сведения о вычисляемых столбцов 
Вычисляемый столбец не сохраняется Он вычисляется только в том случае, если индекс необходимо перестроить. и не занимает дополнительное место в таблице.   
  
Очень важно, что можно создать вычисляемый столбец с одним выражением, планируется использовать в запросах — в этом примере, выражение `JSON_VALUE(Info, '$.Customer.Name')`.  
  
Запросы переписывать не нужно. При использовании выражений с `JSON_VALUE` функции, как показано в приведенном выше примере запроса SQL Server определяет наличие эквивалентного вычисляемого столбца с тем же выражением и применяет индекс, если это возможно.

### <a name="execution-plan-for-this-example"></a>План выполнения для этого примера
Вот план выполнения для запроса в этом примере.  
  
![План выполнения](../../relational-databases/json/media/jsonindexblog1.png "План выполнения")  
  
Вместо полного табличного сканирования SQL Server применяет оператор Index Seek к некластеризованному индексу и выявляет строки, отвечающие указанным условиям. Затем он выполняет поиск ключей в `SalesOrderHeader` таблицы для получения других столбцов, указанных в запросе - в этом примере `SalesOrderNumber` и `OrderDate`.  
 
### <a name="optimize-the-index-further-with-included-columns"></a>Оптимизация дальнейшей индекс с включенными столбцами
При добавлении требуемых столбцов в индексе, можно избежать такого дополнительного поиска в таблице. Эти столбцы можно добавить как стандартные включенные столбцы, как показано в следующем примере, который расширяет `CREATE INDEX` из примера выше.  
  
```sql  
CREATE INDEX idx_soh_json_CustomerName
ON Sales.SalesOrderHeader(vCustomerName)
INCLUDE(SalesOrderNumber,OrderDate)
```  
  
В этом случае SQL Server не имеет для чтения дополнительных данных из `SalesOrderHeader` таблицы, так как все необходимое уже включено в некластеризованный индекс JSON. Это хороший способ объединения данных JSON и столбцов в запросах и создания оптимальных индексов для рабочей нагрузки.  
  
## <a name="json-indexes-are-collation-aware-indexes"></a>Индексы JSON — это индексы с учетом сортировки  
Важной особенностью индексов по данным JSON является то, что индексы учитывают параметры сортировки. Результат `JSON_VALUE` функция, которая используется при создании вычисляемого столбца является текстовое значение, которое наследует параметры сортировки из входного выражения. Таким образом значения в индексе упорядочиваются согласно правилам сортировки, определенные в исходных столбцах.  
  
Чтобы это продемонстрировать, в следующем примере создается простая таблица коллекций с первичным ключом и данными в формате JSON.  
  
```sql  
CREATE TABLE JsonCollection
 (
  id INT IDENTITY CONSTRAINT PK_JSON_ID PRIMARY KEY,
  json NVARCHAR(MAX) COLLATE SERBIAN_CYRILLIC_100_CI_AI
  CONSTRAINT [Content should be formatted as JSON]
  CHECK(ISJSON(json)>0)
 ) 
```  
  
Указанная выше команда задает для столбца JSON сортировку по сербской кириллице. В следующем примере таблица заполняется и создается индекс по свойству name.  
  
```sql  
INSERT INTO JsonCollection
VALUES
(N'{"name":"Иво","surname":"Андрић"}'),
(N'{"name":"Андрија","surname":"Герић"}'),
(N'{"name":"Владе","surname":"Дивац"}'),
(N'{"name":"Новак","surname":"Ђоковић"}'),
(N'{"name":"Предраг","surname":"Стојаковић"}'),
(N'{"name":"Михајло","surname":"Пупин"}'),
(N'{"name":"Борислав","surname":"Станковић"}'),
(N'{"name":"Владимир","surname":"Грбић"}'),
(N'{"name":"Жарко","surname":"Паспаљ"}'),
(N'{"name":"Дејан","surname":"Бодирога"}'),
(N'{"name":"Ђорђе","surname":"Вајферт"}'),
(N'{"name":"Горан","surname":"Бреговић"}'),
(N'{"name":"Милутин","surname":"Миланковић"}'),
(N'{"name":"Никола","surname":"Тесла"}')
GO
  
ALTER TABLE JsonCollection
ADD vName AS JSON_VALUE(json,'$.name')

CREATE INDEX idx_name
ON JsonCollection(vName)
```  
  
Указанные выше команды создают стандартный индекс по вычисляемому столбцу `vName`, из JSON, представляющий значение `$.name` свойства. На странице кода сербской кириллицы буквы сортируются в следующем порядке: "А", "Б", "В", "Г", "Д", "Ђ", "Е" и т. д. Порядок элементов в индексе не соответствует правилам Сербской кириллицы так как результат `JSON_VALUE` функция наследует параметры сортировки из исходного столбца. Следующий пример запрашивает эту коллекцию и сортирует результаты по имени.  
  
```sql  
SELECT JSON_VALUE(json,'$.name'),*
FROM JsonCollection
ORDER BY JSON_VALUE(json,'$.name')
```  
  
 Если посмотреть на фактический план выполнения, можно увидеть, что в нем используются отсортированные значения из некластеризованного индекса.  
  
 ![План выполнения](../../relational-databases/json/media/jsonindexblog2.png "План выполнения")  
  
 Несмотря на то, что в запросе `ORDER BY` предложение, план выполнения не используется оператор Sort. Индекс JSON уже упорядочен по правилам сербской кириллицы. В связи с этим SQL Server может использовать некластеризованный индекс, в котором результаты уже отсортированы.  
  
 Однако если изменить параметры сортировки `ORDER BY` выражения — например, если мы поместили `COLLATE French_100_CI_AS_SC` после `JSON_VALUE` функции — мы получаем другой план выполнения запроса.  
  
 ![План выполнения](../../relational-databases/json/media/jsonindexblog3.png "План выполнения")  
  
 Поскольку порядок значений в индексе не соответствует правилам сортировки для французского языка, SQL Server не может использовать этот индекс для упорядочивания результатов. В связи с этим он добавляет оператор Sort, который сортирует результаты по правилам сортировки для французского языка.  
 
## <a name="learn-more-about-the-built-in-json-support-in-sql-server"></a>Дополнительные сведения о встроенной поддержке JSON в SQL Server  
Большое количество определенных решений варианты использования и рекомендации, см. в разделе [записи в блогах о встроенной поддержке JSON](http://blogs.msdn.com/b/sqlserverstorageengine/archive/tags/json/) в SQL Server и базы данных SQL Azure с руководителем программ Microsoft (Jovan Popovic).

