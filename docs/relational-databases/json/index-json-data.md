---
title: "Индексирование данных JSON | Документация Майкрософт"
ms.custom:
- SQL2016_New_Updated
ms.date: 06/01/2016
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology:
- dbe-json
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- JSON, indexing JSON data
- indexing JSON data
ms.assetid: ced241e1-ff09-4d6e-9f04-a594a9d2f25e
caps.latest.revision: 9
author: douglaslMS
ms.author: douglasl
manager: jhubbard
ms.translationtype: Human Translation
ms.sourcegitcommit: 2edcce51c6822a89151c3c3c76fbaacb5edd54f4
ms.openlocfilehash: cf3c58c7d71a98bfaa1f27611762bf7fb3fe8725
ms.contentlocale: ru-ru
ms.lasthandoff: 04/11/2017

---
# <a name="index-json-data"></a>Индексирование данных JSON
[!INCLUDE[tsql-appliesto-ss2016-asdb-xxxx-xxx_md](../../includes/tsql-appliesto-ss2016-asdb-xxxx-xxx-md.md)]

  Индексы баз данных делают операции фильтрации и сортировки более эффективными. Без индексов SQL Server пришлось бы сканировать всю таблицу при каждом запросе данных.  
  
 JSON не является встроенным типом данных в SQL Server 2016, а SQL Server 2016 нет имеет пользовательских индексов JSON. Тем не менее запросы к документам JSON можно оптимизировать с помощью обычных индексов.  
  
## <a name="index-json-properties-by-using-computed-columns"></a>Индексация свойств JSON с помощью вычисляемых столбцов  
 При хранении данных JSON в SQL Server результаты запросов обычно нужно фильтровать или сортировать по свойствам документов JSON.  
  
 В этом примере таблицы AdventureWorks SalesOrderHeader содержит столбец "Info", содержащий различные сведения о заказах на продажу, например, сведения о клиента, менеджере по продажам, адресам доставки и выставления счетов и т. д. Значения из столбца "Info" можно использовать для фильтрации заказов на продажу по клиенту. С помощью индекса можно оптимизировать следующий запрос:  
  
```tsql  
SELECT SalesOrderNumber,OrderDate,JSON_VALUE(Info,'$.Customer.Name') AS CustomerName
FROM Sales.SalesOrderHeader
WHERE JSON_VALUE(Info,'$.Customer.Name')=N'Aaron Campbell' 
```  
  
 Чтобы ускорить применение фильтров или предложений ORDER BY к свойству в документе JSON, можно применить те же индексы, которые используются в других столбцах. При этом напрямую на свойства в документах JSON ссылаться нельзя. Сначала необходимо создать "виртуальный столбец", возвращающий значения, которые нужно использовать для фильтрации, а затем создать индекс в этом виртуальном столбце.  
  
 В следующем примере создается вычисляемый столбец, который можно использовать для индексирования и последующего создания индекса в этом столбце. В этом примере создается столбец, сообщающий имя клиента, которое хранится в документах JSON в пути $.Customer.Name.  
  
```tsql  
ALTER TABLE Sales.SalesOrderHeader
ADD vCustomerName AS JSON_VALUE(Info,'$.Customer.Name')

CREATE INDEX idx_soh_json_CustomerName
ON Sales.SalesOrderHeader(vCustomerName)  
```  
  
 Вычисляемый столбец не сохраняется и не занимает дополнительное место в таблице. Он вычисляется только в том случае, если индекс необходимо перестроить.  
  
 Вычисляемый столбец необходимо создавать с тем же выражением, которое вы планируете использовать в запросах — в этом примере это выражение `JSON_VALUE(Info, '$.Customer.Name')`.  
  
 Запросы переписывать не нужно. Если выражения используются с функцией JSON_VALUE, SQL Server определяет наличие эквивалентного вычисляемого столбца с тем же выражением и применяет индекс, если это возможно. Вот план выполнения для запроса в этом примере:  
  
 ![План выполнения](../../relational-databases/json/media/jsonindexblog1.png "План выполнения")  
  
 Вместо полного табличного сканирования SQL Server применяет оператор Index Seek к некластеризованному индексу и выявляет строки, отвечающие указанным условиям. Затем он выполняет поиск ключей по таблице SalesOrderHeader, чтобы получить другие указанные в запросе столбцы — в этом примере это столбцы SalesOrderNumber и OrderDate.  
  
 При добавлении требуемых столбцов в индекс JSON такого дополнительного поиска по таблице можно избежать. Эти столбцы можно добавить как стандартные включенные столбцы, как показано в следующем примере.  
  
```tsql  
CREATE INDEX idx_soh_json_CustomerName
ON Sales.SalesOrderHeader(vCustomerName)
INCLUDE(SalesOrderNumber,OrderDate)
```  
  
 В данном случае SQL Server не считывает дополнительные данные из таблицы SalesOrderHeader, поскольку все необходимое уже включено в некластеризованный индекс JSON. Это хороший способ объединения данных JSON и столбцов в запросах и создания оптимальных индексов для вашей рабочей нагрузки.  
  
## <a name="json-indexes-are-collation-aware-indexes"></a>Индексы JSON — это индексы с учетом сортировки  
 Важной особенностью индексов JSON является то, что они учитывают параметры сортировки. Результатом выполнения функции JSON_VALUE является текстовое значение, которое наследует параметры сортировки из входного выражения. Таким образом, значения в индексе упорядочиваются согласно правилам сортировки, определенным в исходных столбцах.  
  
 Чтобы это продемонстрировать, в следующем примере создается простая таблица коллекций с первичным ключом и данными в формате JSON.  
  
```tsql  
CREATE TABLE JsonCollection
 (
  id INT IDENTITY CONSTRAINT PK_JSON_ID PRIMARY KEY,
  json NVARCHAR(MAX) COLLATE SERBIAN_CYRILLIC_100_CI_AI
  CONSTRAINT [Content should be formatted as JSON]
  CHECK(ISJSON(json)>0)
 ) 
```  
  
 Указанная выше команда задает для столбца JSON сортировку по сербской кириллице. В следующем примере таблица заполняется и создается индекс по свойству name.  
  
```tsql  
INSERT INTO JsonCollection
VALUES
(N'{"name":"Иво","surname":"Андрић"}'),
(N'{"name":"Андрија","surname":"Герић"}'),
(N'{"name":"Владе","surname":"Дивац"}'),
(N'{"name":"Новак","surname":"Ђоковић"}'),
(N'{"name":"Предраг","surname":"Стојаковић"}'),
(N'{"name":"Михајло","surname":"Пупин"}'),
(N'{"name":"Борислав","surname":"Станковић"}'),
(N'{"name":"Владимир","surname":"Грбић"}'),
(N'{"name":"Жарко","surname":"Паспаљ"}'),
(N'{"name":"Дејан","surname":"Бодирога"}'),
(N'{"name":"Ђорђе","surname":"Вајферт"}'),
(N'{"name":"Горан","surname":"Бреговић"}'),
(N'{"name":"Милутин","surname":"Миланковић"}'),
(N'{"name":"Никола","surname":"Тесла"}')
GO  
ALTER TABLE JsonCollection
ADD vName AS JSON_VALUE(json,'$.name')

CREATE INDEX idx_name
ON JsonCollection(vName)
```  
  
 Указанные выше команды создают стандартный индекс по значению vName вычисляемого столбца, которое соответствует свойству $.name JSON. На странице кода сербской кириллицы буквы сортируются в следующем порядке: "А", "Б", "В", "Г", "Д", "Ђ", "Е" и т. д. Порядок элементов в индексе соответствует правилам сербской кириллицы, поскольку результат функции JSON_VALUE наследует параметры сортировки из исходного столбца. Следующий пример запрашивает эту коллекцию и сортирует результаты по имени.  
  
```tsql  
SELECT JSON_VALUE(json,'$.name'),*
FROM JsonCollection
ORDER BY JSON_VALUE(json,'$.name')
```  
  
 Если посмотреть на фактический план выполнения, можно увидеть, что в нем используются отсортированные значения из некластеризованного индекса.  
  
 ![План выполнения](../../relational-databases/json/media/jsonindexblog2.png "План выполнения")  
  
 Несмотря на то что запрос содержит предложение ORDER BY, в плане выполнения не используется оператор Sort. Индекс JSON уже упорядочен по правилам сербской кириллицы. В связи с этим SQL Server может использовать некластеризованный индекс, в котором результаты уже отсортированы.  
  
 Однако если порядок сортировки по выражению изменить, например добавить `COLLATE French_100_CI_AS_SC` после функции JSON_VALUE, план выполнения запроса станет совершенно иным.  
  
 ![План выполнения](../../relational-databases/json/media/jsonindexblog3.png "План выполнения")  
  
 Поскольку порядок значений в индексе не соответствует правилам сортировки для французского языка, SQL Server не может использовать этот индекс для упорядочивания результатов. В связи с этим он добавляет оператор Sort, который сортирует результаты по правилам сортировки для французского языка.  
  
  

