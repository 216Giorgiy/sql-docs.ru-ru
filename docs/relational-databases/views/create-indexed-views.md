---
title: "Создание индексированных представлений | Документация Майкрософт"
ms.custom: 
ms.date: 01/22/2018
ms.prod: sql-non-specified
ms.prod_service: database-engine, sql-database, sql-data-warehouse, pdw
ms.service: 
ms.component: views
ms.reviewer: 
ms.suite: sql
ms.technology:
- dbe-views
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- indexed views [SQL Server], creating
- clustered indexes, views
- CREATE INDEX statement
- large_value_types_out_of_row option
- indexed views [SQL Server]
- views [SQL Server], indexed views
ms.assetid: f86dd29f-52dd-44a9-91ac-1eb305c1ca8d
caps.latest.revision: 
author: BYHAM
ms.author: rickbyh
manager: jhubbard
ms.workload: Active
ms.openlocfilehash: 16d6097ac129874ac5fb7f27118e499d86606ba7
ms.sourcegitcommit: d7dcbcebbf416298f838a39dd5de6a46ca9f77aa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2018
---
# <a name="create-indexed-views"></a>Создание индексированных представлений
[!INCLUDE[tsql-appliesto-ss2008-asdb-xxxx-xxx-md](../../includes/tsql-appliesto-ss2008-asdb-xxxx-xxx-md.md)] Этот раздел описывает, как создавать в представлении индексы. Первым индексом, создаваемым для представления, должен быть уникальный кластеризованный индекс. После создания уникального кластеризованного индекса могут быть созданы некластеризованные индексы. Создание уникального кластеризованного индекса для представления повышает производительность запросов, т. к. представление хранится в базе данных так же, как и таблица с кластеризованным индексом. Оптимизатор запросов может использовать индексированные представления для ускорения выполнения запросов. Чтобы оптимизатор рассматривал представление для подстановки, это представление не обязательно должно быть указано в запросе.  
  
##  <a name="BeforeYouBegin"></a> Перед началом  
 Чтобы создать индексированное представление, нужно выполнить следующие шаги. Точность при их выполнении критически важна для успешной реализации индексированного представления.  
  
1.  Убедитесь в правильности параметров SET для всех существующих таблиц, на которые ссылается представление.   
2.  Прежде чем создавать новые таблицы и представление, проверьте параметры SET для сеанса.  
3.  Проверьте, что определение представления детерминировано.  
4.  Создайте представление с помощью параметра `WITH SCHEMABINDING`.  
5.  Создайте уникальный кластеризованный индекс для представления.  

> [!IMPORTANT]
> При выполнении DML<sup>1</sup> для таблицы, на которую ссылается большое количество индексированных представлений либо меньшее количество очень сложных индексированных представлений, эти упоминаемые индексированные представления также потребуется обновить. В результате может значительно снизиться производительность запросов DML, а в некоторых случаях может быть невозможно даже создать план запроса.
> В таких ситуациях протестируйте запросы DML перед использованием в рабочей среде, проанализируйте план запроса и настройте или упростите инструкцию DML.
>
> <sup>1</sup> Например, операции UPDATE, DELETE или INSERT.
  
###  <a name="Restrictions"></a> Обязательные параметры SET для индексированных представлений  
 Если при выполнении запроса активны разные параметры SET, выполнение одного и того же выражения может дать разные результаты в [!INCLUDE[ssDE](../../includes/ssde-md.md)] . Например, если параметр SET `CONCAT_NULL_YIELDS_NULL` равен ON, выражение **'**abc**'** + NULL возвращает значение NULL. Но если параметр `CONCAT_NULL_YIEDS_NULL` равен OFF, то же самое выражение дает результат **'**abc**'**.  
  
 Для правильной поддержки представлений и получения согласованных результатов некоторые параметры SET индексированных представлений должны иметь определенные значения. В приведенных ниже случаях параметрам SET из следующей таблицы нужно присвоить значения, указанные в столбце **Обязательное значение** :  
  
-   Будет создано представление с соответствующими индексами в нем.  
  
-   Базовые таблицы, на которые ссылается представление в момент создания таблицы.  
  
-   С любой из таблиц, используемых в индексированном представлении, выполняется операция вставки, обновления или удаления. Это требование охватывает такие операции, как массовое копирование, репликация и распределенные запросы.  
  
-   Индексированное представление используется оптимизатором запросов для создания плана запроса.  
  
    |Задание параметров|Обязательное значение|Значение сервера по умолчанию|Default<br /><br /> Значение OLE DB и ODBC|Default<br /><br /> Значение DB-Library|  
    |-----------------|--------------------|--------------------------|---------------------------------------|-----------------------------------|  
    |ANSI_NULLS|ON|ON|ON|OFF|  
    |ANSI_PADDING|ON|ON|ON|OFF|  
    |ANSI_WARNINGS<sup>1</sup>|ON|ON|ON|OFF|  
    |ARITHABORT|ON|ON|OFF|OFF|  
    |CONCAT_NULL_YIELDS_NULL|ON|ON|ON|OFF|  
    |NUMERIC_ROUNDABORT|OFF|OFF|OFF|OFF|  
    |QUOTED_IDENTIFIER|ON|ON|ON|OFF|  
  
     <sup>1</sup> Если параметру `ANSI_WARNINGS` присвоить значение ON, то для параметра `ARITHABORT` будет неявно задано значение ON.  
  
 Если используется соединение с сервером через интерфейсы OLE DB или ODBC, достаточно изменить параметр `ARITHABORT`. Все значения DB-Library должны быть правильно установлены на уровне сервера с помощью хранимой процедуры **sp_configure** или из приложения с помощью команды SET.  
  
> [!IMPORTANT]  
> Настоятельно рекомендуется присвоить пользовательскому параметру `ARITHABORT` значение ON на всем сервере, как только в какой-либо базе данных сервера будет создано первое индексированное представление или индекс на базе вычисляемого столбца.  
  
### <a name="deterministic-views"></a>Детерминированные представления  
 Определение индексированного представления должно быть детерминированным. Представление детерминировано, если детерминированы все выражения в списке выбора, а также предложения `WHERE` и `GROUP BY`. Детерминированные выражения возвращают одни и те же результаты при каждом вычислении с одним и тем же набором входных значений. Только детерминированные функции могут использоваться в детерминированных выражениях. Например, функция `DATEADD` детерминирована, так как всегда возвращает один и тот же результат для любого заданного набора значений аргументов трех ее параметров. Функция `GETDATE` не детерминирована, так как всегда вызывается с одним и тем же аргументом, но каждый раз возвращает разные значения.  
  
 Чтобы определить, является ли столбец представления детерминированным, используйте свойство **IsDeterministic** функции [COLUMNPROPERTY](../../t-sql/functions/columnproperty-transact-sql.md) . Чтобы определить, является ли точным детерминированный столбец в представлении с привязкой к схеме, используйте свойство **IsPrecise** функции COLUMNPROPERTY. Функция COLUMNPROPERTY возвращает значение 1 (если TRUE), 0 (если FALSE) и NULL в случае недопустимого входного значения. Это означает, что столбец не является детерминированным или точным.  
  
 Даже если выражение детерминировано, если оно содержит выражения с плавающей запятой, результат может зависеть от архитектуры процессора или версии микропрограммы. Для сохранения целостности данных такие выражения могут быть только неключевыми столбцами индексированных представлений. Детерминированные выражения, не содержащие выражений с плавающей запятой, называются точными выражениями. Только точные детерминированные выражения могут содержаться в ключевых столбцах и предложениях WHERE или GROUP BY индексированных представлений.  

### <a name="additional-requirements"></a>Дополнительные требования  
 Кроме требований, касающихся параметров SET и детерминированных функций, должны выполняться следующие требования.  
  
-   Пользователь, выполняющий инструкцию `CREATE INDEX`, должен быть владельцем представления.  
  
-   При создании индекса параметр `IGNORE_DUP_KEY` должен быть установлен в OFF (значение по умолчанию).  
  
-   Имя таблицы в определении представления должно быть двухкомпонентным: *схема***.***имя_таблицы*.  
  
-   Определяемые пользователем функции, на которые ссылается представление, должны быть созданы с параметром `WITH SCHEMABINDING`.  
  
-   Все определяемые пользователем функции, на которые ссылается представление, должны иметь двухкомпонентные имена: *схема***.***функция*.  
  
-   Свойство доступа к данным пользовательской функции должно быть установлено в значение `NO SQL`, а свойство внешнего доступа — в `NO`.  
  
-   Функции среды CLR могут быть указаны в списке выбора представления, но не могут быть частью определения ключа кластеризованного индекса. Функции CLR нельзя указывать в представлении в предложении WHERE и предложении ON операции JOIN.  
  
-   Функции и методы CLR определяемого пользователем типа данных, используемые в определении представления, должны иметь свойства, установленные так, как показано в следующей таблице.  
  
    |Свойство|Примечание|  
    |--------------|----------|  
    |DETERMINISTIC = TRUE|Должно быть объявлено явно в качестве атрибута метода Microsoft .NET Framework.|  
    |PRECISE = TRUE|Должно быть объявлено явно в качестве атрибута метода .NET Framework.|  
    |DATA ACCESS = NO SQL|Определяется установкой атрибута DataAccess в DataAccessKind.None и атрибута SystemDataAccess в SystemDataAccessKind.None.|  
    |EXTERNAL ACCESS = NO|Для процедур CLR значением свойства по умолчанию является NO.|  
  
-   Представления должны быть созданы с параметром `WITH SCHEMABINDING`.  
  
-   В представлении допустимы ссылки только на базовые таблицы той же самой базы данных. Ссылки на другие представления недопустимы.  
  
-   Инструкция SELECT в определении представления не должна содержать следующие элементы языка Transact-SQL:  
  
    ||||  
    |-|-|-|  
    |`COUNT`|Функции ROWSET (`OPENDATASOURCE`, `OPENQUERY`, `OPENROWSET` И `OPENXML`)|Объединения `OUTER` (`LEFT`, `RIGHT` или `FULL`)|  
    |Производная таблица (определяемая путем указания инструкции `SELECT` в предложении `FROM`)|Самосоединения|Указание столбцов с использованием `SELECT *` или `SELECT <table_name>.*`|  
    |`DISTINCT`|`STDEV`, `STDEVP`, `VAR`, `VARP` или `AVG`|Обобщенное табличное выражение (CTE)|  
    |Столбцы **float**<sup>1</sup>, **text**, **ntext**, **image**, **XML** или **filestream**|Вложенный запрос|Предложение `OVER`, включающее статистические функции или агрегатные оконные функции|  
    |Полнотекстовые предикаты (`CONTAINS`, `FREETEXT`)|Функция `SUM`, ссылающаяся на выражение, допускающее значение NULL|`ORDER BY`|  
    |Определяемая пользователем агрегатная функция CLR|`TOP`|Операторы `CUBE`, `ROLLUP` или `GROUPING SETS`|  
    |`MIN`, `MAX`|Операторы `UNION`, `EXCEPT` или `INTERSECT`|`TABLESAMPLE`|  
    |Табличные переменные|`OUTER APPLY` или `CROSS APPLY`|`PIVOT`, `UNPIVOT`|  
    |Наборы разреженных столбцов|Встроенные функции (TVF) или функции с табличным значением с несколькими инструкциями (MSTVF)|`OFFSET`|  
    |`CHECKSUM_AGG`|||  
  
     <sup>1</sup> Индексированное представление может содержать столбцы типа **float**, но они не могут включаться в ключ кластеризованного индекса.  
  
-   Если присутствует предложение `GROUP BY`, определение VIEW должно содержать `COUNT_BIG(*)` и не должно содержать `HAVING`. Эти ограничения для предложения `GROUP BY` относятся только к определению индексированного представления. Запрос может использовать индексированное представление в своем плане выполнения, даже если он не соответствует этим ограничениям для предложения `GROUP BY`.  
  
-   Если определение представления содержит предложение `GROUP BY`, ключ уникального кластеризованного индекса может включать только столбцы, указанные в предложении `GROUP BY`.  
  
> [!IMPORTANT]  
> Добавление индексированных представлений в темпоральные запросы (запросы, использующие предложение `FOR SYSTEM_TIME`) не поддерживается.  

###  <a name="Recommendations"></a> Рекомендации  
 При ссылке на строковые литералы **datetime** и **smalldatetime** из индексированных представлений рекомендуется явно преобразовывать литерал к нужному типу даты при помощи детерминированного стиля формата даты. Список детерминированных стилей форматирования даты см. в разделе [Функции CAST и CONVERT (Transact-SQL)](../../t-sql/functions/cast-and-convert-transact-sql.md). Дополнительные сведения о детерминированных и недетерминированных выражениях см. в разделе [Замечания](#nondeterministic).

При выполнении DML (например, UPDATE, DELETE или INSERT) для таблицы, на которую ссылается большое количество индексированных представлений либо меньшее количество очень сложных индексированных представлений, эти индексированные представления также потребуется обновить. В результате может значительно снизиться производительность запросов DML, а в некоторых случаях может быть невозможно даже создать план запроса. В таких ситуациях протестируйте запросы DML перед использованием в рабочей среде, проанализируйте план запроса и настройте или упростите инструкцию DML.
  
###  <a name="Considerations"></a> Замечания  
 Значение параметра **large_value_types_out_of_row** столбца в индексированном представлении наследуется от значения соответствующего столбца базовой таблицы. Это значение задается с помощью хранимой процедуры [sp_tableoption](../../relational-databases/system-stored-procedures/sp-tableoption-transact-sql.md). Для столбцов, созданных из выражений, установкой по умолчанию является 0. Это означает, что типы больших значений хранятся в строке.  
  
 Индексированные представления могут создаваться на секционированной таблице и сами могут быть секционированными.  
  
 Чтобы компонент [!INCLUDE[ssDE](../../includes/ssde-md.md)] не использовал индексированные представления, включите в запрос указание `OPTION (EXPAND VIEWS)`. Кроме того, если любой из вышеуказанных параметров установлен неправильно, оптимизатор не сможет использовать индексы представлений. Дополнительные сведения об указании `OPTION (EXPAND VIEWS)` см. в разделе [SELECT (Transact-SQL)](../../t-sql/queries/select-transact-sql.md).  
  
 При удалении представления удаляются также и все его индексы. При удалении кластеризованного индекса удаляются все некластеризованные индексы и автоматически созданные для представления статистики. Статистики, созданные пользователем, сохраняются. Некластеризованные индексы могут удаляться по отдельности. При удалении кластеризованного индекса представления удаляется сохраненный результирующий набор, и оптимизатор снова начинает работать с ним, как с обычным представлением.  
  
 Индексы таблиц и представлений могут быть отключены. При отключении кластеризованного индекса таблицы индексы представлений, связанных с ней, также отключаются.  
 
<a name="nondeterministic"></a> Выражения, включающие неявные преобразования символьных строк в типы **datetime** или **smalldatetime**, считаются недетерминированными. Это связано с тем, что результаты зависят от значений параметров LANGUAGE и DATEFORMAT, определенных для сеанса сервера. Например, результат выражения `CONVERT (datetime, '30 listopad 1996', 113)` зависит от значения параметра LANGUAGE, поскольку строка`listopad`в различных языках обозначает разные месяцы. Аналогичным образом, вычисляя выражение `DATEADD(mm,3,'2000-12-01')`, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] интерпретирует строку `'2000-12-01'` в соответствии со значением параметра DATEFORMAT. Неявное преобразование символьных данных между различными параметрами сортировки не в Юникоде также считается недетерминированным.  
  
###  <a name="Security"></a> безопасность  
  
####  <a name="Permissions"></a> Permissions  
 Для выполнения этой инструкции требуется разрешение CREATE VIEW в отношении базы данных и разрешение ALTER в отношении схемы, в которой создается представление.  
  
##  <a name="TsqlProcedure"></a> Использование Transact-SQL  
  
#### <a name="to-create-an-indexed-view"></a>Создание индексируемого представления  
  
1.  В **обозревателе объектов**подключитесь к экземпляру компонента [!INCLUDE[ssDE](../../includes/ssde-md.md)].  
  
2.  На стандартной панели выберите пункт **Создать запрос**.  
  
3.  Скопируйте следующий пример в окно запроса и нажмите кнопку **Выполнить**. В следующем примере создается представление и индекс для этого представления. Включено два запроса, использующих созданное индексированное представление.  
  
    ```sql  
    USE AdventureWorks2012;  
    GO  
    --Set the options to support indexed views.  
    SET NUMERIC_ROUNDABORT OFF;  
    SET ANSI_PADDING, ANSI_WARNINGS, CONCAT_NULL_YIELDS_NULL, ARITHABORT,  
        QUOTED_IDENTIFIER, ANSI_NULLS ON;  
    GO  
    --Create view with schemabinding.  
    IF OBJECT_ID ('Sales.vOrders', 'view') IS NOT NULL  
    DROP VIEW Sales.vOrders ;  
    GO  
    CREATE VIEW Sales.vOrders  
    WITH SCHEMABINDING  
    AS  
        SELECT SUM(UnitPrice*OrderQty*(1.00-UnitPriceDiscount)) AS Revenue,  
            OrderDate, ProductID, COUNT_BIG(*) AS COUNT  
        FROM Sales.SalesOrderDetail AS od, Sales.SalesOrderHeader AS o  
        WHERE od.SalesOrderID = o.SalesOrderID  
        GROUP BY OrderDate, ProductID;  
    GO  
    --Create an index on the view.  
    CREATE UNIQUE CLUSTERED INDEX IDX_V1   
        ON Sales.vOrders (OrderDate, ProductID);  
    GO  
    --This query can use the indexed view even though the view is   
    --not specified in the FROM clause.  
    SELECT SUM(UnitPrice*OrderQty*(1.00-UnitPriceDiscount)) AS Rev,   
        OrderDate, ProductID  
    FROM Sales.SalesOrderDetail AS od  
        JOIN Sales.SalesOrderHeader AS o ON od.SalesOrderID=o.SalesOrderID  
            AND ProductID BETWEEN 700 and 800  
            AND OrderDate >= CONVERT(datetime,'05/01/2002',101)  
    GROUP BY OrderDate, ProductID  
    ORDER BY Rev DESC;  
    GO  
    --This query can use the above indexed view.  
    SELECT  OrderDate, SUM(UnitPrice*OrderQty*(1.00-UnitPriceDiscount)) AS Rev  
    FROM Sales.SalesOrderDetail AS od  
        JOIN Sales.SalesOrderHeader AS o ON od.SalesOrderID=o.SalesOrderID  
            AND DATEPART(mm,OrderDate)= 3  
            AND DATEPART(yy,OrderDate) = 2002  
    GROUP BY OrderDate  
    ORDER BY OrderDate ASC;  
    GO  
    ```  
  
 Дополнительные сведения см. в статье [CREATE VIEW (Transact-SQL)](../../t-sql/statements/create-view-transact-sql.md).  
  
## <a name="see-also"></a>См. также:  
 [CREATE INDEX (Transact-SQL)](../../t-sql/statements/create-index-transact-sql.md)   
 [SET ANSI_NULLS (Transact-SQL)](../../t-sql/statements/set-ansi-nulls-transact-sql.md)   
 [SET ANSI_PADDING (Transact-SQL)](../../t-sql/statements/set-ansi-padding-transact-sql.md)   
 [SET ANSI_WARNINGS (Transact-SQL)](../../t-sql/statements/set-ansi-warnings-transact-sql.md)   
 [SET ARITHABORT (Transact-SQL)](../../t-sql/statements/set-arithabort-transact-sql.md)   
 [SET CONCAT_NULL_YIELDS_NULL (Transact-SQL)](../../t-sql/statements/set-concat-null-yields-null-transact-sql.md)   
 [SET NUMERIC_ROUNDABORT (Transact-SQL)](../../t-sql/statements/set-numeric-roundabort-transact-sql.md)   
 [SET QUOTED_IDENTIFIER (Transact-SQL)](../../t-sql/statements/set-quoted-identifier-transact-sql.md)  
  
  
