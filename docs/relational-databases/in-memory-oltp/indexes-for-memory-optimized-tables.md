---
title: "Индексы для оптимизированных для памяти таблиц | Документация Майкрософт"
ms.custom:
- MSDN content
- MSDN - SQL DB
ms.date: 06/12/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.service: sql-database
ms.suite: 
ms.technology:
- database-engine-imoltp
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: eecc5821-152b-4ed5-888f-7c0e6beffed9
caps.latest.revision: 14
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.translationtype: Human Translation
ms.sourcegitcommit: 0eb007a5207ceb0b023952d5d9ef6d95986092ac
ms.openlocfilehash: b468f44444a9c6cc031ea892f44849db401e0ab7
ms.contentlocale: ru-ru
ms.lasthandoff: 06/13/2017

---
# <a name="indexes-for-memory-optimized-tables"></a>Индексы для оптимизированных для памяти таблиц
[!INCLUDE[tsql-appliesto-ss2014-asdb-xxxx-xxx_md](../../includes/tsql-appliesto-ss2014-asdb-xxxx-xxx-md.md)]

  
В этой статье описываются типы индексов, доступных для оптимизированных для памяти таблиц. В этой статье  
  
- Представлены небольшие примеры кода для демонстрации синтаксиса Transact-SQL.  
- Описано, чем оптимизированные для памяти индексы отличаются от традиционных дисковых индексов.  
- Объяснены наилучшие обстоятельства для использования каждого типа индекса, оптимизированного для памяти.  
  
  
*Хэш* -индексы рассматриваются подробнее в [связанной статье](../../relational-databases/in-memory-oltp/hash-indexes-for-memory-optimized-tables.md).  
  
  
Индексы*columnstore* рассматриваются в [другой статье](~/relational-databases/indexes/columnstore-indexes-overview.md).  
  
  
## <a name="a-syntax-for-memory-optimized-indexes"></a>A. Синтаксис индексов, оптимизированных для памяти  
  
Каждая инструкция CREATE TABLE для оптимизированной для памяти таблицы должна включать от 1 до 8 предложений для объявления индексов. Индекс должен быть одним из следующих:  
  
- Хэш-индекс.  
- Некластеризованный индекс (т. е. внутренняя структура сбалансированного дерева по умолчанию).  
  
  
Для объявления с параметром DURABILITY = SCHEMA_AND_DATA по умолчанию оптимизированная для памяти таблица должна иметь первичный ключ. Предложение PRIMARY KEY NONCLUSTERED в следующей инструкции CREATE TABLE отвечает двум требованиям:  
  
- предоставляет индекс, благодаря чему выполняется требование наличия по крайней мере одного индекса в инструкции CREATE TABLE;  
- предоставляет первичный ключ, необходимый для предложения SCHEMA_AND_DATA.  
  
  
  
    CREATE TABLE SupportEvent  
    (  
        SupportEventId   int NOT NULL  
            PRIMARY KEY NONCLUSTERED,  
        ...  
    )  
        WITH (  
            MEMORY_OPTIMIZED = ON,  
            DURABILITY = SCHEMA_AND_DATA);  
  
  
  
### <a name="a1-code-sample-for-syntax"></a>A.1 Пример кода для синтаксиса  
  
В этом подразделе приведен блок кода Transact-SQL, демонстрирующий синтаксис для создания различных индексов в таблице, оптимизированной для памяти. Этот код демонстрирует следующее.  
  
  
1. Создание оптимизированной для памяти таблицы.  
2. Используйте инструкции ALTER TABLE для добавления двух индексов.  
3. Вставьте (INSERT) несколько строк данных.  
  
  
  
    DROP TABLE IF EXISTS SupportEvent;  
    go  
  
    CREATE TABLE SupportEvent  
    (  
      SupportEventId   int               not null   identity(1,1)  
        PRIMARY KEY NONCLUSTERED,  
  
      StartDateTime        datetime2     not null,  
      CustomerName         nvarchar(16)  not null,  
      SupportEngineerName  nvarchar(16)      null,  
      Priority             int               null,  
      Description          nvarchar(64)      null  
    )  
      WITH (  
        MEMORY_OPTIMIZED = ON,  
        DURABILITY = SCHEMA_AND_DATA);  
    go  
      
        --------------------  
      
    ALTER TABLE SupportEvent  
      ADD CONSTRAINT constraintUnique_SDT_CN  
        UNIQUE NONCLUSTERED (StartDateTime DESC, CustomerName);  
    go  
  
    ALTER TABLE SupportEvent  
      ADD INDEX idx_hash_SupportEngineerName  
        HASH (SupportEngineerName) WITH (BUCKET_COUNT = 64);  -- Nonunique.  
    go  
      
        --------------------  
      
    INSERT INTO SupportEvent  
        (StartDateTime, CustomerName, SupportEngineerName, Priority, Description)  
      VALUES  
        ('2016-02-25 13:40:41:123', 'Abby', 'Zeke', 2, 'Проблема с выводом.'     ),  
        ('2016-02-25 13:40:41:323', 'Ben' , null  , 1, 'Не удается найти справку.'    ),  
        ('2016-02-25 13:40:41:523', 'Carl', 'Liz' , 2, 'Кнопка неактивна.'      ),  
        ('2016-02-25 13:40:41:723', 'Dave', 'Zeke', 2, 'Не удается отобразить столбец.');  
    go  
  
  
  
## <a name="b-nature-of-memory-optimized-indexes"></a>Б. Природа индексов, оптимизированных для памяти  
  
В таблице, оптимизированной для памяти, каждый индекс также будет оптимизирован для памяти. Между оптимизированными для памяти индексами и традиционными индексами в дисковой таблице есть несколько различий:  
  
Каждый оптимизированный для памяти индекс существует только в активной памяти. Индекс не имеет представления на диске.  
  
- Оптимизированные для памяти индексы перестраиваются, когда база данных переходит в оперативный режим.  
  
  
Если инструкция SQL UPDATE изменяет данные в таблице, оптимизированной для памяти, соответствующие изменения в индексах не записываются в журнал.  
  
  
Записи в индексе, оптимизированном для памяти, содержат прямой адрес строки таблицы в памяти.  
  
- В отличие от них записи в традиционном индексе в виде сбалансированного дерева на диске содержат значение ключа, которое система должна сперва использовать для поиска адреса соответствующей строки таблицы в памяти.  
  
  
Оптимизированные для памяти индексы, в отличие от дисковых индексов, не имеют фиксированных страниц.  
  
- Они не приводят к традиционной фрагментации на странице, поэтому не имеют коэффициента заполнения.  
  
## <a name="c-duplicate-index-key-values"></a>В. Повторяющиеся значения ключа индекса

Повторяющиеся значения ключа индекса могут повлиять на производительность операций с оптимизированными для памяти таблицами. Большое число повторяющихся значений (например, более 100) делают обслуживание индекса неэффективным, так как для большинства операций с индексом требуется проход по повторяющимся цепочкам. Это влияние можно наблюдать при выполнении операций INSERT, UPDATE и DELETE в оптимизированных для памяти таблицах. Особенно наглядно эта проблема проявляется в случае с хэш-индексами из-за более низких затрат на каждую операцию и конфликтов больших повторяющихся цепочек с цепочкой конфликтов хэша. Чтобы уменьшить число повторяющихся значений в индексе, используйте некластеризованный индекс и добавьте дополнительные столбцы (например, из первичного ключа) в конец ключа индекса.

Для примера рассмотрим таблицу "Клиенты" с первичным ключом в столбце "Код клиента" и индексом в столбце "Код категории клиента". Как правило, в каждой категории есть несколько клиентов, поэтому для отдельного ключа в индексе по столбцу "Код категории клиента" значения повторяются. В такой ситуации рекомендуется использовать некластеризованный индекс по столбцам (Код категории клиента, Код клиента). Такой индекс можно использовать для запросов с предикатом, включающим столбец "Код категории клиента". Он не содержит повторяющиеся значения и поэтому не снижает эффективность обслуживания индекса.

В следующем запросе показано среднее число повторяющихся значений ключа индекса для индекса `CustomerCategoryID` в таблице `Sales.Customers`в образце базы данных [WideWorldImporters](https://msdn.microsoft.com/library/mt734199(v=sql.1).aspx).

```Transact-SQL
    SELECT AVG(row_count) FROM
       (SELECT COUNT(*) AS row_count 
        FROM Sales.Customers
        GROUP BY CustomerCategoryID) a
```

Чтобы вычислить среднее число повторяющихся ключей индекса для таблицы и индекса, замените `Sales.Customers` именем таблицы, а `CustomerCategoryID` — списком столбцов ключей индекса.

## <a name="d-comparing-when-to-use-each-index-type"></a>Г. Сравнение с использованием каждого типа индекса  
  
  
Наиболее подходящий тип индекса определяется характером конкретных запросов.  

При реализации оптимизированных для памяти таблиц в существующем приложении действует общая рекомендация — начинать с некластеризованных индексов, так как их возможности больше похожи на возможности традиционных кластеризованных и некластеризованных индексов в таблицах на диске. 
  
  
### <a name="d1-strengths-of-nonclustered-indexes"></a>D.1. Преимущества некластеризованных индексов  
  
  
Некластеризованный индекс является предпочтительным по сравнению с хэш-индексом, когда:  
  
- Запросы содержат предложение ORDER BY для индексированного столбца.  
- Используются запросы, в которых проверяются только первые столбцы для индекса, состоящего из нескольких столбцов.  
- Запросы проверяют индексированный столбец с помощью предложения WHERE, в котором содержится:  
  - Неравенство: *WHERE StatusCode != 'Done'*  
  - Диапазон значений: *WHERE Quantity >= 100*  
  
  
Во всех следующих инструкциях SELECT некластеризованный индекс является предпочтительным по сравнению с хэш-индексом:  
  
  
  
    SELECT col2 FROM TableA  
        WHERE StartDate > DateAdd(day, -7, GetUtcDate());  
      
    SELECT col3 FROM TableB  
        WHERE ActivityCode != 5;  
      
    SELECT StartDate, LastName  
        FROM TableC  
        ORDER BY StartDate;  
      
    SELECT IndexKeyColumn2  
        FROM TableD  
        WHERE IndexKeyColumn1 = 42;  
  
  
  
### <a name="d2-strengths-of-hash-indexes"></a>D.2. Преимущества хэш-индексов  
  
  
[Хэш-индекс](../../relational-databases/in-memory-oltp/hash-indexes-for-memory-optimized-tables.md) является предпочтительным по сравнению с некластеризованным индексом, когда:  
  
- Запросы проверяют индексированный столбец с помощью предложения WHERE с проверкой на точное равенство всех столбцов ключей индекса, как в следующих случаях:  
  
  
  
    SELECT col9 FROM TableZ  
        WHERE Z_Id = 2174;  
  
  
  
### <a name="d3-summary-table-to-compare-index-strengths"></a>D.3. Сводная таблица для сравнения преимуществ каждого типа индекса  
  
  
В следующей таблице перечислены все операции, поддерживаемые различными типами индексов.  
  
  
| Операция | Оптимизированная для памяти, <br/> Хэш | Оптимизированная для памяти, <br/> некластеризованный | Дисковая <br/> (не)кластеризованная |  
| :-------- | :--------------------------- | :----------------------------------- | :------------------------------------ |  
| Сканирование индекса, получение всех строк таблицы. | Да | Да | Да |  
| Поиск по индексу с использованием предикатов равенства (=). | Да <br/> (Требуется полный ключ.) | Да  | Да |  
| Поиск по индексу с использованием неравенства и предикатов диапазона <br/> (>, <, <=, >=, BETWEEN). | Нет <br/> (Результаты в сканировании индекса.) | Да | Да |  
| Получение строк в порядке сортировки, соответствующем определению индекса. | Нет | Да | Да |  
| Получение строк в порядке сортировки, соответствующем обратному определению индекса. | Нет | Нет | Да |  
  
  
В таблице "Да" означает, что индекс может эффективно обслуживать запрос, а "Нет" — что не может.  

