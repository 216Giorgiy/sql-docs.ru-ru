---
title: "Рекомендации по вызову хранимых процедур, скомпилированных в собственном коде | Microsoft Docs"
ms.custom: ""
ms.date: "03/24/2017"
ms.prod: "sql-server-2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "database-engine-imoltp"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: f39fc1c7-cfec-4a95-97f6-6b95954694bb
caps.latest.revision: 8
author: "JennieHubbard"
ms.author: "jhubbard"
manager: "jhubbard"
caps.handback.revision: 8
---
# Рекомендации по вызову хранимых процедур, скомпилированных в собственном коде
  Скомпилированные в собственном коде хранимые процедуры:  
  
-   обычно используются в критически важных для производительности частях приложения;  
  
-   часто выполняются;  
  
-   предполагается, что отличаются очень высоким быстродействием.  
  
 Увеличение производительности при использовании хранимой процедуры, скомпилированной в собственном коде, растет вместе с числом строк и объемом логики, которые обрабатываются в процедуре. Например, хранимая процедура, скомпилированная в собственном коде, позволяет достичь более высокой производительности, если она использует что-либо из следующего:  
  
-   Агрегатная функция.  
  
-   Соединения вложенных циклов.  
  
-   Операции выборки, вставки, обновления и удаления с несколькими инструкциями.  
  
-   Сложные выражения.  
  
-   Процедурная логика, например условные инструкции и циклы.  
  
 Если необходимо обработать только одну строку, применение хранимой процедуры, скомпилированной в собственном коде, может не дать прироста производительности.  
  
 Во избежание необходимости сопоставления имен параметров и преобразования типов сервером выполните следующее:  
  
-   Сопоставьте типы параметров, передаваемых процедуре, с типами в определении процедуры.  
  
-   Используйте параметры с порядковыми номерами (безымянные) при вызове скомпилированных в собственном коде хранимых процедур. Для наиболее эффективного выполнения не используйте именованные параметры.  
  
 Использование именованных параметров с хранимыми процедурами, скомпилированными в собственном коде, можно обнаружить с помощью XEvent **hekaton_slow_parameter_passing**, с **reason=named_parameters**.  
  
 Аналогично можно определить использование несовместимых типов через то же событие XEvent **hekaton_slow_parameter_passing** с **reason=parameter_conversion**.  
  
 Чтобы реализовать логику повторного выполнения при использовании таблиц с оптимизацией для памяти (во многих сценариях) и обойти ограничения некоторых функций, можно создать интерпретируемую оболочкой хранимую процедуру [!INCLUDE[tsql](../../includes/tsql-md.md)]. Пример см. в разделе [Операции с таблицами, оптимизированными для памяти](../../relational-databases/in-memory-oltp/transactions-with-memory-optimized-tables.md).  
  
## См. также:  
 [Скомпилированные в собственном коде хранимые процедуры](../../relational-databases/in-memory-oltp/natively-compiled-stored-procedures.md)  
  
  