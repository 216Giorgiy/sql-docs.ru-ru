---
title: "Хэш-индексы для оптимизированных для памяти таблиц | Документация Майкрософт"
ms.custom:
- MSDN content
- MSDN - SQL DB
ms.date: 06/12/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.service: sql-database
ms.suite: 
ms.technology:
- database-engine-imoltp
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: e922cc3a-3d6e-453b-8d32-f4b176e98488
caps.latest.revision: 7
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.translationtype: Human Translation
ms.sourcegitcommit: 0eb007a5207ceb0b023952d5d9ef6d95986092ac
ms.openlocfilehash: b1acbcd97dfabfa5d23fa82e55d4eb01101233aa
ms.contentlocale: ru-ru
ms.lasthandoff: 06/13/2017

---
# <a name="hash-indexes-for-memory-optimized-tables"></a>Хэш-индексы для оптимизированных для памяти таблиц
[!INCLUDE[tsql-appliesto-ss2014-asdb-xxxx-xxx_md](../../includes/tsql-appliesto-ss2014-asdb-xxxx-xxx-md.md)]

  
В этой статье описывается тип индексов *хэш*, доступный для оптимизированных для памяти таблиц. В этой статье  
  
- Представлены небольшие примеры кода для демонстрации синтаксиса Transact-SQL.  
- Описывает основы хэш-индекса.  
- Описывает, [как оценивать число соответствующих контейнеров](#configuring_bucket_count).  
- Описано, как проектировать хэш-индексы и управлять ими.  
  
  
#### <a name="prerequisite"></a>Предварительные требования  
  
Сведения, необходимые для понимания этой статьи, доступны в следующих статьях:  
  
- [Индексы для оптимизированных для памяти таблиц](../../relational-databases/in-memory-oltp/indexes-for-memory-optimized-tables.md)  
  
  
  
## <a name="a-syntax-for-memory-optimized-indexes"></a>A. Синтаксис индексов, оптимизированных для памяти  
  
  
### <a name="a1-code-sample-for-syntax"></a>A.1 Пример кода для синтаксиса  
  
В этом подразделе представлен блок кода Transact-SQL, демонстрирующий доступные синтаксисы для создания хэш-индекса в таблице, оптимизированной для памяти.  
  
- Это пример демонстрирует хэш-индекс, объявленный в инструкции CREATE TABLE.  
  - Хэш-индекс можно также объявить в отдельной инструкции [ALTER TABLE...ADD INDEX](#h3-b2-declaration-limitations) .  
  
  
  
    DROP TABLE IF EXISTS SupportEventHash;  
    go  
      
    CREATE TABLE SupportIncidentRating_Hash  
    (  
      SupportIncidentRatingId   int      not null   identity(1,1)  
        PRIMARY KEY NONCLUSTERED,  
      
      RatingLevel          int           not null,  
      
      SupportEngineerName  nvarchar(16)  not null,  
      Description          nvarchar(64)      null,  
      
      INDEX ix_hash_SupportEngineerName  
        HASH (SupportEngineerName) WITH (BUCKET_COUNT = 100000)  
    )  
      WITH (  
        MEMORY_OPTIMIZED = ON,  
        DURABILITY = SCHEMA_ONLY);  
    go  
  

Чтобы определить подходящий `BUCKET_COUNT` для ваших данных, см. раздел [Настройка числа контейнеров хэш-индекса](#configuring_bucket_count). 
  
## <a name="b-hash-indexes"></a>Б. Хэш-индексы  
  
  
### <a name="b1-performance-basics"></a>Б.1. Основные сведения о производительности  
  
Производительность хэш-индекса обладает следующими характеристиками.  
  
- Отличная, если предложение WHERE задает *точное* значение каждого столбца в ключе хэш-индекса.  
- Низкая, если в предложении WHERE указан *диапазон* значений ключа индекса.  
- Низкая, если в предложении WHERE указано одно конкретное значение для первого столбца ключа хэш-индекса, состоящего из двух столбцов, но не указано значение для *второго* столбца ключа.  
  
  
<a name="h3-b2-declaration-limitations"></a>  
  
### <a name="b2-declaration-limitations"></a>Б.2. Ограничения для объявления  
  
Хэш-индекс может существовать только для таблицы, оптимизированной для памяти. Он не может существовать для таблицы на диске.  
  
Хэш-индекс можно объявить как:  
  
- УНИКАЛЬНЫЙ или неуникальный по умолчанию.  
- НЕКЛАСТЕРИЗОВАННЫЙ, который используется по умолчанию.   
  
  
Приведем пример синтаксиса для создания хэш-индекса за пределами инструкции CREATE TABLE:  
  
  
    ALTER TABLE MyTable_memop  
      ADD INDEX ix_hash_Column2 UNIQUE  
        HASH (Column2) WITH (BUCKET_COUNT = 64);  
  
  
  
### <a name="b3-buckets-and-hash-function"></a>Б.3. Контейнеры и функция хэша  
  
Хэш-индекс связывает свои значения ключей в так называемый массив *контейнеров* :  
  
- Каждый контейнер имеет размер 8 байт, в которых хранится адрес списка ссылок на записи ключей.  
- Каждая запись представляет собой значение ключа индекса, к которому добавляется адрес соответствующей строки в оптимизированной для памяти таблице.  
  - Каждая запись указывает на следующую запись в списке ссылок на записи, связанных с текущим контейнером.  
  
  
Алгоритм хэширования пытается равномерно распределить все уникальные значения ключей между своими контейнерами, однако общая однородность всегда недостижима. Все экземпляры того или иного значения ключа соединяются с одним контейнером. Кроме того, все экземпляры в контейнере могут быть связаны с разными значениями ключей.  
  
- Такая комбинация называется *конфликтом хэша*. Конфликты распространены, но это не слишком хорошо.  
- Реалистичная цель — сделать так, чтобы 30 % контейнеров содержали два различных значения ключа.  
  
  
Количество контейнеров в хэш-индексе определяете вы.  
  
- Чем меньше отношение количества контейнеров к количеству строк или уникальных значений, тем длиннее будет средний список ссылок на контейнеры.  
- Короткие списки обладают большим быстродействием по сравнению с длинными.  
  
  
В SQL Server есть одна функция хэша, используемая для всех хэш-индексов:  
  
- Хэш-функция детерминирована: для одного и того же значения ключа она всегда возвращает один и тот же слот контейнеров.  
- С повторными вызовами выходные значения хэш-функции, как правило, формируют распределение с кривой Пуассона или колоколообразной кривой, а не плоское линейное распределение.  
  
  
Взаимозависимость хэш-индекса и контейнеров иллюстрируется на следующем рисунке.  
  
  
![hekaton_tables_23d](../../relational-databases/in-memory-oltp/media/hekaton-tables-23d.png "Ключи индекса для подачи на вход хэш-функции. Выходом является адрес сегмента хэша, который указывает на начало цепочки.")  
  
  
  
### <a name="b4-row-versions-and-garbage-collection"></a>Б.4. Версии строк и сбор мусора  
  
  
При изменении строки с помощью инструкции SQL UPDATE в таблице, оптимизированной для памяти, создается обновленная версия строки. Во время транзакции обновления другие сеансы могут считать старую версию строки и тем самым избежать снижения производительности, связанной с блокировкой строки.  
  
Кроме того, хэш-индекс может иметь различные версии записей для отражения обновления.  
  
Позже, когда старые версии больше не требуются, поток сборки мусора перебирает список контейнеров и их списки ссылок, удаляя старые записи. Поток сборки мусора работает быстрее, если списки ссылок короткие.   
  
<a name="configuring_bucket_count"></a>
  
## <a name="c-configuring-the-hash-index-bucket-count"></a>В. Настройка числа контейнеров хэш-индекса  
  
Число контейнеров хэш-индекса указывается в момент создания индекса и может быть изменено с помощью синтаксиса ALTER TABLE...ALTER INDEX REBUILD.  
  
В большинстве случаев идеальное число контейнеров должно находиться в диапазоне, в 1–2 раза превышающем число уникальных значений в ключе индекса.   
Не всегда можно спрогнозировать количество значений, которые содержит конкретный ключ индекса. Обычно производительность остается хорошей, если значение **BUCKET_COUNT** входит в диапазон значений, в 10 раз превышающих фактическое число ключевых значений, и, как правило, его лучше переоценить, чем недооценить.  
  
Слишком *малое* количество контейнеров имеет следующие недостатки.  
  
- Возникает больше конфликтов хэша из-за уникальных значений ключей.  
  - Каждое уникальное значение вынуждено использовать один и тот же контейнер с другим уникальным значением.  
  - Средняя длина цепочки для контейнера возрастает.  
  - Чем длиннее цепочка контейнеров, тем медленнее скорость выполнения проверки на равенство индексов и  
  
Слишком *большое* количество контейнеров имеет следующие недостатки.  
  
- Слишком большое число контейнеров может привести к увеличению количества пустых контейнеров.  
  - Пустые контейнеры влияют на скорость полного сканирования индексов. Если сканирования выполняются регулярно, можно выбрать число контейнеров, близкое к числу уникальных значений ключа индекса.  
  - Пустые контейнеры задействуют память, хотя каждый контейнер использует всего 8 байт.  
    
  
> [!NOTE]
> При добавлении большего числа контейнеров цепочка записей, которые имеют повторяющееся значение, не уменьшается. Степень повторяемости значения используется для того, чтобы решить, правильный ли тип имеет индекс, а не для определения числа контейнеров.  
  
  
  
### <a name="c1-practical-numbers"></a>В.1. Практические величины  
  
Даже если количество контейнеров **BUCKET_COUNT** умеренно ниже или выше предпочитаемого диапазона, производительность хэш-индекса, скорее всего, будет допустимой или приемлемой. Кризиса не возникнет.  
  
Присвойте параметру **BUCKET_COUNT** для своего хэш-индекса значение, примерно равное количеству строк, которое оптимизированная для памяти таблица будет иметь после увеличения.  
  
Предположим, что в растущей таблице около 2 000 000 строк и вы предполагаете, что она вырастет в 10 раз, до 20 000 000 строк. Начните с числа контейнеров, которое в 10 раз превышает количество строк в таблице. Так вы получите запас для увеличения количества строк.  
  
- В идеальном случае, когда количество строк достигает первоначального количества контейнеров, это количество увеличивается.  
- Даже если количество строк превышает количество контейнеров в 5 раз, в большинстве случаев производительность остается высокой.  
  
Предположим, что хэш-индекс содержит 10 000 000 уникальных значений ключей.  
  
- Для такого индекса можно установить количество контейнеров в 2 000 000. Степень снижения производительности может быть приемлемой.  
  
### <a name="c2-too-many-duplicate-values-in-the-index"></a>В.2. В индексе слишком много повторяющихся значений?  
  
Если значения хэш-индекса имеют высокий процент дубликатов, хэш-контейнеры имеют более длинные цепочки.  
  
Возьмем таблицу SupportEvent, которая использовалась в одном из предыдущих блоков кода T-SQL. Следующий код T-SQL демонстрирует определение и отображение отношения *всех* значений к *уникальным* значениям:  
  
        -- Calculate ratio of:  Rows / Unique_Values.  
    DECLARE @allValues float(8) = 0.0, @uniqueVals float(8) = 0.0;  
      
    SELECT @allValues = Count(*) FROM SupportEvent;  
      
    SELECT @uniqueVals = Count(*) FROM  
      (SELECT DISTINCT SupportEngineerName  
         FROM SupportEvent) as d;  
      
        -- If (All / Unique) >= 10.0, use a nonclustered index, not a hash.   
    SELECT Cast((@allValues / @uniqueVals) as float) as [All_divby_Unique];  
    go  
  
- Отношение 10.0 и выше означает, что хэш-индекс будет обладать низкой производительностью. Вместо этого можно использовать некластеризованный индекс.   
  
## <a name="d-troubleshooting-hash-index-bucket-count"></a>Г. Устранение неполадок, связанных с числом контейнеров хэш-индекса  
  
В этом разделе рассказывается, как устранять неполадки, связанные с числом контейнеров хэш-индекса.  
  
### <a name="d1-monitor-statistics-for-chains-and-empty-buckets"></a>Г.1. Отслеживание статистики для цепочек и пустых контейнеров  
  
Для отслеживания показателей работоспособности хэш-индексов можно выполнить следующую инструкцию T-SQL SELECT. Эта инструкция SELECT использует динамическое административное представление с именем **sys.dm_db_xtp_hash_index_stats**.  
  
  
```t-sql
  SELECT  
    QUOTENAME(SCHEMA_NAME(t.schema_id)) + N'.' + QUOTENAME(OBJECT_NAME(h.object_id)) as [table],   
    i.name                   as [index],   
    h.total_bucket_count,  
    h.empty_bucket_count,  
      
    FLOOR((  
      CAST(h.empty_bucket_count as float) /  
        h.total_bucket_count) * 100)  
                             as [empty_bucket_percent],  
    h.avg_chain_length,   
    h.max_chain_length  
  FROM  
         sys.dm_db_xtp_hash_index_stats  as h   
    JOIN sys.indexes                     as i  
            ON h.object_id = i.object_id  
           AND h.index_id  = i.index_id  
    JOIN sys.memory_optimized_tables_internal_attributes ia ON h.xtp_object_id=ia.xtp_object_id
    JOIN sys.tables t on h.object_id=t.object_id
  WHERE ia.type=1
  ORDER BY [table], [index];  
```
  
  
Сравните результаты, полученные от инструкции SELECT, со следующими статистическими рекомендациями.  
  
- Пустые контейнеры:  
  - 33 % является хорошим целевым значением, но обычно подходит более высокий процент (даже 90 %).  
  - Если количество контейнеров равно количеству уникальных значений ключей, то примерно 33 % контейнеров пусты.  
  - Значение ниже 10 % считается слишком маленьким.  
- Цепочки внутри контейнеров:  
  - Средняя длина цепочки, равная 1, является оптимальной в случае, когда нет повторяющихся значений ключей индекса. Обычно приемлемыми являются цепочки длиной до 10.  
  - Если средняя длина цепочки превышает 10 и доля пустых контейнеров превышает 10 %, это означает, что данные содержат так много дубликатов, что хэш-индекс может быть не самым подходящим типом индекса.  
  

  
### <a name="d2-demonstration-of-chains-and-empty-buckets"></a>Г.2. Демонстрация цепочек и пустых контейнеров  
  
  
Следующий блок кода T-SQL позволяет легко протестировать `SELECT * FROM sys.dm_db_xtp_hash_index_stats;`. Выполнения блока кода занимает 1 минуту. Блок кода включает следующие этапы:  
  
  
1. Создает оптимизированную для памяти таблицу, которая имеет несколько хэш-индексов.  
2. Заполняет эту таблицу несколькими тысячами строк.  
    A. Для настройки частоты повторяющихся значений в столбце StatusCode используется оператор остатка от деления.  
    Б. В цикле в таблицу вставляется (INSERT) 262 144 строки примерно за 1 минуту.  
3. Выводит приглашение выполнить предыдущую инструкцию SELECT из **sys.dm_db_xtp_hash_index_stats**.  
  
  
```t-sql
    DROP TABLE IF EXISTS SalesOrder_Mem;  
    go  
      
      
    CREATE TABLE SalesOrder_Mem  
    (  
      SalesOrderId   uniqueidentifier  NOT NULL  DEFAULT newid(),  
      OrderSequence  int               NOT NULL,  
      OrderDate      datetime2(3)      NOT NULL,  
      StatusCode     tinyint           NOT NULL,  
      
      PRIMARY KEY NONCLUSTERED  
          HASH (SalesOrderId)  WITH (BUCKET_COUNT = 262144),  
      
      INDEX ix_OrderSequence  
          HASH (OrderSequence) WITH (BUCKET_COUNT = 20000),  
      
      INDEX ix_StatusCode  
          HASH (StatusCode)    WITH (BUCKET_COUNT = 8),  
      
      INDEX ix_OrderDate       NONCLUSTERED (OrderDate DESC)  
    )  
      WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
    go  
      
        --------------------  
      
    SET NoCount ON;  
      
      -- Same as PK bucket_count.  68 seconds to complete.  
    DECLARE @i int = 262144;  
      
    BEGIN TRANSACTION;  
      
    WHILE @i > 0  
    Begin  
      
      INSERT SalesOrder_Mem  
          (OrderSequence, OrderDate, StatusCode)  
        Values  
          (@i, GetUtcDate(), @i % 8);  -- Modulo technique.  
      
      SET @i -= 1;  
    End  
    COMMIT TRANSACTION;  
      
    PRINT 'Next, you should query:  sys.dm_db_xtp_hash_index_stats .';  
    go  
```  
  
  
Предыдущий цикл INSERT выполняет следующие функции.  
  
- Вставляет уникальные значения в индекс первичного ключа и в ix_OrderSequence.  
- Вставляет несколько сотен тысяч строк, представляющих всего 8 различных значений StatusCode. Следовательно, существует высокая доля дублирования значений в индексе ix_StatusCode.  
  
Если число контейнеров не является оптимальным, изучите следующие выходные данные инструкции SELECT из **sys.dm_db_xtp_hash_index_stats**для решения проблемы. Для этих результатов мы добавили `WHERE Object_Name(h.object_id) = 'SalesOrder_Mem'` в операцию SELECT, скопированную из раздела Г.1.  
  
  
  
Результаты операции SELECT отображаются после кода и искусственно разбиваются на две таблицы более узких результатов для более удобного отображения.  
  
- Приведем результаты для *числа контейнеров*.  
  
  
| IndexName | total_bucket_count | empty_bucket_count | EmptyBucketPercent |  
| :-------- | -----------------: | -----------------: | -----------------: |  
| ix_OrderSequence | 32768 | 13 | 0 |  
| ix_StatusCode | 8 | 4 | 50 |  
| PK_SalesOrd_B14003... | 262144 | 96525 | 36 |  
  
  
- Приведем результаты для *длины цепочки*.  
  
  
| IndexName | avg_chain_length | max_chain_length |  
| :-------- | ---------------: | ---------------: |  
| ix_OrderSequence | 8 | 26 |  
| ix_StatusCode | 65536 | 65536 |  
| PK_SalesOrd_B14003... | 1 | 8 |  
  
  
  
  
Разберем предыдущие таблицы результатов для трех хэш-индексов.  
  
*ix_StatusCode:*  
  
- 50 % контейнеров пусты, это хорошо.  
- Однако средняя длина цепочки очень высока (65536).  
  - Это указывает на большое количество повторяющихся значений.  
  - Поэтому хэш-индекс в данном случае не подходит. Вместо этого следует пользоваться некластеризованным индексом.  
  
*ix_OrderSequence:*  
  
- 0 % контейнеров пусты, это слишком мало.  
- Средняя длина цепочки составляет 8 даже несмотря на то, что все значения в этом индексе являются уникальными.  
  - Поэтому число контейнеров следует увеличить, чтобы уменьшить среднюю длину цепочки до 2 или 3.  
- Поскольку ключ индекса имеет 262 144 уникальных значения, число контейнеров должно быть не менее 262 144.  
  - Если в будущем количество строк увеличится, количество контейнеров должно быть больше.  
  
*Индекс первичного ключа (PK_SalesOrd_...):*  
  
- 36 % контейнеров пусты, это хорошо.  
- Средняя длина цепочки равна 1, что тоже является хорошим показателем. Изменений не требуется.  
  
  
### <a name="d3-balancing-the-trade-off"></a>Г.3. Достижение компромисса  
  
Рабочие нагрузки OLTP сосредотачиваются на отдельных строках. Полное сканирование таблиц обычно не является критическим для производительности для рабочих нагрузок OLTP. Поэтому компромисс, которого необходимо добиться, заключается между:  
  
- объемом использования памяти; и  
- производительностью проверок на равенство операций вставки.  
  
  
*Если использование памяти имеет большее значение:*  
  
- выберите число контейнеров, близкое к числу записей ключа индекса.  
- Число контейнеров не должно быть значительно меньше числа значений ключа индекса, поскольку это влияет на большинство операций DML, а также на время, необходимое для восстановления базы данных после перезапуска сервера.  
  
  
*Если производительность проверок на равенство имеет большее значение:*  
  
- допустимо увеличить число контейнеров, так чтобы оно превышало количество уникальных значений индекса в 2–3 раза. Большее количество означает следующее.  
  - Более быстрое получение значений при поиске конкретного значения.  
  - Увеличенное использование памяти.  
  - Увеличение времени, необходимого для полного сканирования хэш-индекса.  
  
  
  
  
## <a name="e-strengths-of-hash-indexes"></a>Д. Преимущества хэш-индексов  
  
  
Хэш-индекс является предпочтительным по сравнению с некластеризованным индексом, когда:  
  
- Запросы проверяют индексированный столбец с помощью предложения WHERE с проверкой на равенство, как в следующих случаях:  
  
  
  
    SELECT col9 FROM TableZ  
        WHERE Z_Id = 2174;  
  
  
  
### <a name="e1-multi-column-hash-index-keys"></a>Д.1. Хэш-индексы с несколькими столбцами  
  
  
Индекс с двумя столбцами не может быть некластеризованным или хэш-индексом. Предположим, что индекс включает столбцы col1 и col2. Учитывая следующую инструкцию SQL SELECT, для оптимизатора запросов пригодится только некластеризованный индекс:  
  
  
    SELECT col1, col3  
        FROM MyTable_memop  
        WHERE col1 = 'dn';  
  
  
Для хэш-индекса в предложении WHERE должен быть задан тест на равенство для каждого столбца в ключе. Без него хэш-индекс не будет полезен для оптимизатора.  
  
Тип индекса также не будет иметь значения, если предложение WHERE определяет только второй столбец ключа индекса.  

