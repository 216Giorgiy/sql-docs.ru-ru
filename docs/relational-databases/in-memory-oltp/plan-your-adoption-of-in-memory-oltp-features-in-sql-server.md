---
title: "Планирование применения выполняющейся в памяти OLTP в SQL Server | Документация Майкрософт"
ms.custom: 
ms.date: 05/08/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology:
- database-engine-imoltp
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 041b428f-781d-4628-9f34-4d697894e61e
caps.latest.revision: 4
author: MightyPen
ms.author: genemi
manager: jhubbard
ms.translationtype: Human Translation
ms.sourcegitcommit: 0bcdf5c7eec91bccabc4b7b54f6121bec4d6c7f2
ms.openlocfilehash: bf29cd596c9b52ecf88fc715a580253de5477271
ms.contentlocale: ru-ru
ms.lasthandoff: 06/23/2017

---
# <a name="plan-your-adoption-of-in-memory-oltp-features-in-sql-server"></a>Планирование освоения возможностей выполняющейся в памяти OLTP в SQL Server
[!INCLUDE[tsql-appliesto-ss2014-asdb-xxxx-xxx_md](../../includes/tsql-appliesto-ss2014-asdb-xxxx-xxx-md.md)]


В этой статье описывается, как освоение возможностей технологии обработки в памяти влияет на другие аспекты вашей бизнес-системы.



## <a name="a-adoption-of-in-memory-oltp-features"></a>A. Освоение возможностей выполняющейся в памяти OLTP


В следующих подразделах описываются факторы, которые необходимо учитывать при планировании освоения и реализации возможностей технологии обработки в памяти. Пояснительная информация в значительном объеме доступна в следующей статье:

- [Повышение производительности приложений в Базе данных SQL Azure с помощью выполняющейся в памяти OLTP](https://azure.microsoft.com/documentation/articles/sql-database-in-memory-oltp-migration/)



### <a name="a1-prerequisites"></a>A.1. Предварительные условия

Одним из предварительных требований, связанных с использованием возможностей технологии обработки в памяти, может являться наличие определенного выпуска продукта SQL или уровня SQL-службы. Это и другие предварительные требования описаны в следующих источниках:

- [Требования для использования таблиц, оптимизированных для памяти](../../relational-databases/in-memory-oltp/requirements-for-using-memory-optimized-tables.md)
    - [Выпуски и компоненты SQL Server 2016](../../sql-server/editions-and-components-of-sql-server-2016.md)
    - [Рекомендации по ценовому уровню базы данных SQL](https://azure.microsoft.com/documentation/articles/sql-database-service-tier-advisor/)


### <a name="a2-forecast-the-amount-of-active-memory"></a>A.2. Прогнозирование объема активной памяти

В вашей системе достаточно активной памяти для обеспечения работы новой таблицы, оптимизированной для обработки в памяти?

#### <a name="microsoft-sql-server"></a>Microsoft SQL Server

Оптимизированная для обработки в памяти таблица, которая содержит 200 ГБ данных, требует выделения на ее поддержку более 200 ГБ активной памяти. Прежде чем создавать оптимизированную для обработки в памяти таблицу с большим объемом данных, необходимо спрогнозировать объем дополнительной активной памяти, которую, возможно, потребуется добавить на серверный компьютер. Руководство по оценке см. в следующих статьях:

- [Оценка требований к объему памяти для таблиц, оптимизированных для памяти](../../relational-databases/in-memory-oltp/estimate-memory-requirements-for-memory-optimized-tables.md)

#### <a name="azure-sql-database"></a>База данных SQL Azure

Для базы данных, размещенной в облачной службе базы данных SQL Azure, выбранный уровень службы повлияет на объем активной памяти, которую разрешено потреблять вашей базе данных. Необходимо спланировать мониторинг использования памяти вашей базой данных при помощи предупреждений. Подробная информация доступна в следующих статьях:

- Проверьте ограничения In-Memory OLTP хранения для вашей [ценовую категорию.](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-service-tiers#single-database-service-tiers-and-performance-levels)
- [Мониторинг хранилища OLTP в памяти](https://azure.microsoft.com/documentation/articles/sql-database-in-memory-oltp-monitoring/)

#### <a name="memory-optimized-table-variables"></a>Оптимизированные для памяти табличные переменные

Иногда использовать табличную переменную, которая объявляется как оптимизированная для обработки в памяти, предпочтительнее, чем традиционную переменную #TempTable, расположенную в базе данных **tempdb** . Такие табличные переменные позволяют существенно повысить производительность, не расходуя большие объемы активной памяти.

### <a name="a3-table-must-be-offline-to-convert-to-memory-optimized"></a>A.3. Таблицу можно преобразовать в оптимизированную для обработки в памяти, только если она не используется

Некоторые функциональные возможности инструкции ALTER TABLE доступны для таблиц, оптимизированных для обработки в памяти. Однако инструкцию ALTER TABLE не получится использовать, чтобы преобразовать дисковую таблицу в таблицу, оптимизированную для обработки в памяти. Вместо этого необходимо выполнить несколько неавтоматизированных действий. Ниже описано несколько способов преобразования дисковой таблицы в оптимизированную для обработки в памяти.

#### <a name="manual-scripting"></a>Написание скриптов вручную

Один из способов преобразования дисковой таблицы в таблицу, оптимизированную для обработки в памяти, заключается в самостоятельном создании кода для необходимых действий Transact-SQL.


1. Приостановите работу приложения.

2. Создайте полную резервную копию.

3. Переименуйте дисковую таблицу.

4. Выполните инструкцию CREATE TABLE для создания новой оптимизированной для обработки в памяти таблицы.

5. Вставьте (INSERT INTO) в свою оптимизированную для обработки в памяти таблицу данные из дисковой таблицы (с использованием вложенного SELECT).

6. Удалите (DROP) дисковую таблицу.

7. Создайте еще одну полную резервную копию.

8. Возобновите работу приложения.


#### <a name="memory-optimization-advisor"></a>Помощник по оптимизации памяти

Помощник по оптимизации памяти позволяет создавать скрипт преобразования дисковой таблицы в оптимизированную для обработки в памяти таблицу. Он устанавливается в составе SQL Server Data Tools (SSDT).

- [Помощник по оптимизации памяти](../../relational-databases/in-memory-oltp/memory-optimization-advisor.md)
- [Скачать SQL Server Data Tools (SSDT)](https://msdn.microsoft.com/library/mt204009.aspx)


#### <a name="dacpac-file"></a>DACPAC-файл

Воспользовавшись DACPAC-файлом, которым управляют SSDT, можно обновить базу данных "на месте". В SSDT можно задать изменения схемы, которые кодируются в DACPAC-файл.

Работа с DACPAC-файлами выполняется в контексте проекта Visual Studio типа *База данных*.

- [Приложения уровня данных](../../relational-databases/data-tier-applications/data-tier-applications.md) и DACPAC-файлы



### <a name="a4-guidance-for-whether-in-memory-oltp-features-are-right-for-your-application"></a>A.4. Руководство по определению того, подходит ли выполняющаяся в памяти OLTP вашему приложению

Рекомендации по ли функции выполнения OLTP в памяти может повысить производительность конкретного приложения см. в разделе:

- [In-Memory OLTP (оптимизация в памяти)](../../relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization.md)



## <a name="b-unsupported-features"></a>Б. Неподдерживаемые функции

В описаны компоненты, которые не поддерживаются в некоторых сценариях OLTP в памяти:

- [Неподдерживаемые функции SQL Server для выполняющейся в памяти OLTP](../../relational-databases/in-memory-oltp/unsupported-sql-server-features-for-in-memory-oltp.md)


В следующих подразделах рассматривается ряд весьма важных неподдерживаемых возможностей.


### <a name="b1-snapshot-of-a-database"></a>Б.1. Снимок (SNAPSHOT) базы данных

После создания первой оптимизированной для обработки в памяти таблицы или модуля в конкретной базе данных сделать [снимок](../../relational-databases/databases/database-snapshots-sql-server.md) этой базы данных становится невозможно. Причина в следующем:

- первый элемент, оптимизированный для обработки в памяти, делает невозможным удаление последнего файла из оптимизированной для обработки в памяти файловой группы (FILEGROUP); и
- ни одна база данных с файлом в оптимизированной для обработки в памяти файловой группе не поддерживает снимки.

Как правило, SNAPSHOT удобно использовать в быстрых итерациях тестирования.


### <a name="b2-cross-database-queries"></a>Б.2. Межбазовые запросы

Оптимизированные для обработки в памяти таблицы не поддерживают [межбазовые](../../relational-databases/in-memory-oltp/cross-database-queries.md) транзакции. Нельзя получить доступ к другой базе данных из той же транзакции или того же запроса, которые также получают доступ к оптимизированной для памяти таблицы.

Табличные переменные не является транзакционными. Следовательно, [переменные оптимизированных для обработки в памяти таблиц](../../relational-databases/in-memory-oltp/faster-temp-table-and-table-variable-by-using-memory-optimization.md) можно использовать в межбазовых запросах.


### <a name="b3-readpast-table-hint"></a>Б.3. Табличное указание READPAST

Не существует запроса, способного применить [табличное указание](../../t-sql/queries/hints-transact-sql-table.md) READPAST к какой-либо оптимизированной для обработки в памяти таблице.

Указание READPAST полезно в случаях, в которых несколько сеансов обращаются к одному и тому же небольшому набору строк и вносят в эти строки изменения, например при обработке очереди.


### <a name="b4-rowversion-sequence"></a>Б.4. RowVersion, объект Sequence

- Не существует столбца, который можно пометить как [RowVersion](../../t-sql/data-types/rowversion-transact-sql.md) в оптимизированной для обработки в памяти таблице.


- Объект [ПОСЛЕДОВАТЕЛЬНОСТИ](../../t-sql/statements/create-sequence-transact-sql.md) не может использоваться с ограничением в таблице, оптимизированной для памяти. Например с предложением NEXT VALUE FOR не может создать ограничение по умолчанию. Последовательности может использоваться с инструкциями INSERT и UPDATE.


## <a name="c-administrative-maintenance"></a>В. Обслуживание в рамках администрирования


В этом разделе описываются различия в администрировании баз данных, в которых используются оптимизированные для обработки в памяти таблицы.


### <a name="c1-identity-seed-reset-increment--1"></a>В.1. Сброс начального значения идентификаторов, приращение >1

Инструкция [DBCC CHECKIDENT](../../t-sql/database-console-commands/dbcc-checkident-transact-sql.md) не может использоваться для повторного заполнения столбца IDENTITY начальными значениями в оптимизированной для обработки в памяти таблице.

Значение приращения столбца IDENTITY ограничено единицей (1) в таблице, оптимизированной для обработки в памяти.


### <a name="c2-dbcc-checkdb-cannot-validate-memory-optimized-tables"></a>В.2. Инструкция DBCC CHECKDB не может проверять оптимизированные для обработки в памяти таблицы

Если целевым объектом инструкции [DBCC CHECKDB](../../t-sql/database-console-commands/dbcc-checkdb-transact-sql.md) является оптимизированная для обработки в памяти таблица, никакие действия не выполняются. Обходное решение:


1. [Резервное копирование журнала транзакций](../../relational-databases/backup-restore/back-up-a-transaction-log-sql-server.md).

2. Выполните резервное копирование файлов в оптимизированной для обработки в памяти файловой группе на NULL-устройство. Процесс резервного копирования вызывает проверку контрольных сумм.

    При обнаружении повреждений перейдите к следующим шагам.

3. Скопируйте данные из оптимизированных для обработки в памяти таблиц в дисковые таблицы на временное хранение.

4. Восстановите файлы оптимизированной для обработки в памяти файловой группы.

5. Вставьте (INSERT INTO) в оптимизированные для обработки в памяти таблицы данные, которые временно сохранены в дисковых таблицах.

6. Удалите (DROP) дисковые таблицы, в которых были временно сохранены данные.



## <a name="d-performance"></a>Г. Производительность

В этом разделе описываются ситуации, в которых определенные обстоятельства могут мешать отличным показателям в сфере производительности оптимизированных для обработки в памяти таблиц проявиться в полной мере.


### <a name="d1-index-considerations"></a>Г.1. Несколько замечаний об индексах

Все индексы в оптимизированной для обработки в памяти таблице создаются и управляются при помощи табличных инструкций, CREATE TABLE и ALTER TABLE. Невозможно работать с оптимизированной для обработки в памяти таблицей через инструкцию CREATE INDEX.

Зачастую целесообразно и удобно использовать при первоначальной реализации оптимизированной для обработки в памяти таблицы традиционный некластеризованный индекс сбалансированного дерева. Впоследствии, проанализировав работу приложения, можно перейти на индекс другого типа.

Два специальных типа индексов требуют дополнительного обсуждения в контексте оптимизированных для обработки в памяти таблиц: хэш-индексы и индексы Columnstore.

Обзорную информацию об индексах в оптимизированных для обработки в памяти таблицах см. в следующих источниках:

- [Индексы для оптимизированных для памяти таблиц](../../relational-databases/in-memory-oltp/indexes-for-memory-optimized-tables.md)


#### <a name="hash-indexes"></a>Хэш-индексы

Иногда хэш-индексы — это самый быстрый способ получить доступ к конкретной строке, указав точное значение первичного ключа в операторе**=**.

- Неточные операторы, такие как**!=**,**>**или**BETWEEN**, могут снизить производительность при использовании совместно с хэш-индексом.

- Возможно, хэш-индекс не лучший выбор, если скорость дублирования значений ключа становится слишком высокой.

- Опасно недооценивать число *контейнеров* , которое может потребоваться хэш-индексу, это может привести к длинным цепочкам в отдельных контейнерах, чего следует избегать. Подробная информация доступна в следующих статьях:
    - [Хэш-индексы для оптимизированных для памяти таблиц](../../relational-databases/in-memory-oltp/hash-indexes-for-memory-optimized-tables.md)


#### <a name="nonclustered-columnstore-indexes"></a>Некластеризованные индексы columnstore

Оптимизированные для обработки в памяти таблицы обеспечивают высокую скорость обработки типичных транзакционных бизнес-данных, что в парадигме называется *обработкой транзакций в режиме реального времени* (или *OLTP*). Индексы Columnstore обеспечивают высокую скорость обработки агрегирования и других аналогичных операций обработки данных, которые мы называем *аналитикой*. В прошлом для удовлетворения потребностей OLTP и обработки аналитических операций считалось оптимальным наличие отдельных таблиц с активным перемещением данных и определенной степенью дублирования. Сегодня доступно более простое **гибридное решение** : индекс columnstore в оптимизированной для обработки в памяти таблице.


- [Индекс columnstore](../../relational-databases/indexes/columnstore-indexes-overview.md) может быть создан на основе дисковой таблицы и даже в форме кластеризованного индекса. Однако в таблице, оптимизированной для обработки в памяти, индекс columnstore не может быть кластеризован.


- Столбцы LOB или внестрочные столбцы в оптимизированной для обработки в памяти таблице не позволяют создавать в таблице индекс columnstore.


- Инструкции ALTER TABLE не могут выполняться в отношении таблицы, оптимизированной для обработки в памяти, при наличии в последней индекса columnstore.
    - С августа 2016 года корпорация Майкрософт активно работает над повышением эффективности повторного создания индекса columnstore.



### <a name="d2-lob-and-off-row-columns"></a>Г.2. Столбцы LOB и внестрочные столбцы

Большие объекты (LOB) — это столбцы таких типов, как varchar (**max**). Наличие пары столбцов LOB в таблице, оптимизированной для обработки в памяти, наверное, не окажет сколько-нибудь ощутимого отрицательного влияния на производительность. Однако старайтесь не создавать лишние столбцы LOB. То же самое касается внестрочных столбцов. Не присваивайте столбцу тип nvarchar(3072), если достаточно varchar(512).


Чуть более подробные сведения о столбцах LOB и внестрочных столбцах доступны в следующих источниках:

- [Размер строк и таблицы для таблиц, оптимизированных для памяти](../../relational-databases/in-memory-oltp/table-and-row-size-in-memory-optimized-tables.md)
- [Поддерживаемые типы данных для выполняющейся в памяти OLTP](../../relational-databases/in-memory-oltp/supported-data-types-for-in-memory-oltp.md)



## <a name="e-limitations-of-native-procs"></a>Д. Ограничения, связанные со скомпилированными в машинный код процедурами


Определенные элементы Transact-SQL не поддерживаются в скомпилированных в машинный код хранимых процедурах.

Факторы, которые необходимо учесть при переносе скрипта Transact-SQL в скомпилированную в машинный код процедуру, описаны в следующей статье:

- [Проблемы миграции, связанные с хранимыми процедурами, скомпилированными в собственном коде](../../relational-databases/in-memory-oltp/migration-issues-for-natively-compiled-stored-procedures.md)


### <a name="e1-no-case-in-a-native-proc"></a>Д.1. Отсутствие выражения CASE в скомпилированной в машинный код процедуре

Выражение CASE в Transact-SQL невозможно использовать в скомпилированной в машинный код процедуре. Однако существует обходное решение:

- [Реализация выражения CASE в скомпилированной в собственном коде хранимой процедуре](../../relational-databases/in-memory-oltp/implementing-a-case-expression-in-a-natively-compiled-stored-procedure.md)


### <a name="e2-no-merge-in-a-native-proc"></a>Д.2. Отсутствие выражения MERGE в скомпилированной в машинный код процедуре


[Инструкция MERGE](../../t-sql/statements/merge-transact-sql.md) в Transact-SQL похожа на логику *upsert* ("изменить данные, если они существуют, либо вставить, если их еще нет"). Ее невозможно использовать в скомпилированной в машинный код процедуре. Однако схожую с MERGE функциональность можно обеспечить сочетанием инструкций SELECT, UPDATE и INSERT. Пример кода доступен в следующей статье:

- [Реализация функциональности MERGE в скомпилированной в собственном коде хранимой процедуре](../../relational-databases/in-memory-oltp/implementing-merge-functionality-in-a-natively-compiled-stored-procedure.md)



### <a name="e3-no-joins-in-update-or-delete-statements-in-a-native-proc"></a>Д.3. Отсутствие соединений в инструкциях UPDATE и DELETE в скомпилированной в машинный код процедуре

Инструкции Transact-SQL в скомпилированной в машинный код процедуре могут обращаться только к оптимизированным для обработки в памяти таблицам. В инструкциях UPDATE и DELETE невозможно соединить какие бы то ни было таблицы. Попытки сделать это в скомпилированной в машинный код процедуре завершатся ошибками с сообщением 12319, которое поясняет следующее:

- Невозможно использовать предложение FROM в инструкции UPDATE.
- Невозможно указывать таблицу-источник в инструкции DELETE.

Нет таких вложенных запросов, которые помогли бы обойти эту ситуацию. Однако можно использовать переменную оптимизированной для обработки в памяти таблицы, чтобы выполнить соединение в несколько инструкций. Ниже представлены два примера кода:

- Инструкции DELETE...JOIN...: желательно использовать в отношении скомпилированной в машинный код процедуры, однако невозможно.
- Существует обходное решение, состоящее из ряда инструкций Transact-SQL, позволяющих выполнить удаление и соединение.


*Ситуация:* таблица TabProjectEmployee имеет уникальный ключ из двух столбцов: ProjectId и EmployeeId. Каждая строка указывает на назначение сотрудника активному проекту. Когда сотрудник уходит из компании, его необходимо удалить из таблицы TabProjectEmployee.


#### <a name="invalid-t-sql-deletejoin"></a>Недопустимая инструкция T-SQL, DELETE...JOIN


В скомпилированной в машинный код процедуре невозможно использовать инструкции DELETE...JOIN следующим образом.


```tsql
DELETE pe
    FROM
             TabProjectEmployee   AS pe
        JOIN TabEmployee          AS e

            ON pe.EmployeeId = e.EmployeeId
    WHERE
            e.EmployeeStatus = 'Left-the-Company'
;
```


#### <a name="valid-work-around-manual-deletejoin"></a>Рабочее обходное решение: удаление и соединение вручную

Ниже представлен пример кода для реализации этого обходного пути (в двух частях):

1. Инструкция CREATE TYPE выполняется один раз и задолго до того, как тип в первый раз используется любой реальной табличной переменной.

2. Созданный тип используется в бизнес-процессе. Для начала объявляется табличная переменная типа созданной таблицы.


```tsql

CREATE TYPE dbo.type_TableVar_EmployeeId
    AS TABLE  
    (
        EmployeeId   bigint   NOT NULL
    );
```


Затем используется тип создания таблицы.


```tsql
DECLARE @MyTableVarMo  dbo.type_TableVar_EmployeeId  

INSERT INTO @MyTableVarMo (EmployeeId)
    SELECT
            e.EmployeeId
        FROM
                 TabProjectEmployee  AS pe
            JOIN TabEmployee         AS e  ON e.EmployeeId = pe.EmployeeId
        WHERE
            e.EmployeeStatus = 'Left-the-Company'
;

DECLARE @EmployeeId   bigint;

WHILE (1=1)
BEGIN
    SET @EmployeeId = NULL;

    SELECT TOP 1 @EmployeeId = v.EmployeeId
        FROM @MyTableVarMo  AS v;

    IF (NULL = @Employeed) BREAK;
    
    DELETE TabProjectEmployee
        WHERE EmployeeId = @EmployeeId;

    DELETE @MyTableVarMo
        WHERE EmployeeId = @EmployeeId;
END;
```


### <a name="e4-query-plan-limitations-for-native-procs"></a>Д.4. Ограничения, связанные с планом запросов для скомпилированных в машинный код процедур


Некоторые типы планов запросов недоступны для скомпилированных в машинный код процедур. Многие подробности обсуждаются в следующей статье:

- [Руководство по обработке запросов для таблиц, оптимизированных для памяти](../../relational-databases/in-memory-oltp/a-guide-to-query-processing-for-memory-optimized-tables.md)


#### <a name="no-parallel-processing-in-a-native-proc"></a>В скомпилированных в машинный код процедурах отсутствует параллельная обработка

Параллельная обработка не может быть частью какого бы то ни было плана запросов для скомпилированной в машинный код процедуры. Скомпилированные в машинный код процедуры всегда однопоточны.


#### <a name="join-types"></a>Типы соединений


Ни хэш-соединение, ни соединение слиянием не может быть частью плана запросов для скомпилированной в машинный код процедуры. Используются соединения вложенных циклов.


#### <a name="no-hash-aggregation"></a>Агрегирование хэшей отсутствует

Если план запросов для скомпилированной в машинный код процедуры требует этапа агрегирования, доступно только агрегирование потоков. Хэш-агрегирование не поддерживается в плане запросов для скомпилированных в машинный код процедур.

- Хэш-агрегирование больше подходит для ситуаций, когда необходимо агрегировать данные из большого числа строк.



## <a name="f-application-design-transactions-and-retry-logic"></a>Е. Проектирование приложений: транзакции и логика повторных попыток

Транзакция, связанная с оптимизированной для обработки в памяти таблицей, может стать зависимой от другой транзакции, в которой используется та же таблица. Если число зависимых транзакций превысит допустимый максимум, все зависимые транзакции завершатся сбоем.

В SQL Server 2016:

- допустимый предел — 8 зависимых транзакций. 8 — это также предельное число транзакций, от которых может зависеть любая транзакция.
- Номер ошибки — 41839. (В SQL Server 2014 номер ошибки — 41301.)


Скрипты Transact-SQL можно сделать более устойчивыми к ошибкам, связанным с транзакциями, добавив в скрипты *логику повторных попыток* . Логика повторных попыток окажется полезной, если вызовы UPDATE и DELETE выполняются часто или если на оптимизированную для обработки в памяти таблицу ссылается внешний ключ другой таблицы. Подробная информация доступна в следующих статьях:

- [Transactions with Memory-Optimized Tables](../../relational-databases/in-memory-oltp/transactions-with-memory-optimized-tables.md)
- [Transaction dependency limits with memory optimized tables — Error 41839 (Ограничения, связанные с зависимостями транзакций в оптимизированных для обработки в памяти таблицах, — ошибка 41839)](https://blogs.msdn.microsoft.com/sqlcat/2016/07/11/transaction-dependency-limits-with-memory-optimized-tables-error-41839/)



## <a name="related-links"></a>Связанные ссылки

- [In-Memory OLTP (оптимизация в памяти)](../../relational-databases/in-memory-oltp/in-memory-oltp-in-memory-optimization.md)



