---
title: "Загрузка данных индексов ColumnStore | Microsoft Docs"
ms.custom: 
  - "SQL2016_New_Updated"
ms.date: "01/27/2017"
ms.prod: "sql-server-2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "database-engine"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: b29850b5-5530-498d-8298-c4d4a741cdaf
caps.latest.revision: 31
author: "barbkess"
ms.author: "barbkess"
manager: "jhubbard"
caps.handback.revision: 28
---
# Загрузка данных индексов ColumnStore
[!INCLUDE[tsql-appliesto-ss2012-all_md](../../includes/tsql-appliesto-ss2012-all-md.md)]

  Загрузите данные в индекс columnstore с помощью стандартных методов массовой загрузки и тонкой вставки SQL. К этим методам относятся bcp, службы Integration Services, а также инструкция merge или insert в Transact-SQL.  
  
 Незнакомы с индексами columnstore? Ознакомьтесь с терминами и понятиями в разделе [Руководство по индексам columnstore](../Topic/Columnstore%20Indexes%20Guide.md).  
  
 Требуется подробное обсуждение? См. [статью в блоге](http://blogs.msdn.com/b/sqlcat/archive/2015/03/11/data-loading-performance-considerations-on-tables-with-clustered-columnstore-index.aspx).  
  
##  <a name="dataload_cci"></a> Массовая загрузка в кластеризованный индекс columnstore  
 Для массовой загрузки строк в кластеризованный индекс columnstore можно использовать программу командной строки bcp, службы Integration Services либо выбрать строки в промежуточной таблице.  
  
 ![Загрузка в кластеризованный индекс columnstore](../../relational-databases/indexes/media/sql-server-pdw-columnstore-loadprocess.gif "Загрузка в кластеризованный индекс columnstore")  
  
 Как видно на диаграмме, массовая загрузка:  
  
1.  Не выполняет предварительную сортировку данных. Данные вставляются в группы строк в порядке их получения.  
  
2.  Если размер пакета > = 102 400, строки вставляются непосредственно в сжатые группы строк. Для обеспечения эффективного массового импорта рекомендуется выбирать размер пакета > = 102 400, поскольку можно избежать перемещения строк данных в разностные группы строк до того, как в конечном счете фоновый поток, а именно задача переноса кортежей (TM), выполнит перемещение строк в сжатые группы строк.  
  
3.  Если размер пакета < 102 400 или если количество оставшихся строк < 102 400, строки будут загружены в разностные группы строк.  
  
 При массовой загрузке в кластеризованный индекс columnstore можно выполнять следующие операции оптимизации.  
  
-   Параллельная загрузка: можно выполнять несколько параллельных сеансов массового импорта (bcp или bulk insert), каждый из которых будет загружать отдельный файл данных. В отличие от rowstore, TABLOCK задавать не нужно, так как каждый поток массового импорта будет загружать данные только в отдельные группы строк (сжатые или разностные) с монопольной блокировкой.   В случае применения аргумента TABLOCK для таблицы будет принудительно выполнена монопольная блокировка и импортировать данные в параллельном режиме будет невозможно.  
  
-   Оптимизация журнала: при загрузке данных в сжатую группу строк массовая загрузка будет протоколироваться в минимальном объеме. При загрузке данных в разностную группу строк с размером пакета < 102 400 никакого минимального протоколирования выполняться не будет.  
  
-   Оптимизация блокировки: при загрузке в сжатую группу строк требуется блокировка X на группе строк. Однако при массовой загрузке в разностную группу строк требуется блокировка X на группе строк, но SQL Server по-прежнему блокирует СТРАНИЦУ или ЭКСТЕНТ, так как блокировка X группы строк не является частью иерархии блокировки.  
  
 Если у вас есть один или несколько некластеризованных индексов, для самого индекса оптимизировать блокировку или ведение журнала невозможно, но оптимизация кластеризованного индекса columnstore, как описано выше, по-прежнему возможна.  
  
## Как работает deltastore  
 Кластеризованные индексы columnstore собирают до 1 048 576 строк в deltastore перед их сжатием в виде сжатой группы строк. Это повышает степень сжатия индекса columnstore. Если группа строк deltastore содержит 1 048 576 строк, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] отметит данную группу как закрытую. Фоновый процесс, называемый *перемещение кортежей*, находит каждую закрытую группу строк и сжимает ее в columnstore.  
  
 Для каждого кластеризованного индекса columnstore может быть несколько deltastore.  
  
-   Если deltastore блокировано, компонент [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] пытается получить блокировку на другом deltastore. Если доступных deltastore нет, компонент [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] создает новое deltastore.  
  
-   Для секционированной таблицы для каждой секции может быть несколько deltastore.  
  
 В следующих сценариях описано, когда загруженные строки перейдут непосредственно в columnstore, а когда — в deltastore.  
  
 В примере каждая rowgroup может иметь 102 400-1 048 576 строк на rowgroup. На практике, если не хватает памяти, максимальный размер группы строк может быть меньше 1 048 576 строк.  
  
|Строки для массовой загрузки|Строки, добавленные в сжатую группу строк|Строки, добавленные в разностную группу строк|  
|-----------------------|-------------------------------------------|--------------------------------------|  
|102,000|0|102,000|  
|145,000|145,000<br /><br /> Размер группы строк: 145 000.|0|  
|1,048,577|1 048 576<br /><br /> Размер группы строк: 1 048 576.|1|  
|2,252,152|2,252,152<br /><br /> Размер группы строк: 1 048 576, 1 048 576, 155 000.|0|  
  
 В следующем примере показаны результаты загрузки 1 048 577 строк в таблицу. Результаты показывают наличие одной СЖАТОЙ rowgroup в columnstore (в виде сжатых сегментов столбцов) и 1 строки в deltastore.  
  
```  
SELECT object_id, index_id, partition_number, row_group_id, delta_store_hobt_id, state state_desc, total_rows, deleted_rows, size_in_bytes   
FROM sys.dm_db_column_store_row_group_physical_stats  
```  
  
 ![Rowgroup and deltastore for a batch load](../../relational-databases/indexes/media/sql-server-pdw-columnstore-batchload.gif "Rowgroup and deltastore for a batch load")  
  
## Загрузка из промежуточной таблицы  
 Стандартным вариантом является загрузка данных в промежуточную таблицу, выполнение определенного преобразования и их загрузка в целевую таблицу с помощью следующей команды.  
  
```  
INSERT INTO <columnstore index>  SELECT <list of columns> FROM <Staging Table>  
  
```  
  
 Эта команда загружает данные в индекс columnstore примерно так же, как и с помощью инструкций BCP или Bulk Insert, но в виде одного пакета. Если количество строк в промежуточной таблице < 102 400, строки загружаются в разностную группу строк; в противном случае строки загружаются непосредственно в сжатую группу строк.  Основное ограничение заключалось в том, что эта операция INSERT была однопотоковой. Чтобы загрузить данные в параллельном режиме, можно создать несколько промежуточных таблиц или выполнить инструкцию INSERT/SELECT с неперекрывающимися диапазонами строк из промежуточной таблицы.  В SQL Server 2016 данное ограничение отсутствует. Команда, приведенная ниже, загружает данные из промежуточной таблицы в параллельном режиме, но необходимо задать TABLOCK.  
  
```  
INSERT INTO <columnstore index>  WITH (TABLOCK)  SELECT <list of columns> FROM <Staging Table>  
```  
  
 При загрузке в кластеризованный индекс columnstore из промежуточной таблицы можно выполнять следующие операции оптимизации.  
  
-   Оптимизация журнала: при загрузке данных в сжатую группу строк загрузка будет протоколироваться в минимальном объеме. При загрузке данных в разностную группу строк никакого минимального протоколирования выполняться не будет.  
  
-   Оптимизация блокировки: при загрузке в сжатую группу строк требуется блокировка X на группе строк. Однако для разностной группы строк требуется блокировка X на группе строк, но SQL Server по-прежнему блокирует СТРАНИЦУ или ЭКСТЕНТ, так как блокировка X группы строк не является частью иерархии блокировки.  
  
 Если у вас есть один или несколько некластеризованных индексов, для самого индекса оптимизировать блокировку или ведение журнала невозможно, но оптимизация кластеризованного индекса columnstore, как описано выше, по-прежнему возможна.  
  
## Загрузка с помощью тонкой вставки  
 *Тонкая вставка* представляет собой способ загрузки строк в columnstore с помощью инструкции INSERT INTO. Каждая строка добавляется в разностную группу строк. Добавляемые строки поступают непосредственно в группу строк deltastore, где происходит их накопление до тех пор, пока группа строк не будет закрыта при достижении 1 048 576 строк или пока не будет перестроен индекс columnstore.  
  
```  
INSERT INTO <table-name> VALUES (<set of values>)  
```  
  
 Следует отметить, что параллельные потоки, выполняемые с помощью инструкции INSERT INTO для вставки значений в кластеризованный индекс columnstore, могут вставлять строки в одну и ту же группу строк deltastore.  
  
 Как только в группе окажется 1 048 576 строк, разностная группа строк будет отмечена как закрытая, но она по-прежнему будет доступна для запросов и операций обновления или удаления, хотя новые вставленные строки будут добавляться в существующую или новую группу строк deltastore. Существует фоновый поток, называемый *задачей переноса кортежей (TM)*, который периодически сжимает закрытые разностные группы строк примерно через каждые 5 минут. Для сжатия закрытой разностной группы строк можно явным образом вызвать следующую команду.  
  
```  
ALTER INDEX <index-name> on <table-name> REORGANIZE  
```  
  
 Если необходимо принудительно закрыть и сжать разностную группу строк, можно выполнить следующую команду. Выполнение этой команды может потребоваться, если вы загрузили строки и никакие новые строки не нужны. Благодаря явному закрытию и сжатию разностной группы строк можно экономить место в хранилище и повышать производительность аналитических запросов. Эту команду рекомендуется использовать, если вставка новых строк не нужна.  
  
```  
ALTER INDEX <index-name> on <table-name> REORGANIZE with (COMPRESS_ALL_ROW_GROUPS = ON)  
```  
  
## Загрузка в секционированную таблицу  
 Для секционированных данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] сначала назначает каждую строку секции, а затем выполняет операции columnstore для данных в секции. Каждая секция имеет собственную rowgroups и как минимум одно deltastore.  
  
## Загрузка в некластеризованный индекс columnstore  
 В таблице rowstore с данными некластеризованного индекса columnstore [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] всегда вставляет данные в базовую таблицу. Данные никогда не вставляются непосредственно в индекс columnstore.  
  
## См. также:  
 [Руководство по индексам columnstore](../Topic/Columnstore%20Indexes%20Guide.md)   
 [Сводка функций индексов columnstore по версиям](../Topic/Columnstore%20Indexes%20Versioned%20Feature%20Summary.md)   
 [Производительность запросов индексов columnstore](../../relational-databases/indexes/columnstore-indexes-query-performance.md)   
 [Начало работы с Columnstore для получения операционной аналитики в реальном времени](../../relational-databases/indexes/get-started-with-columnstore-for-real-time-operational-analytics.md)   
 [Индексы сolumnstore для хранилищ данных](../Topic/Columnstore%20Indexes%20for%20Data%20Warehousing.md)   
 [Дефрагментация индексов columnstore](../../relational-databases/indexes/columnstore-indexes-defragmentation.md)  
  
  