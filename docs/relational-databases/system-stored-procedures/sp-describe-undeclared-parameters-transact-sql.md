---
title: sp_describe_undeclared_parameters (Transact-SQL) | Документы Microsoft
ms.custom: ''
ms.date: 03/14/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.service: ''
ms.component: system-stored-procedures
ms.reviewer: ''
ms.suite: sql
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: language-reference
f1_keywords:
- sp_describe_undeclared_parameters
- sp_describe_undeclared_parameters_TSQL
dev_langs:
- TSQL
helpviewer_keywords:
- sp_describe_undeclared_parameters
ms.assetid: 6f016da6-dfee-4228-8b0d-7cd8e7d5a354
caps.latest.revision: 22
author: edmacauley
ms.author: edmaca
manager: craigg
ms.workload: Inactive
monikerRange: = azuresqldb-current || >= sql-server-2016 || = sqlallproducts-allversions
ms.openlocfilehash: 55becb87f41fdc54aa4e618dc5be80d5292b1ea3
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="spdescribeundeclaredparameters-transact-sql"></a>sp_describe_undeclared_parameters (Transact-SQL)
[!INCLUDE[tsql-appliesto-ss2012-asdb-xxxx-xxx-md](../../includes/tsql-appliesto-ss2012-asdb-xxxx-xxx-md.md)]

  Возвращает результирующий набор, который содержит метаданные о необъявленных параметрах в [!INCLUDE[tsql](../../includes/tsql-md.md)] пакета. Учитывается каждый параметр, который используется в **@tsql** пакета, но не объявлены в **@params**. Возвращается результирующий набор, содержащий одну строку для каждого такого параметра со сведениями о предполагаемом типе параметра. Процедура возвращает пустой результирующий набор, если **@tsql** входном пакете не имеет параметров, кроме объявленных в **@params**.  
  
 ![Значок ссылки на раздел](../../database-engine/configure-windows/media/topic-link.gif "Значок ссылки на раздел") [Синтаксические обозначения в Transact-SQL](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="syntax"></a>Синтаксис  
  
```  
  
sp_describe_undeclared_parameters   
    [ @tsql = ] 'Transact-SQL_batch'   
    [ , [ @params = ] N'parameters' data type ] [, ...n]  
```  
  
## <a name="arguments"></a>Аргументы  
 [  **@tsql =** ] **"***Transact SQL_batch***"**  
 Одна или несколько инструкций [!INCLUDE[tsql](../../includes/tsql-md.md)]. *Transact SQL_batch* может быть **nvarchar (***n***)** или **nvarchar(max)**.  
  
 [  **@params =** ] **N'***параметры***"**  
 @params обеспечивает строку объявления параметров для [!INCLUDE[tsql](../../includes/tsql-md.md)] работает пакет, как и в хранимой процедуре sp_executesql. *Параметры* может быть **nvarchar (***n***)** или **nvarchar(max)**.  
  
 Строка, содержащая определения всех параметров, внедренных в *Transact SQL_batch*. Строка должна представлять собой константу в Юникоде либо переменную в этом же формате. Определение каждого параметра состоит из имени параметра и типа данных. n — заполнитель, указывающий дополнительные определения параметра. Если выполнение инструкции Transact-SQL или пакета в инструкции не содержит параметров, @params не требуется. Этот аргумент по умолчанию принимает значение NULL.  
  
 Datatype  
 Тип данных параметра.  
  
## <a name="return-code-values"></a>Значения кода возврата  
 **sp_describe_undeclared_parameters** всегда возвращает состояние 0 в случае успешного выполнения. Если процедура вызывает ошибку и процедура вызывается через RPC, возвращаемое состояние заполняется тип ошибки, как описано в столбце error_type sys.dm_exec_describe_first_result_set. Если процедура вызывается из [!INCLUDE[tsql](../../includes/tsql-md.md)], возвращаемое значение всегда равно нулю, даже при наличии ошибок.  
  
## <a name="result-sets"></a>Результирующие наборы  
 **sp_describe_undeclared_parameters** возвращает следующий результирующий набор.  
  
|Имя столбца|Тип данных|Описание|  
|-----------------|---------------|-----------------|  
|**parameter_ordinal**|**int NOT NULL**|Содержит порядковый номер параметра в результирующем наборе. Позиция первого параметра будет указана как 1.|  
|**name**|**sysname NOT NULL**|Содержит имя параметра.|  
|**suggested_system_type_id**|**int NOT NULL**|Содержит **system_type_id** типа данных параметра, как указано в sys.types.<br /><br /> Для типов CLR даже если **system_type_name** столбец возвратит NULL, этот столбец вернет значение 240.|  
|**suggested_system_type_name**|**nvarchar (256) значение NULL**|Содержит имя типа данных. Включает аргументы (длина, точность, масштаб), заданные для типа данных параметра. Если тип данных является пользовательским псевдонимом, то здесь указывается базовый системный тип данных. Если это определяемый пользователем тип данных CLR, то в этом столбце возвращается значение NULL. Если не удается определить тип параметра, возвращается значение NULL.|  
|**suggested_max_length**|**Smallint, не NULL**|В разделе sys.columns. для **max_length** описание столбца.|  
|**suggested_precision**|**tinyint NOT NULL**|В разделе sys.columns. содержащий описание столбца precision.|  
|**suggested_scale**|**tinyint NOT NULL**|В разделе sys.columns. содержащий описание столбца scale.|  
|**suggested_user_type_id**|**int NULL**|Для типов CLR и псевдонимов содержит user_type_id для типа данных столбца, как указано в sys.types. В противном случае значение равно NULL.|  
|**suggested_user_type_database**|**sysname NULL**|Для типов CLR и псевдонимов содержит имя базы данных, в которой этот тип определен. В противном случае значение равно NULL.|  
|**suggested_user_type_schema**|**sysname NULL**|Для типов CLR и псевдонимов содержит имя схемы, в которой этот тип определен. В противном случае значение равно NULL.|  
|**suggested_user_type_name**|**sysname NULL**|Для типов CLR и псевдонимов содержит имя типа. В противном случае значение равно NULL.|  
|**suggested_assembly_qualified_type_name**|**nvarchar (4000) значение NULL**|Для типов CLR возвращает имя сборки и класса, определяющего тип. В противном случае значение равно NULL.|  
|**suggested_xml_collection_id**|**int NULL**|Содержит xml_collection_id для типа данных параметра, как указано в sys.columns. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_database**|**sysname NULL**|Содержит базу данных, в которой определена коллекция схем XML, связанная с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_schema**|**sysname NULL**|Содержит схему, в которой определена коллекция схем XML, связанная с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_xml_collection_name**|**sysname NULL**|Содержит имя коллекции схем XML, связанной с этим типом. Этот столбец возвратит NULL, если возвращаемый тип не связан с коллекцией схем XML.|  
|**suggested_is_xml_document**|**бит NOT NULL**|Возвращает значение 1, если возвращается тип XML и этот тип гарантированно представляет собой XML-документ. В противном случае возвращается 0.|  
|**suggested_is_case_sensitive**|**бит NOT NULL**|Возвращает значение 1, если столбец относится к строковому типу с учетом регистра, либо значение 0 в противном случае.|  
|**suggested_is_fixed_length_clr_type**|**бит NOT NULL**|Возвращает значение 1, если столбец относится к типу CLR с фиксированной длиной, либо значение 0 в противном случае.|  
|**suggested_is_input**|**бит NOT NULL**|Возвращает значение 1, если параметр используется за пределами левой стороны присваивания. В противном случае возвращается 0.|  
|**suggested_is_output**|**бит NOT NULL**|Возвращает значение 1, если параметр используется в левой стороне присваивания или передается в выходной параметр хранимой процедуры. В противном случае возвращается 0.|  
|**formal_parameter_name**|**sysname NULL**|Если параметр служит аргументом хранимой процедуры или определяемой пользователем функции, здесь возвращается имя соответствующего формального параметра. В противном случае возвращается NULL.|  
|**suggested_tds_type_id**|**int NOT NULL**|Для внутреннего использования.|  
|**suggested_tds_length**|**int NOT NULL**|Для внутреннего использования.|  
  
## <a name="remarks"></a>Замечания  
 **sp_describe_undeclared_parameters** всегда возвращает состояние 0.  
  
 Чаще всего она применяется, когда приложению передается инструкция [!INCLUDE[tsql](../../includes/tsql-md.md)], которая может содержать параметры и должна некоторым образом их обрабатывать. Например, пользовательский интерфейс (например, ODBCTest или RowsetViewer), где пользователь передает запрос с синтаксисом параметров ODBC. Приложение должно динамически обнаруживать число параметров и запрашивать каждый параметр у пользователя.  
  
 Другим примером служит ситуация, где пользователь не вводит данные, а приложение должно просматривать параметры и получать для них данные из другого расположения (из таблицы и т. п.) В этом случае приложение не должно сразу передавать сведения обо всех параметрах. Вместо этого приложение может получить сведения обо всех параметрах от поставщика, а сами данные получить из таблицы. Код с использованием **sp_describe_undeclared_parameters** , более универсален и менее вероятно, потребует изменения в случае изменения структуры данных.  
  
 **sp_describe_undeclared_parameters** возвращает сообщение об ошибке в любом из следующих случаев.  
  
-   Если входные данные @tsql не является допустимым [!INCLUDE[tsql](../../includes/tsql-md.md)] пакета. Действия определяется синтаксического разбора и анализа [!INCLUDE[tsql](../../includes/tsql-md.md)] пакета. Все ошибки, вызванных пакетом во время оптимизации запроса или во время выполнения не учитываются при определении ли [!INCLUDE[tsql](../../includes/tsql-md.md)] пакета является допустимым.  
  
-   Если @params не равно NULL и содержит строку, не является синтаксически правильной строкой объявления для параметров, или если она содержит строку, в котором объявлен какого-либо параметра более одного раза.  
  
-   Если входные данные [!INCLUDE[tsql](../../includes/tsql-md.md)] пакет объявляет локальную переменную с тем же именем, как параметр, объявленный в @params.  
  
-   Если инструкция создает временные таблицы.  
  
 Если @tsql не имеет параметров, не объявленных в @params, процедура возвращает пустой результирующий набор.  
  
## <a name="parameter-selection-algorithm"></a>Алгоритм выбора параметров  
 Для запроса с необъявленными параметрами выполняется процесс определения типов данных необъявленных параметров, состоящий из трех шагов.  
  
 **Шаг 1**  
  
 Первым шагом определения типов данных для запроса с необъявленными параметрами является поиск типов данных для всех вложенных выражений, типы данных которых не зависят от необъявленных параметров. Тип можно определить для следующих выражений:  
  
-   столбцы, константы, переменные и объявленные параметры;  
  
-   результаты вызова определяемой пользователем функции;  
  
-   выражение с типами данных, не зависящими от необъявленных параметров для всех входов.  
  
 В качестве примера рассмотрим запрос `SELECT dbo.tbl(@p1) + c1 FROM t1 WHERE c2 = @p2 + 2`. Выражения dbo.tbl (@p1) + c1 и c2 имеют типы данных и выражение @p1 и @p2 + 2 — нет.  
  
 Если после этого шага любое выражение (кроме вызова определяемой пользователем функции) содержит два аргумента без типов данных, то определение типов завершается с ошибкой. Например, все следующие инструкции вызывают ошибки:  
  
```  
SELECT * FROM t1 WHERE @p1 = @p2  
SELECT * FROM t1 WHERE c1 = @p1 + @p2  
SELECT * FROM t1 WHERE @p1 = SUBSTRING(@p2, 2, 3)  
```  
  
 В следующем примере не вызывается ошибка:  
  
```  
SELECT * FROM t1 WHERE @p1 = dbo.tbl(c1, @p2, @p3)  
```  
  
 **Шаг 2**  
  
 Для заданного необъявленного параметра @p, то алгоритм определения типов обнаруживает внутреннее выражение E (@p), содержащий @p и является одним из следующих:  
  
-   аргументом оператора сравнения или присваивания;  
  
-   аргументом определяемой пользователем функции (в том числе определяемой пользователем функции, возвращающей табличное значение), процедуры или метода;  
  
-   Аргумент для **значения** предложения **вставить** инструкции.  
  
-   Аргумент для **ПРИВЕДЕНИЯ** или **преобразовать**.  
  
 Алгоритм определения типов находит целевой тип данных TT (@p) для вставки (@p). Далее показаны целевые типы данных для предыдущих примеров:  
  
-   тип данных на другой стороне сравнения или присваивания;  
  
-   объявленный тип данных параметра, в который передается этот аргумент;  
  
-   тип данных столбца, в который вставляется это значение;  
  
-   тип данных, к которому приводится или преобразуется инструкция.  
  
 В качестве примера рассмотрим запрос `SELECT * FROM t WHERE @p1 = dbo.tbl(@p2 + c1)`. Затем E (@p1) = @p1, E (@p2) = @p2 + c1, TT (@p1) является типом объявленного возвращаемых данных dbo.tbl и TT (@p2) является объявленным типом данных параметра для dbo.tbl.  
  
 Если @p не содержится в одном выражении, указанном в начале шага 2, алгоритм определения типов определяет, E (@p) является самым большим скалярным выражением, которое содержит @p, и не поддерживает алгоритм определения типов целевой тип данных TT вычислений (@p) для вставки (@p). Например, если запрос SELECT `@p + 2` затем E (@p) = @p + 2, и не TT (@p).  
  
 **Шаг 3**  
  
 Теперь, E (@p) и TT (@p), определения, алгоритм определения типов определяет тип данных для @p в одном из следующих двух способов:  
  
-   Простое определение  
  
     Если E (@p) = @p и TT (@p) существует, т. е. Если @p прямо аргументом одного из выражений, указанных в начале шага 2, то алгоритм определения типов определяет тип данных имеет @p быть TT (@p). Например:  
  
    ```  
    SELECT * FROM t WHERE c1 = @p1 AND @p2 = dbo.tbl(@p3)  
    ```  
  
     Тип данных для @p1, @p2, и @p3 будет иметь тип данных c1, тип возвращаемых данных dbo.tbl и тип данных параметра для dbo.tbl соответственно.  
  
     В особом случае если @p является аргументом для \<, >, \<= или > =-оператор простое определение правила не применяются. Алгоритм определения типов будет использовать общие правила определения, описанные в следующем разделе. Например, если столбец c1 имеет тип данных char(30), рассмотрим следующие два запроса:  
  
    ```  
    SELECT * FROM t WHERE c1 = @p  
    SELECT * FROM t WHERE c1 > @p  
    ```  
  
     В первом случае алгоритм определения типов определяет **char(30)** как тип данных для @p согласно правилам ранее в этом разделе. Во втором случае алгоритм определения типов определяет **varchar(8000)** согласно правилам общее определение в следующем разделе.  
  
-   Общее определение  
  
     Если простое определение не действует, то для необъявленных параметров рассматриваются следующие типы данных.  
  
    -   Целочисленные типы данных (**бит**, **tinyint**, **smallint**, **int**, **bigint**)  
  
    -   Типы данных (**smallmoney**, **money**)  
  
    -   Типы данных с плавающей запятой (**float**, **реальные**)  
  
    -   **Числовой (38, 19)** -другие типы данных numeric или decimal не учитываются.  
  
    -   **varchar(8000)**, **varchar(max)**, **nvarchar(4000)**, и **nvarchar(max)** - другие строковые типы данных (такие как **текст**, **char(8000)**, **nvarchar(30)**, т. д.) не учитываются.  
  
    -   **varbinary(8000)** и **varbinary(max)** -другие двоичные типы данных не учитываются (например, **изображения**, **binary(8000)**, **varbinary (30)** и т. д.).  
  
    -   **Дата**, **time(7)**, **smalldatetime**, **datetime**, **datetime2(7)**, **datetimeoffset(7)**  — Другие типы даты и времени, таких как **time(4)**, не учитываются.  
  
    -   **sql_variant**  
  
    -   **xml**  
  
    -   Системные типы CLR (**hierarchyid**, **geometry**, **geography**)  
  
    -   Определяемые пользователем типы CLR  
  
### <a name="selection-criteria"></a>Условия выбора  
 Любой тип данных-кандидат, который нарушает допустимость запроса, отклоняется. Из оставшихся кандидатов алгоритм определения типов выбирает один тип данных по следующим правилам.  
  
1.  Тип данных, который создает наименьшее количество неявных преобразований в E (@p) установлен. Если определенный тип данных создает тип данных для вставки (@p), отличается от TT (@p), алгоритм определения типов считает это дополнительным неявным преобразованием из типа данных E (@p) для TT (@p).  
  
     Например:  
  
    ```  
    SELECT * FROM t WHERE Col_Int = Col_Int + @p  
    ```  
  
     В этом случае E (@p) имеет тип Col_Int + @p и TT (@p) является **int**. **int** выбирается для @p , так как он не требует неявных преобразований. Любой другой выбор типа данных требует не меньше одного неявного преобразования.  
  
2.  Если несколько типов данных имеют минимальное число преобразований, то используется тип данных с максимальным приоритетом. Например.  
  
    ```  
    SELECT * FROM t WHERE Col_Int = Col_smallint + @p  
    ```  
  
     В этом случае **int** и **smallint** требуется одно преобразование. Для любого другого типа данных требуется несколько преобразований. Поскольку **int** имеет приоритет над **smallint**, **int** используется для @p. Дополнительные сведения о приоритете типов данных см. в разделе [очередности типов данных &#40;Transact-SQL&#41;](../../t-sql/data-types/data-type-precedence-transact-sql.md).  
  
     Это правило применяется, только если существует неявное преобразование между каждым из типов, равнозначных по правилу 1, и типом данных с максимальным приоритетом. Если неявное преобразование отсутствует, то определение типа данных завершается с ошибкой. Например, в запросе `SELECT @p FROM t`, тип данных выведение завершается ошибкой, так как любой тип данных для @p бы хорошо. Например, нет неявного преобразования из **int** для **xml**.  
  
3.  Если два схожих типа данных перегрузки по правилу 1, например **varchar(8000)** и **varchar(max)**, тем меньше данных типа (**varchar(8000)**) выбирается. Тот же принцип применяется к **nvarchar** и **varbinary** типов данных.  
  
4.  В рамках правила 1 алгоритм определения типов используют различные приоритеты преобразований. Далее показаны преобразования в порядке убывания приоритета.  
  
    1.  Преобразование между типами с одним базовым типом, имеющими разную длину.  
  
    2.  Преобразование между версии те же типы данных фиксированной и переменной длины (например, **char** для **varchar**).  
  
    3.  Преобразование между **NULL** и **int**.  
  
    4.  Все прочие преобразования.  
  
 Например, для запроса `SELECT * FROM t WHERE [Col_varchar(30)] > @p`, **varchar(8000)** выбирается, поскольку преобразование первого класса лучше всего подходит. Для запроса `SELECT * FROM t WHERE [Col_char(30)] > @p`, **varchar(8000)** по-прежнему выбран, поскольку она вызывает преобразование типа (b), а другой вариант (такие как **varchar(4000)**) используется для перевода преобразования типов (d).  
  
 В последнем примере данным запросом `SELECT NULL + @p`, **int** выбирается для @p за счет преобразования типов (c).  
  
## <a name="permissions"></a>Разрешения  
 Требуется разрешение на выполнение @tsql аргумент.  
  
## <a name="examples"></a>Примеры  
 В следующем примере возвращаются такие данные, как ожидаемый тип данных для необъявленных параметров `@id` и `@name`.  
  
```  
sp_describe_undeclared_parameters @tsql =   
N'SELECT object_id, name, type_desc   
FROM sys.indexes  
WHERE object_id = @id OR name = @name'  
  
```  
  
 Если параметр `@id` передается по ссылке `@params`, то параметр `@id` исключается из результирующего набора и описывается только параметр `@name`.  
  
```  
sp_describe_undeclared_parameters @tsql =   
N'SELECT object_id, name, type_desc   
FROM sys.indexes  
WHERE object_id = @id OR NAME = @name',  
@params = N'@id int'  
  
```  
  
## <a name="see-also"></a>См. также  
 [sp_describe_first_result_set &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-describe-first-result-set-transact-sql.md)   
 [sys.dm_exec_describe_first_result_set &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-exec-describe-first-result-set-transact-sql.md)   
 [sys.dm_exec_describe_first_result_set_for_object &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-exec-describe-first-result-set-for-object-transact-sql.md)  
  
  
