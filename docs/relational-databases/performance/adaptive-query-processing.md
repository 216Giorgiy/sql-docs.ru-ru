---
title: Адаптивная обработка запросов в базах данных Microsoft SQL | Документация Майкрософт | Документация Майкрософт
description: Функции адаптивной обработки запросов для улучшения производительности запросов в SQL Server (2017 и более поздних версиях) и базе данных SQL Azure.
ms.custom: ''
ms.date: 11/13/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.service: ''
ms.component: performance
ms.reviewer: ''
ms.suite: sql
ms.technology: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords: ''
ms.assetid: ''
author: joesackmsft
ms.author: josack
manager: craigg
ms.workload: On Demand
monikerRange: = azuresqldb-current || >= sql-server-2016 || = sqlallproducts-allversions
ms.openlocfilehash: b3d872beef925cd7e49387b231adcea401b4c4b3
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="adaptive-query-processing-in-sql-databases"></a>Адаптивная обработка запросов в базах данных SQL
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]

Эта статья описывает функции адаптивной обработки запросов, позволяющие улучшить производительность запросов в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] (начиная с [!INCLUDE[ssSQL17](../../includes/sssql17-md.md)]) и [!INCLUDE[ssSDS](../../includes/sssds-md.md)]:
- Обратная связь по временно предоставляемому буферу памяти в пакетном режиме.
- Адаптивное соединение в пакетном режиме.
- Выполнение с чередованием. 

На общем уровне SQL Server выполняет запрос следующим образом:
1. Процесс оптимизации запросов создает набор осуществимых планов выполнения для конкретного запроса. При этом оценивается стоимость вариантов планов и используется план с самой низкой предполагаемой стоимостью.
1. Процесс выполнения запросов принимает план, выбранный оптимизатором запросов, и использует его для выполнения.
    
Иногда план, выбранный оптимизатором запросов, по ряду причин отличается от оптимального. Например, предполагаемое количество строк, передаваемых через план запроса, может оказаться неправильным. Оценка затрат помогает определить, какой план выбирается для выполнения. Если оценки кратности неправильны, по-прежнему используется исходный план, несмотря на неточные первоначальные предположения.

![Функции адаптивной обработки запросов](./media/1_AQPFeatures.png)

### <a name="how-to-enable-adaptive-query-processing"></a>Включение адаптивной обработки запросов
Рабочие нагрузки можно автоматически сделать соответствующими для адаптивной обработки запросов, включив для базы данных уровень совместимости 140.  Это можно сделать с помощью Transact-SQL. Пример:  

```sql
ALTER DATABASE [WideWorldImportersDW] SET COMPATIBILITY_LEVEL = 140;
```

## <a name="batch-mode-memory-grant-feedback"></a>Обратная связь по временно предоставляемому буферу памяти в пакетном режиме
План после выполнения запроса в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] включает минимальный объем памяти, необходимый для выполнения, а также оптимальный временно предоставляемый буфер памяти, позволяющий уместить в памяти все строки. Если размер временно предоставляемого буфера памяти выбран неправильно, производительность снижается. Избыточные буферы ведут к потере памяти и снижению параллелизма. Недостаточные буферы ведут к затратной временной записи на диск. Обратная связь по временно предоставляемому буферу памяти в пакетном режиме, ориентированная на повторяющиеся рабочие процессы, пересчитывает фактическую требуемую память для запроса и затем обновляет значение временного буфера для кэшированного плана.  При выполнении идентичной инструкции запроса используется пересмотренный размер временно предоставляемого буфера памяти, который уменьшает чрезмерные буферы, снижающие параллелизм, исправляет недостаточные буферы, вызывающие затратную временную запись на диск.
На следующем графе показан пример использования обратной связи по временно предоставляемому буферу памяти в пакетном режиме. Длительность первого выполнения запроса составила **88 секунд** из-за высокого уровня временной записи на диск.   

```sql
DECLARE @EndTime datetime = '2016-09-22 00:00:00.000';
DECLARE @StartTime datetime = '2016-09-15 00:00:00.000';
SELECT TOP 10 hash_unique_bigint_id
FROM dbo.TelemetryDS
WHERE Timestamp BETWEEN @StartTime and @EndTime
GROUP BY hash_unique_bigint_id
ORDER BY MAX(max_elapsed_time_microsec) DESC;
```

![Высокий уровень временной записи на диск](./media/2_AQPGraphHighSpills.png)

С включенной обратной связью по временно предоставляемому буферу памяти длительность второго выполнения составила **1 секунду** (ранее 88 секунд), при этом временная запись на диск полностью устранена, а временный буфер увеличен. 

![Временная запись на диск отсутствует.](./media/3_AQPGraphNoSpills.png)

### <a name="memory-grant-feedback-sizing"></a>Определение размера с помощью обратной связи по временно предоставляемому буферу памяти
Для чрезмерных временно предоставляемых буферов памяти, когда предоставленный объем памяти больше чем в два раза превышает объем фактической используемой памяти, функция обратной связи пересчитывает временно предоставляемый буфер памяти и обновляет кэшированный план. Для планов, у которых размер временно предоставляемого буфера памяти меньше 1 МБ, пересчет по превышению не выполняется.
Для недостаточных временно предоставляемых буферов памяти, которые приводят к временной записи на диск для операторов пакетного режима, обратная связь по временно предоставляемому буферу памяти активирует пересчет буфера. События временной записи передаются в функцию обратной связи и могут быть предоставлены с помощью события XEvent *spilling_report_to_memory_grant_feedback*. Они возвращает идентификатор узла из плана, а также объем временно записанных данных для этого узла.

### <a name="memory-grant-feedback-and-parameter-sensitive-scenarios"></a>Обратная связь по временно предоставляемому буферу памяти и сценарии, зависящие от параметров
Для сохранения оптимальности различным значениям параметров могут также потребоваться разные планы запроса. Такой тип запроса называется "зависящим от параметров". Для планов, зависящих от параметров, функция обратной связи по временно предоставляемому буферу памяти отключается для запроса, имеющего нестабильные требования к памяти. После нескольких повторных выполнений запроса план отключается, что можно наблюдать, отслеживая событие XEvent *memory_grant_feedback_loop_disabled*. Дополнительные сведения о сканировании и чувствительности параметров см. в разделе [Руководство по архитектуре обработки запросов](../../relational-databases/query-processing-architecture-guide.md#ParamSniffing).

### <a name="memory-grant-feedback-caching"></a>Кэширование обратной связи по временно предоставляемому буферу памяти
Обратную связь можно хранить в кэшированном плане для однократного выполнения. Но именно последовательные выполнения этой инструкции позволяют использовать преимущества корректировки обратной связи по временно предоставляемому буферу памяти. Эта функция применяется к повторному выполнению инструкций. Обратная связь по временно предоставляемому буферу памяти изменяет только кэшированный план. Изменения сейчас не сохраняются в хранилище запросов.
Обратная связь не сохраняется, если план исключается из кэша. Кроме того, в случае перехода на другой ресурс обратная связь будет утеряна. Инструкция, использующая `OPTION (RECOMPILE)`, создает план и не кэширует его. Из-за отсутствия кэширования обратная связь по временно предоставляемому буферу памяти не создается, а план не сохраняется для компиляции и выполнения.  Но если эквивалентная инструкция (т. е. с тем же хэшем запроса), **не** использовавшая `OPTION (RECOMPILE)`, была кэширована и затем повторно выполнена, последующая инструкция может использовать преимущества обратной связи по временно предоставляемому буферу памяти.

### <a name="tracking-memory-grant-feedback-activity"></a>Отслеживание операций обратной связи по временно предоставляемому буферу памяти
Вы можете отслеживать события обратной связи по временно предоставляемому буферу памяти с помощью события xEvent *memory_grant_updated_by_feedback*. Оно отслеживает текущий журнал подсчета выполнений, количество изменений плана функцией обратной связи, оптимальный дополнительный временно предоставляемый буфер памяти перед изменением и оптимальный буфер после изменения кэшированного плана функцией обратной связи.

### <a name="memory-grant-feedback-resource-governor-and-query-hints"></a>Обратная связь по временно предоставляемому буферу памяти, регулятор ресурсов и указания запроса
Фактический объем предоставляемой памяти учитывает лимит памяти запросов, определяемый регулятором ресурсов или указанием запроса.

## <a name="batch-mode-adaptive-joins"></a>Адаптивные соединения в пакетном режиме
Функция адаптивных соединений в пакетном режиме позволяет отложить выбор метода [хэш-соединения или соединения вложенными циклами](../../relational-databases/performance/joins.md) **до** завершения сканирования первых входных данных. Оператор адаптивного соединения определяет пороговое значение, по которому принимается решение о переключении на план вложенного цикла. Таким образом, во время выполнения план может динамически переключаться на более эффективную стратегию соединения.
Это работает следующим образом:
-  Если число строк во входных данных соединения сборки настолько мало, что соединение вложенными циклами будет эффективнее хэш-соединения, ваш план переключается на алгоритм вложенных циклов.
-  Если число строк во входных данных соединения сборки превышает пороговое значение, переключение не выполняется и план продолжает использовать хэш-соединение.

Следующий запрос используется в качестве наглядного примера адаптивного соединения:

```sql
SELECT  [fo].[Order Key], [si].[Lead Time Days],
[fo].[Quantity]
FROM [Fact].[Order] AS [fo]
INNER JOIN [Dimension].[Stock Item] AS [si]
       ON [fo].[Stock Item Key] = [si].[Stock Item Key]
WHERE [fo].[Quantity] = 360;
```

Этот запрос возвращает 336 строк. Включив [статистику активных запросов](../../relational-databases/performance/live-query-statistics.MD), мы видим следующий план:

![Результат запроса: 336 строк](./media/4_AQPStats336Rows.png)

В плане мы видим следующее:
1. Просмотр индекса columnstore, используемый для предоставления строк для этапа сборки хэш-соединения.
1. Новый оператор адаптивного соединения. Он определяет пороговое значение, по которому принимается решение о переключении на план вложенного цикла. В нашем примере пороговое значение равно 78 строкам. Если число строк &gt; = 78, будет использоваться хэш-соединение. При значении меньше порогового будет использоваться соединение вложенными циклами.
1. Так как мы возвращаем 336 строк, пороговое значение превышено, и поэтому вторая ветвь представляет пробный этап стандартной операции хэш-соединения. Обратите внимание, что статистика активных запросов показывает строки, передаваемые через операторы — в данном случае это "672 из 672".
1. И последней ветвью является поиск кластеризованного индекса, используемый соединением вложенными циклами в случае, если пороговое значение не было превышено. Обратите внимание, что мы видим число строк "0 из 336" (ветвь не используется).
 Теперь давайте сравним план с таким же запросом, но на этот раз для значения *Quantity*, имеющего всего одну строку в таблице:
 
```sql
SELECT  [fo].[Order Key], [si].[Lead Time Days],
[fo].[Quantity]
FROM [Fact].[Order] AS [fo]
INNER JOIN [Dimension].[Stock Item] AS [si]
       ON [fo].[Stock Item Key] = [si].[Stock Item Key]
WHERE [fo].[Quantity] = 361;
```
Запрос возвращает одну строку. Включив статистику активных запросов, мы видим следующий план:

![Результатом запроса является одна строка.](./media/5_AQPStatsOneRow.png)

В плане мы видим следующее:
- При возврате одной строки видно, что теперь через поиск кластеризованного индекса передаются строки.
- А так как этап сборки хэш-соединения не продолжается, никакие строки через вторую ветвь не передаются.

### <a name="adaptive-join-benefits"></a>Преимущества адаптивных соединений
Наиболее полезной эта функция будет для рабочих нагрузок с частыми переключениями между просмотрами входных данных мелких и крупных соединений.

### <a name="adaptive-join-overhead"></a>Издержки адаптивных соединений
Адаптивные соединения предъявляют более высокие требования к памяти, чем эквивалентный план соединения вложенными циклами индекса. Дополнительная память запрашивается так, как если бы вложенный цикл был хэш-соединением. Существуют также издержки на этапе сборки, такие как стартстопная операция и эквивалентное потоковое соединение вложенными циклами. Эти дополнительные затраты обеспечивают гибкость для сценариев, где количество строк во входных данных сборки может меняться.

### <a name="adaptive-join-caching-and-re-use"></a>Кэширование и повторное использование адаптивных соединений
Адаптивные соединения в пакетном режиме используются для первого выполнения инструкции, а после компиляции последовательные выполнения остаются адаптивными с учетом порога скомпилированных адаптивных соединений и строк времени выполнения, передаваемых через этап сборки внешних входных данных.

### <a name="tracking-adaptive-join-activity"></a>Отслеживание операций адаптивного соединения
Оператор адаптивного соединения имеет следующие атрибуты оператора плана:

| Атрибут плана | Description |
|--- |--- |
| AdaptiveThresholdRows | Показывает пороговое значение, используемое для переключения с хэш-соединения на соединение вложенными циклами. |
| EstimatedJoinType | К какому типу, вероятнее всего, относится соединение. |
| ActualJoinType | В фактическом плане показывает, какой итоговый алгоритм соединения был выбран на базе порогового значения. |

Предполагаемый план показывает форму плана адаптивного соединения, а также определенное пороговое значение адаптивного соединения и предполагаемый тип соединения.

### <a name="adaptive-join-and-query-store-interoperability"></a>Взаимодействие адаптивного соединения и хранилища запросов
Хранилище запросов захватывает и может принудительно применить план адаптивного соединения в пакетном режиме.

### <a name="adaptive-join-eligible-statements"></a>Допустимые инструкции адаптивного соединения
Чтобы логическое соединение стало допустимым для адаптивного соединения в пакетном режиме, должны выполняться следующие условия:
- Уровень совместимости базы данных равен 140.
- Запрос является инструкцией SELECT (инструкции для изменения данных сейчас недопустимы).
- Соединение может выполняться посредством как индексированного соединения вложенными циклами, так и физического алгоритма хэш-соединения.
- Хэш-соединение использует пакетный режим — либо в результате присутствия индекса columnstore во всем запросе в целом, либо из-за того, что на таблицу индекса columnstore ссылается само соединение.
- Созданные альтернативные решения соединения вложенными циклами и хэш-соединения должны иметь одинаковый первый дочерний элемент (внешняя ссылка).

### <a name="adaptive-joins-and-nested-loop-efficiency"></a>Адаптивные соединения и эффективность вложенного цикла
Если адаптивное соединение переключается на режим вложенного цикла, оно использует строки, уже считанные сборкой хэш-соединения. Этот оператор **не** считывает повторно строки по внешней ссылке.

### <a name="adaptive-threshold-rows"></a>Строки адаптивного порогового значения
Приведенная ниже диаграмма показывает пример пересечения между затратами хэш-соединения и затраты альтернативного ему соединения вложенными циклами.  В этой точке пересечения определяется пороговое значение, что, в свою очередь, определяет фактический алгоритм, используемый для операции соединения.

![Пороговое значение соединения](./media/6_AQPJoinThreshold.png)

## <a name="interleaved-execution-for-multi-statement-table-valued-functions"></a>Выполнение с чередованием для функций с табличным значением с несколькими инструкциями
Выполнение с чередованием изменяет однонаправленную границу между этапами оптимизации и выполнения для выполнения с одним запросом и позволяет планам адаптироваться с учетом пересмотренных оценок кратности. Если во время оптимизации нам встречается кандидат на выполнение с чередованием, который сейчас является **функциями с табличным значением с несколькими инструкциями (MSTVF)**, мы приостановим оптимизацию, выполним соответствующее поддерево, запишем точные оценки кратности и возобновим оптимизацию для нисходящих операций.
Функции MSTVF имеют фиксированное предполагаемое значение кратности 100 в [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] и [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] и 1 в более ранних версиях. Выполнение с чередованием помогает устранить проблемы с производительностью рабочих нагрузок, вызванные фиксированными оценками кратности, которые связаны с функциями MSTVF.

На приведенном ниже рисунке изображены выходные данные статистики активных запросов — подмножество общего плана выполнения, показывающее влияние фиксированных оценок кратности из MSTVF. Вы можете сравнить фактическую передачу строк с предполагаемым значением. Следует отметить три области плана (передача идет справа налево):
1. Сканирование таблицы MSTVF имеет фиксированную оценку в 100 строк. Но в данном примере через это сканирование таблицы MSTVF передается 527 597 строк, как видно в статистике активных запросов — *527 597 из 100*, то есть фиксированная оценка имеет значительное отклонение.
1. Для операции вложенных циклов предполагается, что наружная часть соединения возвращает всего 100 строк. Учитывая, как много строк функция MSTVF возвращает на самом деле, лучше всего перейти на другой алгоритм соединения.
1. Для операции хэш-совпадений обратите внимание на небольшой предупреждающий символ, который в данном случае указывает на временную запись на диск.

![Поток строк и предполагаемые строки](./media/7_AQPFlowThreeAreas.png)

Сравним предыдущий план с фактическим планом, созданным при включенном выполнении с чередованием:

![План с чередованием](./media/8_AQPInterleavedEnabledPlan.png)

1. Обратите внимание, что сканирование таблицы MSTVF отражает точную оценку кратности. Также обратите внимание на переупорядочение этого сканирования таблицы и других операций.
1. Что касается алгоритмов соединения, мы перешли от операции вложенных циклов Loop к операции хэш-совпадений, которая лучше подходит для такого большого числа строк.
1. Также обратите внимание, что прекратились предупреждения о временной записи, так как мы выделяем больше памяти на основе истинного количества строк, поступающих из сканирования таблицы MSTVF.

### <a name="interleaved-execution-eligible-statements"></a>Допустимые инструкции выполнения с чередованием
Инструкции ссылок MSTVF в выполнении с чередованием сейчас должны быть доступны только для чтения и не входить в состав операции изменения данных. Кроме того, функции MSTVF нельзя выполнять с чередованием, если в них не используются константы времени выполнения.

### <a name="interleaved-execution-benefits"></a>Преимущества выполнения с чередованием
Обычно чем выше отклонение между предполагаемым и фактическим числом строк в сочетании с числом нисходящих операций плана, тем больше негативное влияние на производительность.
В общем случае выполнение с чередованием оказывается полезным для запросов, где выполняются следующие условия:
1. Имеется большое отклонение между предполагаемым и фактическим числом строк для промежуточного результирующего набора (в данном случае — MSTVF).
1. Весь запрос чувствителен к изменению размера промежуточного результата. Обычно это происходит, когда над поддеревом в плане запроса имеется сложное дерево.
Выполнение с чередованием не принесет никакой выгоды для простой инструкции "SELECT *" из MSTVF.

### <a name="interleaved-execution-overhead"></a>Издержки выполнения с чередованием
Издержки должны быть минимальными либо отсутствовать. Функции MSTVF уже были материализованы перед появлением выполнения с чередованием, но различие состоит в том, что теперь мы разрешаем отложенную оптимизацию и используем оценку кратности для набора материализованных строк.
Как и в случае с любым планом, влияющим на изменения, некоторые планы могут изменяться таким образом, что при улучшенной кратности для поддерева мы получаем ухудшенный план для всего запроса в целом. В качестве устранения этой проблемы можно отменить изменения уровня совместимости или использовать хранилище запросов для принудительного применения нерегрессированной версии плана.

### <a name="interleaved-execution-and-consecutive-executions"></a>Выполнение с чередованием и последовательные выполнения
После кэширования плана выполнения с чередованием этот план с оценками, пересмотренными при первом выполнении, используется для последующих выполнений без повторного создания экземпляра выполнения с чередованием.

### <a name="tracking-interleaved-execution-activity"></a>Отслеживание операций выполнения с чередованием
Вы можете просмотреть атрибуты использования в фактическом плане выполнения запроса:

| Атрибут плана выполнения | Description |
| --- | --- |
| ContainsInterleavedExecutionCandidates | Применяется к узлу *QueryPlan*. Значение *true* означает, что план содержит кандидаты на выполнение с чередованием. |
| IsInterleavedExecuted | Атрибут элемента *RuntimeInformation* под RelOp для узла TVF. Если значение равно *true*, значит, операция была материализована как часть операции выполнения с чередованием. |

Вы также можете отслеживать случаи выполнения с чередованием с помощью следующих событий xEvents:

| xEvent | Description |
| ---- | --- |
| interleaved_exec_status | Это событие возникает, когда происходит выполнение с чередованием. |
| interleaved_exec_stats_update | Это событие описывает оценки кратности, обновленные выполнением с чередованием. |
| Interleaved_exec_disabled_reason | Это событие возникает, когда запрос с кандидатом на выполнение с чередованием не получает такое выполнение. |

Чтобы разрешить выполнению с чередованием пересматривать оценки кратности MSTVF, нужно выполнить запрос. При этом предполагаемый план выполнения по-прежнему сообщает о наличии кандидатов на выполнение с чередованием с помощью атрибута showplan `ContainsInterleavedExecutionCandidates`.    

### <a name="interleaved-execution-caching"></a>Кэширование выполнения с чередованием
Если план удаляется или извлекается из кэша, при выполнении запроса появляется новая компиляция, в которой используется исполнение чередованием.
Инструкция с использованием `OPTION (RECOMPILE)` создаст план с использованием выполнения с чередованием, но без кэширования.     

### <a name="interleaved-execution-and-query-store-interoperability"></a>Взаимодействие выполнения с чередованием и хранилища запросов
Планы с использованием выполнения с чередованием можно применять принудительно. План представляет собой версию с оценками кратности, исправленными на основе начального выполнения.    

## <a name="see-also"></a>См. также:
[Центр производительности для базы данных SQL Azure и ядра СУБД SQL Server](../../relational-databases/performance/performance-center-for-sql-server-database-engine-and-azure-sql-database.md)     
[Руководство по архитектуре обработки запросов](../../relational-databases/query-processing-architecture-guide.md)    
[Справочник по логическим и физическим операторам Showplan](../../relational-databases/showplan-logical-and-physical-operators-reference.md)    
[Соединения](../../relational-databases/performance/joins.md)    
[Демонстрация адаптивной обработки запросов](https://github.com/joesackmsft/Conferences/blob/master/Data_AMP_Detroit_2017/Demos/AQP_Demo_ReadMe.md)          

