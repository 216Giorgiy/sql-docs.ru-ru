---
title: Интеллектуальная обработка запросов в базах данных Microsoft SQL | Документы Майкрософт
description: Функции интеллектуальной обработки запросов для повышения производительности запросов в SQL Server и базе данных SQL Azure.
ms.custom: ''
ms.date: 02/21/2019
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: performance
ms.topic: conceptual
helpviewer_keywords: ''
author: joesackmsft
ms.author: josack
manager: craigg
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 1b92bc15079fcc85212ea3d1b51be64a3348a4b1
ms.sourcegitcommit: 2663063e29f2868ee6b6d596df4b2af2d22ade6f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57305372"
---
# <a name="intelligent-query-processing-in-sql-databases"></a>Интеллектуальная обработка запросов в базах данных SQL

[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]

Семейство функций интеллектуальной обработки запросов включает ряд возможностей с широкой областью применения. Они повышают производительность существующих рабочих нагрузок с минимальными усилиями по реализации. Чтобы автоматически применять это семейство функций, перейдите на соответствующий уровень совместимости базы данных.

| **Функция интеллектуальной обработки запросов** | **Поддерживается в Базе данных Azure SQL** | **Поддерживается в SQL Server** |
| --- | --- | --- |
| [Адаптивные соединения в пакетном режиме](https://docs.microsoft.com/en-us/sql/relational-databases/performance/adaptive-query-processing?view=sql-server-2017#batch-mode-adaptive-joins) | Да, при уровне совместимости 140| Да, начиная с SQL Server 2017 при уровне совместимости 140|
| [Приблизительный подсчет различных объектов](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#approximate-query-processing) | Да, в режиме общедоступной предварительной версии| Да, начиная с SQL Server 2019 CTP 2.0 в режиме общедоступной предварительной версии|
| [Пакетный режим для данных rowstore](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#batch-mode-on-rowstore) | Да, при уровне совместимости 150 в режиме общедоступной предварительной версии| Да, начиная с SQL Server 2019 CTP 2.0 при уровне совместимости 150 в режиме общедоступной предварительной версии|
| [Выполнение с чередованием](https://docs.microsoft.com/en-us/sql/relational-databases/performance/adaptive-query-processing?view=sql-server-2017#interleaved-execution-for-multi-statement-table-valued-functions) | Да, при уровне совместимости 140| Да, начиная с SQL Server 2017 при уровне совместимости 140|
| [Обратная связь по временно предоставляемому буферу памяти в пакетном режиме](https://docs.microsoft.com/en-us/sql/relational-databases/performance/adaptive-query-processing?view=sql-server-2017#batch-mode-memory-grant-feedback) | Да, при уровне совместимости 140| Да, начиная с SQL Server 2017 при уровне совместимости 140|
| [Обратная связь по временно предоставляемому буферу памяти в строковом режиме](https://docs.microsoft.com/en-us/sql/relational-databases/performance/adaptive-query-processing?view=sql-server-2017#row-mode-memory-grant-feedback) | Да, при уровне совместимости 150 в режиме общедоступной предварительной версии| Да, начиная с SQL Server 2019 CTP 2.0 при уровне совместимости 150 в режиме общедоступной предварительной версии|
| [Встраивание скалярных определяемых пользователем функций](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#scalar-udf-inlining) | Нет, но запланировано на будущее обновление | Да, начиная с SQL Server 2019 CTP 2.1 при уровне совместимости 150 в режиме общедоступной предварительной версии|
| [Отложенная компиляция табличных переменных](https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?view=sql-server-2017#table-variable-deferred-compilation) | Да, при уровне совместимости 150 в режиме общедоступной предварительной версии| Да, начиная с SQL Server 2019 CTP 2.0 при уровне совместимости 150 в режиме общедоступной предварительной версии|



## <a name="adaptive-query-processing"></a>Адаптивная обработка запросов

Семейство функций адаптивной обработки запросов включает указанные ниже улучшения для обработки запросов. Эти улучшения адаптируют стратегии оптимизации к среде выполнения для рабочих нагрузок ваших приложений: 
- Адаптивные соединения в пакетном режиме
- Обратная связь для временно предоставляемого буфера памяти
- Выполнение с чередованием для функций с табличным значением с несколькими инструкциями (MSTVF)

### <a name="batch-mode-adaptive-joins"></a>Адаптивные соединения в пакетном режиме

Эта функция позволяет динамически переключить ваш план на лучшую стратегию соединения во время выполнения, используя отдельный кэшированный план.

Дополнительные сведения об адаптивных соединениях в пакетном режиме см. в статье [Адаптивная обработка запросов в базах данных SQL](../../relational-databases/performance/adaptive-query-processing.md).

### <a name="row-and-batch-mode-memory-grant-feedback"></a>Обратная связь по временно предоставляемому буферу памяти в строковом или пакетном режиме

> [!NOTE]
> Функция "Обратная связь по временно предоставляемому буферу памяти в строковом режиме" предоставляется в режиме общедоступной предварительной версии.  

Эта функция отвечает за пересчет фактической требуемой памяти для запроса. Затем обновляется значение объема предоставляемой памяти для кэшированного плана. Это снижает чрезмерное выделение памяти, которое влияет на параллелизм. Кроме того, эта функция устраняет проблемы с недостаточным предоставлением памяти, которые приводят к дорогостоящим сбросам данных на диск.

Дополнительные сведения об обратной связи для временно предоставляемого буфера памяти см. в статье [Адаптивная обработка запросов в базах данных SQL](../../relational-databases/performance/adaptive-query-processing.md).

### <a name="interleaved-execution-for-mstvfs"></a>Выполнение с чередованием для MSTVF

При выполнении с чередованием используется фактическое количество строк из функции для принятия обоснованного решения о плане запроса. См. дополнительные сведения о [функциях с табличным значением с несколькими инструкциями (MSTVF)](../../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md#TVF).

Дополнительные сведения о выполнении с чередованием см. в статье [Адаптивная обработка запросов в базах данных SQL](../../relational-databases/performance/adaptive-query-processing.md).

## <a name="table-variable-deferred-compilation"></a>Отложенная компиляция табличных переменных

> [!NOTE]
> Функция "Отложенная компиляция табличных переменных" предоставляется в режиме общедоступной предварительной версии.  

Отложенная компиляция табличных переменных позволяет оптимизировать план и повысить общую производительность запросов со ссылками на табличные переменные. Во время оптимизации и первичной компиляции эта функция распространяет оценки кратности, основанные на фактическом количестве строк табличной переменной. Эти точные сведения о количестве строк позволяют оптимизировать последующие операции плана.

Если используется отложенная компиляция табличных переменных, компиляция инструкции со ссылкой на табличную переменную откладывается до первого фактического выполнения этой инструкции. Это поведение отложенной компиляции совпадает с поведением временных таблиц. Такое изменение позволяет использовать реальную кратность вместо обычного предположения по одной строке. 

Вы можете включить отложенную компиляцию табличных переменных в Базе данных SQL Azure в режиме общедоступной предварительной версии. Для этого включите уровень совместимости 150 для той базы данных, к которой вы подключаетесь при выполнении нужного запроса.

См. дополнительные сведения об [отложенной компиляции табличных переменных](../../t-sql/data-types/table-transact-sql.md#table-variable-deferred-compilation).

## <a name="scalar-udf-inlining"></a>Встраивание скалярных пользовательских функций

> [!NOTE]
> Предоставляется общедоступная предварительная версия функции встраивания скалярных определяемых пользователем функций.  

Функция встраивания скалярных определяемых пользователем функций позволяет автоматически преобразовать [скалярные определяемые пользовательские функции](../../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md#Scalar) в реляционные выражения. Затем они внедряются в вызывающий SQL-запрос. Такое преобразование повышает производительность рабочих нагрузок, которые используют скалярные определяемые пользователем функции. Встраивание скалярных определяемых пользователем функций способствует оптимизации с учетом стоимости операций, выполняемых внутри определяемых пользователем функций. Это обеспечивает эффективные планы выполнения с поддержкой наборов и параллелизма вместо неэффективных, итеративных и последовательных планов. Эта функция включена по умолчанию на уровне совместимости базы данных 150.

Дополнительные сведения см. в разделе [Встраивание скалярных функций, определяемых пользователем](../user-defined-functions/scalar-udf-inlining.md).

## <a name="approximate-query-processing"></a>Приблизительная обработка запросов

> [!NOTE]
> Предоставляется общедоступная предварительная версия функции **APPROX_COUNT_DISTINCT**.  

Приблизительная обработка запросов — это новое семейство функций. Оно позволяет агрегировать большие наборы данных, для которых скорость реагирования намного важнее абсолютной точности. В качестве примера предположим, что нам нужно вычислить выражение **COUNT(DISTINCT())** по 10 миллиардам строк, чтобы отобразить результат на панели мониторинга. Абсолютная точность здесь не требуется, но критически важна скорость реагирования. Новая агрегатная функция **APPROX_COUNT_DISTINCT** возвращает приблизительное количество содержащихся в группе уникальных значений, не равных NULL.

Дополнительные сведения см. в описании [APPROX_COUNT_DISTINCT (Transact-SQL)](../../t-sql/functions/approx-count-distinct-transact-sql.md).

## <a name="batch-mode-on-rowstore"></a>Пакетный режим для данных rowstore 

> [!NOTE]
> Предоставляется общедоступная предварительная версия функции "Пакетный режим для данных rowstore".  

Пакетный режим для данных rowstore обеспечивает выполнение в пакетном режиме для аналитических рабочих нагрузок без необходимости использовать индексы columnstore.  Эта функция поддерживает выполнение в пакетном режиме и фильтры по битовым картам для кучи на диске и индексов сбалансированного дерева. Пакетный режим rowstore обеспечивает поддержку для всех операторов, доступных в этом режиме.

### <a name="background"></a>Историческая справка

В [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] появилась новая функция для ускорения аналитических рабочих нагрузок — индексы columnstore. С каждым последующим выпуском мы расширяли возможности использования индексов columnstore и улучшали их производительность. До этого момента мы представляли и документировали все эти возможности как одну функцию. Индексы columnstore создаются на уровне таблиц. Благодаря этому быстрее выполняются аналитические рабочие нагрузки. Но на самом деле здесь применяются два связанных, но различных набора технологий.
- Индексы **columnstore** позволяют аналитическим запросам получать доступ к данным только в требуемых столбцах. Кроме того, сжатие в формате columnstore намного эффективнее, чем для традиционных индексов **rowstore**. 
- При обработке в **пакетном режиме** операторы запросов выполняются более эффективно. Они работают по пакету строк, а не по одной строке за раз. С обработкой в пакетном режиме также связан ряд других улучшений масштабируемости. Дополнительные сведения о пакетном режиме см. в разделе [Режимы выполнения](../../relational-databases/query-processing-architecture-guide.md#execution-modes).

Эти два набора функций взаимодействуют, чтобы оптимизировать скорость выполнения операций ввода-вывода и использования ЦП.
- Благодаря индексам columnstore в памяти помещается больше данных. Это снижает потребность в операциях ввода-вывода.
- При обработке в пакетном режиме ресурсы ЦП используются более эффективно.

Эти две технологии совместно используются везде, где это возможно, для получения дополнительных преимуществ. Например, статические выражения в пакетном режиме можно вычислить в рамках сканирования индекса columnstore. Кроме того, с помощью соединений и статических вычислений пакетного режима мы гораздо более эффективно обрабатываем данные columnstore, которые сжаты с использованием кодирования по длине серий. 
 
Эти две функции можно использовать независимо друг от друга.
* Можно создать план со строковым режимом, который использует индексы columnstore.
* Можно создать план с пакетным режимом, который использует только индексы rowstore. 

Но обычно совместное использование этих компонентов дает наилучший результат. Поэтому до текущего момента оптимизатор запросов SQL Server применял пакетную обработку только для запросов, которые включают хотя бы одну таблицу с индексом columnstore.

Индексы columnstore не подходят для некоторых приложений. Приложение может использовать другие функции, которые не совместимы с индексами columnstore. Например, изменения на месте не совместимы со сжатием columnstore. Поэтому таблицы с кластеризованными индексами columnstore не поддерживают триггеры. Что еще важнее, индексы columnstore повышают затраты на выполнение инструкций **DELETE** и **UPDATE**. 

Для некоторых гибридных транзакционно-аналитических рабочих нагрузок издержки на транзакционные аспекты рабочей нагрузки перевешивают преимущество от использования индексов columnstore. В таких сценариях показатель использования ЦП можно снизить, отдельно применяя режим пакетной обработки. Поэтому функция "Пакетный режим для данных rowstore" позволяет применять пакетный режим для всех запросов. При этом неважно, какие индексы используются.

### <a name="workloads-that-might-benefit-from-batch-mode-on-rowstore"></a>Рабочие нагрузки, для которых целесообразно использовать пакетный режима для данных rowstore

Пакетный режим для данных rowstore предоставляет преимущества для рабочих нагрузок со следующими характеристиками:
* Если значительная часть рабочей нагрузки состоит из аналитических запросов. Обычно такие запросы используют соединения или статистические выражения для обработки сотен тысяч строк или даже больше.
* Если рабочая нагрузка сильно зависит от ЦП. Для всех случаев, когда узким местом остается скорость ввода и вывода, мы по прежнему рекомендуем при любой возможности применять индекс columnstore.
* Если создание индекса columnstore сопряжено со слишком большими транзакционными расходами для рабочей нагрузки. Возможно также, что индекс columnstore создать нельзя из-за зависимости приложения от функции, которая пока не поддерживает работу с индексами columnstore.

> [!NOTE]
> Использование пакетного режима для данных rowstore помогает только сократить потребление ресурсов ЦП. Если же узким местом являются операции ввода-вывода и данные не кэшируются ("холодный" кэш), использование пакетного режима для rowstore не сократит затраченное время. Аналогичным образом, если на компьютере не хватает памяти для кэширования всех данных, повышение производительности маловероятно.

### <a name="what-changes-with-batch-mode-on-rowstore"></a>Что изменяется при использовании пакетного режима для данных rowstore?

Помимо перехода на уровень совместимости 150, с вашей стороны не требуется никаких изменений для применения пакетного режима к данным rowstore для рабочих нагрузок.

Даже если запрос не содержит таблиц с индексом columnstore, обработчик запросов теперь включает пакетный режим в эвристический анализ. Этот эвристический анализ включает следующее:
1. Первоначальной проверки размеров таблиц, используемых операторов и предполагаемого количества элементов во входном запросе.
2. Дополнительных проверок, так как оптимизатор обнаруживает новые, более дешевые планы для запроса. Если эти альтернативные планы используют пакетный режим незначительно, оптимизатор прекратит изучение альтернатив с пакетным режимом.

Если для данных rowstore используется пакетный режим, фактический режим выполнения будет обозначен как **batch mode** (пакетный режим) в плане запроса. Оператор сканирования использует пакетный режим для кучи на диске и индексов сбалансированного дерева. При этом сканировании пакетного режима можно оценить фильтры растрового изображения в пакетном режиме. Вы можете заметить в плане и другие операторы пакетного режима. Например, хэш-соединения, статические операции на основе хэша, сортировки, статистические операции с окнами, фильтры, объединение и операторы вычисления скалярного значения.

### <a name="remarks"></a>Remarks

* Планы запросов не всегда используют пакетный режим. Оптимизатор запросов может определить, что пакетный режим не улучшит обработку запроса. 
* Пространство поиска оптимизатора запросов изменяется. Например, план в строковом режиме может не совпадать с планом, который вы получите на более низком уровне совместимости. А план в пакетном режиме может не совпадать с планом, который вы получите для индекса columnstore. 
* Новый режим сканирования пакетного режима для данных rowstore может изменять планы для запросов, в которых сочетаются индексы columnstore и rowstore.
* Для нового сканирования пакетного режима для данных rowstore действует ряд ограничений: 
    * Сканирование не будет использоваться для таблиц OLTP, выполняющейся в памяти, или для любых других индексов, отличных от индексов в виде куч на диске и сбалансированных деревьев. 
    * Также оно не применяется, если LOB-столбец извлекается или фильтруется. Это ограничение относится и к наборам разреженных столбцов и XML-столбцам.
* Есть запросы, для которых пакетный режим не применяется даже с индексами columnstore. В качестве примера можно назвать запросы с курсорами. Эти исключения относятся и к пакетному режиму для индексов rowstore.

### <a name="configure-batch-mode-on-rowstore"></a>Настройка пакетного режима для данных rowstore

Параметр **BATCH_MODE_ON_ROWSTORE** в конфигурации уровня базы данных включен по умолчанию. Он позволяет отключить пакетный режим для индексов rowstore, не требуя изменять уровень совместимости базы данных:

```sql
-- Disabling batch mode on rowstore
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ON_ROWSTORE = OFF;

-- Enabling batch mode on rowstore
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ON_ROWSTORE = ON;
```

Вы можете отключить пакетный режим для rowstore в конфигурации уровня базы данных. Но этот параметр можно переопределить на уровне запроса с помощью указания запроса **ALLOW_BATCH_MODE**. В следующем примере пакетный режим для данных rowstore включается, несмотря на то что функция отключена через конфигурацию на уровне базы данных:

```sql
SELECT [Tax Rate], [Lineage Key], [Salesperson Key], SUM(Quantity) AS SUM_QTY, SUM([Unit Price]) AS SUM_BASE_PRICE, COUNT(*) AS COUNT_ORDER
FROM Fact.OrderHistoryExtended
WHERE [Order Date Key]<=DATEADD(dd, -73, '2015-11-13')
GROUP BY [Tax Rate], [Lineage Key], [Salesperson Key]
ORDER BY [Tax Rate], [Lineage Key], [Salesperson Key]
OPTION(RECOMPILE, USE HINT('ALLOW_BATCH_MODE'));
```

Пакетный режим для данных rowstore также можно отключить для отдельных запросов, используя указание запроса **DISALLOW_BATCH_MODE**. См. следующий пример.

```sql
SELECT [Tax Rate], [Lineage Key], [Salesperson Key], SUM(Quantity) AS SUM_QTY, SUM([Unit Price]) AS SUM_BASE_PRICE, COUNT(*) AS COUNT_ORDER
FROM Fact.OrderHistoryExtended
WHERE [Order Date Key]<=DATEADD(dd, -73, '2015-11-13')
GROUP BY [Tax Rate], [Lineage Key], [Salesperson Key]
ORDER BY [Tax Rate], [Lineage Key], [Salesperson Key]
OPTION(RECOMPILE, USE HINT('DISALLOW_BATCH_MODE'));
```

## <a name="see-also"></a>См. также раздел

[Центр производительности для базы данных SQL Azure и ядра СУБД SQL Server](../../relational-databases/performance/performance-center-for-sql-server-database-engine-and-azure-sql-database.md)     
[Руководство по архитектуре обработки запросов](../../relational-databases/query-processing-architecture-guide.md)    
[Справочник по логическим и физическим операторам Showplan](../../relational-databases/showplan-logical-and-physical-operators-reference.md)    
[Соединения](../../relational-databases/performance/joins.md)    
[Демонстрация адаптивной обработки запросов](https://github.com/joesackmsft/Conferences/blob/master/Data_AMP_Detroit_2017/Demos/AQP_Demo_ReadMe.md)       
[Демонстрация интеллектуальной обработки запросов](https://github.com/joesackmsft/Conferences/blob/master/IQPDemos/IQP_Demo_ReadMe.md)   
