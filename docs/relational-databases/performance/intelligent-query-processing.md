---
title: Интеллектуальная обработка запросов в базах данных Microsoft SQL | Документы Майкрософт
description: Функции интеллектуальной обработки запросов для повышения производительности запросов в SQL Server и базе данных SQL Azure.
ms.custom: ''
ms.date: 11/07/2018
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.technology: performance
ms.topic: conceptual
helpviewer_keywords: ''
ms.assetid: ''
author: joesackmsft
ms.author: josack
manager: craigg
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: c4269cc9f61ecd1bd3130fe7fab0f1e5a1ae65bf
ms.sourcegitcommit: 9c6a37175296144464ffea815f371c024fce7032
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/15/2018
ms.locfileid: "51660956"
---
# <a name="intelligent-query-processing-in-sql-databases"></a>Интеллектуальная обработка запросов в базах данных SQL
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]

Семейство функций **интеллектуальной обработки запросов** включает средства, которые значительно повышают производительность существующих рабочих нагрузок и требуют минимальных усилий при реализации.

![Функции интеллектуальной обработки запросов](./media/3_IQPFeatureFamily.png)

## <a name="adaptive-query-processing"></a>Адаптивная обработка запросов
Семейство функций адаптивной обработки запросов включает усовершенствования, которые позволяют применять стратегии оптимизации к среде выполнения рабочих нагрузок ваших приложений. Эти улучшения включают адаптивные соединения в пакетном режиме, обратную связь с временно предоставляемым буфером памяти и выполнение с чередованием для функций с табличным значением с несколькими инструкциями.

### <a name="batch-mode-adaptive-joins"></a>Адаптивные соединения в пакетном режиме
Эта функция позволяет динамически переключить ваш план на лучшую стратегию соединения во время выполнения с использованием одного кэшированного плана.

### <a name="row-and-batch-mode-memory-grant-feedback"></a>Обратная связь по временно предоставляемому буферу памяти в строковом или пакетном режиме
> [!NOTE]
> Функция "Обратная связь по временно предоставляемому буферу памяти в строковом режиме" предоставляется в режиме общедоступной предварительной версии.  

Эта функция пересчитывает фактический объем памяти, необходимый для выполнения запроса, и обновляет размер временно предоставляемого буфера памяти для кэшированного плана. Это позволяет сократить избыточное использование временно предоставляемых буферов памяти и решить проблему с недостатком временно предоставляемых буферов памяти, который вызывает избыточную запись на диск.

### <a name="interleaved-execution-for-multi-statement-table-valued-functions-mstvfs"></a>Выполнение с чередованием для функций с табличным значением с несколькими инструкциями (MSTVF)
При выполнении с чередованием используется фактическое количество строк из функции для принятия обоснованного решения о плане запроса. 

Дополнительные сведения см. в статье [Адаптивная обработка запросов в базах данных SQL](../../relational-databases/performance/adaptive-query-processing.md).

## <a name="table-variable-deferred-compilation"></a>Отложенная компиляция табличных переменных
> [!NOTE]
> Функция "Отложенная компиляция табличных переменных" предоставляется в режиме общедоступной предварительной версии.  

Отложенная компиляция табличных переменных улучшает качество плана и повышает общую производительность для запросов со ссылкой на табличные переменные. Во время оптимизации и первичной компиляции эта функция будет распространять оценки кратности, основанные на фактическом количестве строк табличной переменной.  Эти точные сведения о количестве строк будут использоваться для оптимизации нижестоящих операций планирования.

При отложенной компиляции табличных переменных компиляция инструкции со ссылкой на табличную переменную откладывается до момента первого фактического выполнения инструкции. Такое поведение при отложенной компиляции идентично поведению временных таблиц. В результате вместо исходного однострочного предположения используется фактическое значение кратности. Чтобы включить общедоступную предварительную версию отложенной компиляции табличных переменных в Базе данных SQL Azure, активируйте режим совместимости базы данных 150 для базы данных, к которой вы подключаетесь при выполнении запроса.

См. дополнительные сведения об [отложенной компиляции табличных переменных](../../t-sql/data-types/table-transact-sql.md#table-variable-deferred-compilation ).

## <a name="scalar-udf-inlining"></a>Встраивание скалярных пользовательских функций
> [!NOTE]
> Встраивание скалярных пользовательских функций входит в общедоступную предварительную версию.  

Функция масштабируемого встраивания определяемых пользователем функций автоматически преобразует скалярные функции, определяемые пользователем (UDF), в реляционные выражения и внедряет их в вызывающий SQL-запрос. Это повышает производительность рабочих нагрузок, использующих скалярные функции, определяемые пользователем. Скалярное встраивание определяемых пользователем функций упрощает оптимизацию на основе коэффициентов стоимости в этих функциях. Это позволяет создать эффективные планы с использованием наборов и параллельного выполнения вместо неэффективных планов с последовательным итеративным выполнением. Эта функция включена по умолчанию на уровне совместимости базы данных 150.

Дополнительные сведения: [Встраивание скалярной функции, определяемой пользователем](https://docs.microsoft.com/sql/relational-databases/user-defined-functions/scalar-udf-inlining?view=sqlallproducts-allversions).

## <a name="approximate-query-processing"></a>Приблизительная обработка запросов
> [!NOTE]
> APPROX_COUNT_DISTINCT — эта функция предоставляется в режиме общедоступной предварительной версии.  

Приблизительная обработка запросов — это новое семейство функций, предназначенных для агрегирования в больших наборах данных, для которых скорость реагирования намного важнее абсолютной точности.  Примером может быть вычисление COUNT(DISTINCT()) в 10 миллиардах строк для отображения на панели мониторинга.  В этом случае абсолютная точность не требуется, но важна скорость реагирования. Новая агрегатная функция APPROX_COUNT_DISTINCT возвращает приблизительное количество уникальных значений, не равных NULL, в группе.

Дополнительные сведения см. в описании [APPROX_COUNT_DISTINCT (Transact-SQL)](../../t-sql/functions/approx-count-distinct-transact-sql.md).

## <a name="batch-mode-on-rowstore"></a>Пакетный режим для данных rowstore 
> [!NOTE]
> Функция "Пакетный режим для данных rowstore" предоставляется в режиме общедоступной предварительной версии.  

### <a name="background"></a>Историческая справка
В SQL Server 2012 появилась новая функция для ускорения аналитических рабочих нагрузок — индексы columnstore. Мы расширяли варианты использования индексов columnstore и улучшали их производительность с каждым последующим выпуском. До сих пор мы представляли и документировали все эти возможности как одну функцию: вы создаете индексы columnstore в таблицах, и рабочая нагрузка аналитики просто выполняется быстрее. Однако, на самом деле, существует два связанных, но различных набора технологий:
- Индексы **columnstore** позволяют аналитическим запросам получать доступ к данным только в тех столбцах, которые им нужны. Формат columnstore также обеспечивает гораздо более эффективное сжатие, чем сжатие страниц в традиционных индексах rowstore. 
- Обработка в **пакетном режиме** позволяет операторам запросов обрабатывать данные более эффективно, работая одновременно с пакетом строк, а не с одной строкой за раз. С обработкой в пакетном режиме также связан ряд других улучшений масштабируемости.

Два набора функций работают вместе, чтобы повысить скорость выполнения операций ввода-вывода и оптимизировать использование ЦП:
- Благодаря индексам columnstore в память можно поместить большее количество данных, что позволяет сократить число операций ввода-вывода.
- При обработке в пакетном режиме ресурсы ЦП используются более эффективно.

Эти две технологии совместно используются везде, где это возможно, для получения дополнительных преимуществ. Например, статические выражения в пакетном режиме можно вычислить в рамках сканирования индекса columnstore. Кроме того, с помощью соединений и статических вычислений пакетного режима мы гораздо более эффективно обрабатываем данные columnstore, которые сжаты с использованием кодирования по длине серий. 
 
Эти две функции можно использовать независимо: вы можете получить планы выполнения в строковом режиме, использующие индексы columnstore, и планы пакетного режима, использующие только индексы rowstore. Но так как в большинстве случаев совместное использование этих двух функций позволяет получить лучшие результаты, до сих пор оптимизатор запросов SQL рассматривал обработку в пакетном режиме только для запросов, которые включают по крайней мере одну таблицу с индексом columnstore.

В некоторых приложениях индексы columnstore не подходят, так как приложение использует функцию, которая не поддерживается индексами columnstore (например, триггеры не поддерживаются в таблицах с кластерными индексами columnstore). Что более важно, индексы columnstore добавляют издержки для инструкций DELETE и UPDATE, так как изменения на месте несовместимы со сжатием columnstore. Для некоторых гибридных транзакционно-аналитических рабочих нагрузок издержки на транзакционные аспекты рабочей нагрузки перевешивают преимущество, которое индексы columnstore приносят для аналитических запросов. В таких сценариях улучшить потребление ресурсов ЦП можно и за счет самого пакетного режима, поэтому функция **​​пакетного режима для данных rowstore** будет рассматривать пакетный режим для всех запросов независимо от используемых индексов.

### <a name="what-workloads-may-benefit-from-batch-mode-on-rowstore"></a>Рабочие нагрузки, которые могут получить преимущества от использования пакетного режима для данных rowstore
Получить преимущества от использования пакетного режима для данных rowstore могут следующие рабочие нагрузки:
1.  Значительная часть рабочей нагрузки состоит из аналитических запросов (как правило, запросов с операторами, например соединениями или статистическими выражениями, обрабатывающих сотни тысяч строк или более). (**И следующее**.)
2.  Рабочая нагрузка связана с ЦП (если узким местом являются операции ввода-вывода, по-прежнему рекомендуется рассмотреть индекс columnstore, если это возможно). (**И следующее**.)
3.  Если создание индекса columnstore добавляет слишком большие издержки в транзакционную часть рабочей нагрузки **либо** создание индекса columnstore не представляется возможным из-за того, что приложение зависит от функции, которая еще не поддерживается индексами columnstore.

> [!NOTE]
> Сократить потребление ресурсов ЦП может только использование пакетного режима для данных rowstore. Если же проблема связана с операциями ввода-вывода, а данные не кэшируются ("холодный" кэш), использование пакетного режима rowstore не сэкономит время. Аналогичным образом, если на компьютере не хватает памяти для кэширования всех данных, повышение производительности маловероятно.

### <a name="what-changes-with-batch-mode-on-rowstore"></a>Что изменяется при использовании пакетного режима для данных rowstore
Помимо перехода на уровень совместимости 150, чтобы включить пакетный режим для данных rowstore для рабочих нагрузок-кандидатов, не нужно ничего менять на своей стороне.

Даже если запрос не содержит какую-либо таблицу с индексом columnstore, обработчик запросов теперь использует эвристику, чтобы решить, следует ли рассматривать пакетный режим. Эвристика состоит из:
1.  Первоначальной проверки размеров таблиц, используемых операторов и предполагаемого количества элементов во входном запросе.
2.  Дополнительных проверок, так как оптимизатор обнаруживает новые, более дешевые планы для запроса. Если эти альтернативные планы используют пакетный режим незначительно, оптимизатор прекратит изучение альтернатив пакетного режима.

Если используется пакетный режим для данных rowstore, в плане выполнения запросов будет отображаться пакетный режим выполнения, используемый оператором сканирования для куч на диске и индексов в виде сбалансированного дерева.  Это сканирование в пакетном режиме может оценить фильтры растрового изображения в пакетном режиме.  В плане также можно увидеть другие операторы пакетного режима, такие как хэш-соединения, статические операции на основе хэша, сортировки, статистические операции с окнами, фильтры, объединение и операторы вычисления скалярного значения.

### <a name="remarks"></a>Remarks
1.  Гарантии относительно того, что планы запросов будут использовать пакетный режим, отсутствуют. Оптимизатор запросов может решить, что этот пакетный режим не полезен для запроса. 
2.  По мере изменения пространства поиска оптимизатора запросов, нет никакой гарантии, что если вы получите план выполнения в строковом режиме, он будет таким же, как план, который вы получите на более низком уровне совместимости. Кроме того, нет никакой гарантии, что в случае получения плана выполнения в пакетном режиме он будет таким же, как план, который можно получить при использовании индексов columnstore. 
3.  Из-за сканирования в новом пакетном режиме в rowstore планы могут неочевидными способами изменяться для запросов, в которых сочетаются индексы columnstore и rowstore.
4.  Текущие ограничения для сканирования в новом пакетном режиме для данных rowstore: сканирование не будет использоваться для таблиц OLTP, выполняющейся в памяти, или для любых других индексов, отличных от индексов в виде куч на диске и сбалансированных деревьев. Сканирование также не активируется, если LOB-столбец выбран или отфильтрован. Это ограничение включает в себя наборы разреженных столбцов и XML-столбцы.
5.  Есть запросы, для которых пакетный режим не используется даже с индексами columnstore (например, запросы, связанные с курсорами). Эти же исключения распространяются и на пакетный режим для данных rowstore.

### <a name="configuring-batch-mode-on-rowstore"></a>Настройка пакетного режима для данных rowstore
Конфигурации на уровне базы данных BATCH_MODE_ON_ROWSTORE включена по умолчанию и может использоваться для отключения пакетного режима для данных rowstore без необходимости изменения уровня совместимости базы данных:
```sql
-- Disabling batch mode on rowstore
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ON_ROWSTORE = OFF;

-- Enabling batch mode on rowstore
ALTER DATABASE SCOPED CONFIGURATION SET BATCH_MODE_ON_ROWSTORE = ON;
```
Пакетный режим для данных rowstore также можно отключить с помощью конфигурации на уровне базы данных, однако все еще нужно переопределить параметр на уровне запроса с использованием указания запроса ALLOW_BATCH_MODE. В следующем примере пакетный режим для данных rowstore включается, несмотря на то что функция отключена через конфигурацию на уровне базы данных:
```sql
SELECT [Tax Rate], [Lineage Key], [Salesperson Key], SUM(Quantity) AS SUM_QTY, SUM([Unit Price]) AS SUM_BASE_PRICE, COUNT(*) AS COUNT_ORDER
FROM Fact.OrderHistoryExtended
WHERE [Order Date Key]<=DATEADD(dd, -73, '2015-11-13')
GROUP BY [Tax Rate], [Lineage Key], [Salesperson Key]
ORDER BY [Tax Rate], [Lineage Key], [Salesperson Key]
OPTION(RECOMPILE, USE HINT('ALLOW_BATCH_MODE'));
```
Пакетный режим для данных rowstore также можно отключить для отдельных запросов, используя указание запроса DISALLOW_BATCH_MODE. Пример:
```sql
SELECT [Tax Rate], [Lineage Key], [Salesperson Key], SUM(Quantity) AS SUM_QTY, SUM([Unit Price]) AS SUM_BASE_PRICE, COUNT(*) AS COUNT_ORDER
FROM Fact.OrderHistoryExtended
WHERE [Order Date Key]<=DATEADD(dd, -73, '2015-11-13')
GROUP BY [Tax Rate], [Lineage Key], [Salesperson Key]
ORDER BY [Tax Rate], [Lineage Key], [Salesperson Key]
OPTION(RECOMPILE, USE HINT('DISALLOW_BATCH_MODE'));
```

## <a name="see-also"></a>См. также раздел
[Центр производительности для базы данных SQL Azure и ядра СУБД SQL Server](../../relational-databases/performance/performance-center-for-sql-server-database-engine-and-azure-sql-database.md)     
[Руководство по архитектуре обработки запросов](../../relational-databases/query-processing-architecture-guide.md)    
[Справочник по логическим и физическим операторам Showplan](../../relational-databases/showplan-logical-and-physical-operators-reference.md)    
[Соединения](../../relational-databases/performance/joins.md)    
[Демонстрация адаптивной обработки запросов](https://github.com/joesackmsft/Conferences/blob/master/Data_AMP_Detroit_2017/Demos/AQP_Demo_ReadMe.md)       
[Демонстрация интеллектуальной обработки запросов](https://github.com/joesackmsft/Conferences/blob/master/IQPDemos/IQP_Demo_ReadMe.md)   
