---
title: "Руководство по архитектуре обработки запросов | Документация Майкрософт"
ms.custom: 
ms.date: 10/26/2016
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- database-engine
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- guide, query processing architecture
- query processing architecture guide
ms.assetid: 44fadbee-b5fe-40c0-af8a-11a1eecf6cb5
caps.latest.revision: 5
author: BYHAM
ms.author: rickbyh
manager: jhubbard
translationtype: Human Translation
ms.sourcegitcommit: 2edcce51c6822a89151c3c3c76fbaacb5edd54f4
ms.openlocfilehash: 0f2edc5c0bbf2fba20b26826413ee4f659b379b1
ms.lasthandoff: 04/11/2017

---
# <a name="query-processing-architecture-guide"></a>Руководство по архитектуре обработки запросов
[!INCLUDE[tsql-appliesto-ss2008-all_md](../includes/tsql-appliesto-ss2008-all-md.md)]

Ядро СУБД обрабатывает запросы к различным архитектурам хранения данных, таким как локальные таблицы, секционированные таблицы и таблицы, распределенные по нескольким серверам. В следующих разделах описано, как SQL Server обрабатывает запросы и оптимизирует повторное использование запроса через кэширование плана выполнения.

## <a name="sql-statement-processing"></a>Обработка инструкций SQL

Обработка одиночной инструкции SQL — самый распространенный способ, с помощью которого SQL Server выполняет инструкции SQL. Шаги, используемые для обработки одиночной инструкции `SELECT` , которая обращается только к таблицам локальной базы (а не к представлениям и не к удаленным таблицам), иллюстрируют основной процесс.

#### <a name="optimizing-select-statements"></a>Оптимизация инструкций SELECT

Инструкция `SELECT` является непроцедурной. Она не определяет точные шаги, которые сервер базы данных должен предпринять для получения запрошенных данных. Это означает, что сервер базы данных должен проанализировать инструкцию для определения самого эффективного способа извлечения запрошенных данных. Это упоминается как оптимизация инструкции `SELECT` . Выполняющий это компонент называют оптимизатором запросов. Входные данные оптимизатора состоят из самого запроса, схемы базы данных (определений таблиц и индексов) и статистики базы данных. Выходные данные оптимизатора — это план выполнения запроса, который иногда называется планом запроса или просто планом. Содержимое плана запроса описывается более подробно далее в этом разделе.

Входные и выходные данные оптимизатора запросов при оптимизации одиночной инструкции `SELECT` показаны на следующей схеме.  
![query_processor_io](../relational-databases/media/query-processor-io.gif)

Инструкция `SELECT` определяет только следующее.  
* Формат результирующего набора. Он указан, главным образом, в списке выбора. Однако другие предложения, например `ORDER BY` и `GROUP BY` , также затрагивают конечную форму результирующего набора.
* Таблицы, которые содержат исходные данные. Они указываются в предложении `FROM` .
* Логическую связь между таблицами для инструкции `SELECT` . Это определяется в спецификациях соединения, которые могут появляться в предложении `WHERE` или в предложении `ON` , следующем за предложением `FROM`.
* Условия, которым строки в исходных таблицах должны соответствовать для выбора их инструкцией `SELECT` . Они указываются в предложениях `WHERE` и `HAVING` .


План выполнения запроса представляет собой определение следующего. 

* Последовательности, в которой происходит обращение к исходным таблицам.  
  Как правило, существует много последовательностей, в которых сервер базы данных может обращаться к базовым таблицам для построения результирующего набора. Например, если инструкция `SELECT` ссылается на три таблицы, сервер базы данных сначала может обратиться к `TableA`, использовать данные из `TableA` для извлечения соответствующих строк из `TableB`, а затем использовать данные из `TableB` для извлечения данных из `TableC`. Другие последовательности, в которых сервер базы данных может обращаться к таблицам:  
  `TableC`, `TableB`, `TableA`или  
  `TableB`, `TableA`, `TableC`или  
  `TableB`, `TableC`, `TableA`или  
  `TableC`, `TableA`, `TableB`  

* Методы, используемые для извлечения данных из каждой таблицы.  
  Есть различные методы для обращения к данным в каждой таблице. Если необходимы только несколько строк с определенными ключевыми значениями, то сервер базы данных может использовать индекс. Если необходимы все строки в таблице, то сервер базы данных может пропустить индексы и выполнить просмотр таблицы. Если необходимы все строки в таблице, но есть индекс, ключевые столбцы которого находятся в `ORDER BY`, то просмотр индекса вместо просмотра таблицы позволит избежать отдельный сортировки результирующего набора. Если таблица является очень маленькой, то просмотры таблицы могут быть самым эффективным методом для практически всех обращений к таблице. 


Процесс выбора одного плана выполнения из множества потенциально возможных планов называется оптимизацией. Оптимизатор запросов является одним из самых важных компонентов системы базы данных SQL. Хотя для анализа запроса и выбора плана оптимизатору запросов требуются некоторые накладные расходы, эти накладные расходы обычно многократно окупаются, когда оптимизатор запроса выбирает эффективный план выполнения. Например, двум строительным компаниям могут быть предоставлены идентичные проекты дома. Если одна компания потратит сначала несколько дней на планирование того, как она будет строить дом, а другая компания начнет строить без планирования, то компания, которая потратит время на планирование проекта, вероятно, закончит первой.

Оптимизатор запросов SQL Server работает по принципу оценки стоимости. Каждому возможному плану выполнения соответствует некоторая стоимость, определенная в терминах объема использованных вычислительных ресурсов. Оптимизатор запросов должен проанализировать возможные планы и выбрать один файл с самой низкой предполагаемой стоимостью. Для некоторых сложных инструкций `SELECT` есть тысячи возможных планов выполнения. В этих случаях оптимизатор запросов не анализирует все возможные комбинации. Вместо этого он использует сложные алгоритмы поиска плана выполнения, имеющего стоимость, близкую к минимальной возможной стоимости.

Оптимизатор запросов SQL Server выбирает план выполнения не с самой низкой стоимостью ресурсов. Он выбирает такой план, который быстрее других возвращает результаты пользователю, но при разумной цене. Например, параллельная обработка запроса обычно использует больше ресурсов, чем его последовательная обработка, но завершает выполнение запроса быстрее. Оптимизатор SQL Server будет использовать параллельный план выполнения для возврата результатов, если это не окажет неблагоприятного влияния на загрузку сервера.

Оптимизатор запросов полагается на статистику распределения, когда он оценивает затраты ресурсов для различных методов извлечения сведений из таблицы или индекса. Статистика распределения хранится для столбцов и индексов. Она указывает селективность значений в определенном индексе или столбце. Например, в таблице, представляющей автомобили, много автомобилей имеют одного производителя, но каждый автомобиль имеет уникальный идентификационный номер транспортного средства (VIN). Индекс по VIN является более селективным, чем индекс по производителям. Если статистика индекса не является текущей, оптимизатор запросов, возможно, не сделает лучший выбор для текущего состояния таблицы. Дополнительные сведения о хранении текущей статистики индекса см. в статье "Использование статистики для повышения производительности запросов". 

Оптимизатор запросов важен, потому что дает возможность серверу базы данных вносить динамическую коррекцию в изменяющиеся условия в базе данных, не требуя ввода данных от администратора базы данных или программиста. Это дает возможность программистам сосредоточиться на описании конечного результата запроса. Они могут полагаться на то, что оптимизатор запросов будет создавать эффективный план выполнения с учетом состояния базы данных каждый раз при выполнении инструкции.

#### <a name="processing-a-select-statement"></a>Обработка инструкции SELECT

Ниже представлены основные шаги, используемые SQL Server для обработки одиночной инструкции SELECT. 

1. Средство анализа просматривает инструкцию `SELECT` и разбивает ее на логические единицы, такие как ключевые слова, выражения, операторы и идентификаторы.
2. Строится дерево запроса, иногда называемое деревом последовательности, с описанием логических шагов, необходимых для преобразования исходных данных в формат, требуемый результирующему набору.
3. Оптимизатор запросов анализирует различные способы, с помощью которых можно обратиться к исходным таблицам. Затем он выбирает ряд шагов, которые возвращают результаты быстрее всего и используют меньше ресурсов. Дерево запроса обновляется для записи этого точного ряда шагов. Конечную, оптимизированную версию дерева запроса называют планом выполнения.
4. Реляционный механизм начинает реализовывать план выполнения. В ходе обработки шагов, требующих данных из базовых таблиц, реляционный механизм запрашивает у подсистемы хранилища передачу данных из набора строк, указанных реляционным механизмом.
5. Реляционный механизм преобразует данные, возвращенные подсистемой хранилища, в заданный для результирующего набора формат и возвращает результирующий набор клиенту.

#### <a name="processing-other-statements"></a>Обработка других инструкций

Основные шаги, описанные для обработки инструкции `SELECT` , применимы к другим инструкциям SQL, таким как `INSERT`, `UPDATE`и `DELETE`. Инструкции`UPDATE` и `DELETE` предназначены для набора строк, которые будут изменены или удалены. Идентификация этих строк выполняется так же, как и идентификация исходных строк, определяющих результирующий набор инструкции `SELECT` . Обе инструкции ( `UPDATE` и `INSERT` ) могут содержать встроенные инструкции SELECT, предоставляющие значения данных, которые будут обновлены или вставлены.

Даже инструкции языка описания данных DDL (язык DDL), такие как `CREATE PROCEDURE` или `ALTER TABL`, в конечном счете приводятся к ряду реляционных операций с таблицами системного каталога, а иногда (для `ALTER TABLE ADD COLUMN`) с таблицами данных.

### <a name="worktables"></a>Рабочие таблицы

Чтобы выполнить логические операции, указанные в инструкции SQL, реляционному механизму может потребоваться создание рабочей таблицы. Рабочие таблицы — это внутренние таблицы, предназначенные для хранения промежуточных результатов. Они создаются для некоторых запросов `GROUP BY`, `ORDER BY`или `UNION` . Например, если предложение `ORDER BY` ссылается на столбцы, не включенные в индексы, реляционному модулю может потребоваться создать рабочую таблицу, чтобы отсортировать результирующий набор в необходимом порядке. Рабочие таблицы также иногда применяются для временного хранения результатов выполнения части плана запроса. Рабочие таблицы создаются в базе данных `tempdb` , и когда они больше не нужны, автоматически удаляются.

### <a name="view-resolution"></a>Разрешение представлений

Обработчик запросов SQL Server обращается с индексированными и неиндексированными представлениями по-разному: 

* Строки индексированного представления хранятся в базе данных в том же формате, что и таблица. Если оптимизатор запросов решает использовать индексированное представление в плане запроса, оно обрабатывается так же, как базовая таблица.
* В случае неиндексированного представления хранится только его определение, но не строки. Оптимизатор запросов интегрирует логику определения представления в план выполнения, создаваемый для инструкции SQL, ссылающейся на неиндексированное представление. 

Решение об использовании индексированного представления принимает оптимизатор запросов SQL Server на основе тех же принципов, что и решение об использовании индекса таблицы. Если данные индексированного представления охватывают всю инструкцию SQL или ее часть, а оптимизатор запросов определит, что использовать индекс представления выгодно, он выберет индекс независимо от того, имеется ли в запросе ссылка на представление по его имени.

Если инструкция SQL ссылается на неиндексированное представление, средство синтаксического анализа и оптимизатор запросов анализируют исходный код инструкции SQL и представления, разрешая их в один план выполнения. Отдельных планов для инструкции SQL и представления нет.

Рассмотрим следующее представление:

```
USE AdventureWorks2014;
GO
CREATE VIEW EmployeeName AS
SELECT h.BusinessEntityID, p.LastName, p.FirstName
FROM HumanResources.Employee AS h 
JOIN Person.Person AS p
ON h.BusinessEntityID = p.BusinessEntityID;
GO
```

Обе следующих инструкции SQL, основанных на данном представлении, выполняют одни и те же операции над базовой таблицей, формируя одинаковый результат:

```
/* SELECT referencing the EmployeeName view. */
SELECT LastName AS EmployeeLastName, SalesOrderID, OrderDate
FROM AdventureWorks2014.Sales.SalesOrderHeader AS soh
JOIN AdventureWorks2014.dbo.EmployeeName AS EmpN
ON (soh.SalesPersonID = EmpN.BusinessEntityID)
WHERE OrderDate > '20020531';

/* SELECT referencing the Person and Employee tables directly. */
SELECT LastName AS EmployeeLastName, SalesOrderID, OrderDate
FROM AdventureWorks2014.HumanResources.Employee AS e 
JOIN AdventureWorks2014.Sales.SalesOrderHeader AS soh
ON soh.SalesPersonID = e.BusinessEntityID
JOIN AdventureWorks2014.Person.Person AS p
ON e.BusinessEntityID =p.BusinessEntityID
WHERE OrderDate > '20020531';
```

Используя входящую в среду SQL Server Management Studio инструкцию Showplan, нужно убедиться, что для обеих инструкций `SELECT` реляционный модуль создает один и тот же план выполнения.

#### <a name="using-hints-with-views"></a>Использование указаний с представлениями

Указания, связываемые с представлениями в запросах, могут конфликтовать с другими указаниями, которые обнаруживаются при расширении представления для доступа к его базовым таблицам. Когда это происходит, запрос возвращает ошибку. Взгляните, например, на следующее представление, в определение которого входит табличное указание:

```
USE AdventureWorks2014;
GO
CREATE VIEW Person.AddrState WITH SCHEMABINDING AS
SELECT a.AddressID, a.AddressLine1, 
    s.StateProvinceCode, s.CountryRegionCode
FROM Person.Address a WITH (NOLOCK), Person.StateProvince s
WHERE a.StateProvinceID = s.StateProvinceID;
```

Предположим, что вводится следующий запрос:

```
SELECT AddressID, AddressLine1, StateProvinceCode, CountryRegionCode
FROM Person.AddrState WITH (SERIALIZABLE)
WHERE StateProvinceCode = 'WA';
```

Он завершится ошибкой, так как указание `SERIALIZABLE` , примененное в запросе к представлению `Person.AddrState` , при расширении представления распространится как на таблицу `Person.Address` , так и на таблицу `Person.StateProvince` . Однако при расширении представления будет также обнаружено указание `NOLOCK` , связанное с таблицей `Person.Address`. Из-за конфликта указаний `SERIALIZABLE` и `NOLOCK` результирующий запрос окажется неправильным. 

Табличные указания `PAGLOCK`, `NOLOCK`, `ROWLOCK`, `TABLOCK`и `TABLOCKX` , а также `HOLDLOCK`, `NOLOCK`, `READCOMMITTED`, `REPEATABLEREAD`и `SERIALIZABLE` конфликтуют друг с другом.

Указания могут распространяться через уровни вложенных представлений. Предположим, что в запросе указание `HOLDLOCK` применяется к представлению `v1`. При расширении представления `v1` выясняется, что представление `v2` является частью его определения. Определение`v2`включает в себя связанное с одной из его базовых таблиц указание `NOLOCK` . Однако эта таблица также наследует представленное в запросе указание `HOLDLOCK` , примененное к представлению `v1`. Из-за конфликта указаний `NOLOCK` и `HOLDLOCK` запрос завершится ошибкой.

Если в запросе, включающем представление, используется указание `FORCE ORDER` , порядок соединения таблиц в представлении определяется по позиции представления в конструкции упорядочения. Например, приведенный ниже запрос выбирает данные из трех таблиц и представления:

```
SELECT * FROM Table1, Table2, View1, Table3
WHERE Table1.Col1 = Table2.Col1 
    AND Table2.Col1 = View1.Col1
    AND View1.Col2 = Table3.Col2;
OPTION (FORCE ORDER);
```

Допустим, что представление `View1` определено следующим образом:

```
CREATE VIEW View1 AS
SELECT Colx, Coly FROM TableA, TableB
WHERE TableA.ColZ = TableB.Colz;
```

В этом случае порядок соединения таблиц в плане запроса будет таким: `Table1`, `Table2`, `TableA`, `TableB`, `Table3`.

### <a name="resolving-indexes-on-views"></a>Разрешение индексов для представлений

Как и при работе с любым индексом, SQL Server использует в плане запроса индексированное представление, только если оптимизатор запросов определит, что это целесообразно.

Индексированные представления можно создавать в любом выпуске SQL Server. В некоторых версиях SQL Server оптимизатор запросов учитывает индексированные представления автоматически. Чтобы использовать индексированное представление в некоторых версиях SQL Server, следует применить табличное указание `NOEXPAND` . Пояснения см. в документации для каждой версии.

Оптимизатор запросов SQL Server пользуется индексированными представлениями при соблюдении следующих условий. 

* Для следующих параметров сеанса установлено значение `ON`: 
  * `ANSI_NULLS`
  * `ANSI_PADDING`
  * `ANSI_WARNINGS`
  * `ARITHABORT`
  * `CONCAT_NULL_YIELDS_NULL`
  * `QUOTED_IDENTIFIER` 
  * Для параметра сеанса `NUMERIC_ROUNDABORT` установлено значение OFF.
* Оптимизатор запросов находит соответствие между столбцами индексированного представления и элементами запроса, например: 
  * предикатами условия поиска в предложении WHERE;
  * операциями соединения;
  * Агрегатные функции
  * Предложения`GROUP BY` 
  * ссылками на таблицы.
* Предполагаемые затраты на использование индекса имеют меньшую стоимость по сравнению с любыми механизмами доступа, имеющимися в распоряжении оптимизатора запросов. 
* Каждая таблица, на которую ссылается запрос (либо прямо, либо при расширении представления для доступа к его базовым таблицам), соответствующая табличной ссылке в индексированном представлении, должна иметь в запросе точно такой же набор указаний.

> [!NOTE] 
. Указания `READCOMMITTED` и `READCOMMITTEDLOCK` в данном контексте всегда рассматриваются как разные, независимо от уровня изоляции текущей транзакции.
 
За исключением требований к параметрам `SET` и табличным указаниям, это те же самые правила, по которым оптимизатор запросов выясняет, подходит ли индекс таблицы для выполнения запроса. Для использования индексированного представления в запросе больше ничего указывать не нужно.

Запрос не обязательно должен ссылаться в предложении `FROM` на индексированное представление, чтобы оптимизатор запросов его использовал. Если запрос ссылается на столбцы в базовой таблице, которые также присутствуют в индексированном представлении, и оптимизатор запросов определяет, что индексированное представление будет иметь самую низкую стоимость механизма доступа, он применит индексированное представление точно так же, как он применяет индекс базовой таблицы, если на него отсутствуют прямые ссылки в запросе. Оптимизатор запросов может применить представление и в том случае, если оно содержит столбцы, на которые не ссылается запрос, если это представление обеспечивает самую низкую стоимость доступа к одному или нескольким столбцам, указанным в запросе.

Индексированное представление, указанное в предложении `FROM` , оптимизатор запросов рассматривает как стандартное представление. В начале процесса оптимизации оптимизатор запросов расширяет определение представления в запрос, а затем выполняет в индексированном представлении поиск соответствий. В окончательном плане выполнения, выбранном оптимизатором, может быть использовано индексированное представление, или же план может материализовать необходимые данные, производя доступ к базовым таблицам этого представления. Оптимизатором будет выбран вариант с наименьшей стоимостью.

#### <a name="using-hints-with-indexed-views"></a>Использование указаний с индексированными представлениями

Чтобы индексы представления не использовались в запросе, можно задать указание запроса `EXPAND VIEWS` или табличное указание `NOEXPAND` , чтобы принудительно задействовать индекс для индексированного представления запроса в предложении `FROM` . Однако оптимизатору запросов следует разрешить динамически определять лучший метод доступа для каждого из запросов. Ограничьте применение указаний `EXPAND` и `NOEXPAND` только теми случаями, когда очевидно, что они значительно повысят производительность.

Параметр `EXPAND VIEWS` указывает, что оптимизатор запросов не будет использовать индексы представления для всего запроса. 

Если для представления задано указание `NOEXPAND` , оптимизатор запросов предполагает использование всех индексов, определенных в представлении. `NOEXPAND` может иметь необязательное предложение `INDEX()` , которое активирует принудительное применение указанных индексов в оптимизаторе запросов. `NOEXPAND` может быть указано только для индексированного представления и не применяется для представлений без индексов.

Если в запросе, содержащем представление, не заданы ни `NOEXPAND` , ни `EXPAND VIEWS` , это представление расширяется для доступа к базовым таблицам. Если запрос представления содержит какие-либо табличные указания, они распространяются на базовые таблицы. (Этот процесс подробно описан в разделе "Разрешение представлений".) Пока указания, имеющиеся в базовых таблицах представления, идентичны, для запроса может устанавливаться соответствие с индексированным представлением. Чаще всего эти указания соответствуют друг другу, поскольку они наследуются непосредственно из представления. Однако если запрос ссылается на таблицы, а не на представления, и применяемые к этим таблицам указания неидентичны, то для такого запроса соответствие с индексированным представлением устанавливаться не может. Если указания `INDEX`, `PAGLOCK`, `ROWLOCK`, `TABLOCKX`, `UPDLOCK`или `XLOCK` применяются к таблицам, на которые запрос ссылается после расширения представления, для этого запроса не может быть установлено соответствие с индексированным представлением.

Если табличное указание вида `INDEX (index_val[ ,...n] )` ссылается на представление в запросе, а указание `NOEXPAND` не задано, указание индекса не обрабатывается. Конкретный индекс следует указывать через `NOEXPAND. 

Обычно, если оптимизатор запросов устанавливает соответствие индексированного представления запросу, все заданные в таблицах или представлениях запроса указания применяются непосредственно к индексированному представлению. Если оптимизатор запросов решил не использовать индексированное представление, все указания распространяются непосредственно на таблицы, на которые ссылается это представление. Дополнительные сведения см. в разделе "Разрешение представлений". Это не относится к указаниям соединения. Они применяются только в той исходной позиции запроса, где они указаны. Указания в соединении оптимизатором запросов при установке соответствия запроса индексированным представлениям не рассматриваются. Если план запроса использует индексированное представление, которое совпадает с частью запроса, содержащей указание соединения, последний в данном плане не используется.

В определении индексированных представлений указания не допускаются. В режимах совместимости 80 и выше SQL Server пропускает указания при работе с определениями индексированных представлений и при выполнении содержащих их запросов. В режиме совместимости 80 использование указаний в определениях индексированных представлений не вызывает ошибок синтаксиса — они просто пропускаются.

### <a name="resolving-distributed-partitioned-views"></a>Разрешение распределенных секционированных представлений

Обработчик запросов SQL Server оптимизирует производительность распределенных секционированных представлений. При оптимизации распределенных секционированных представлений важно минимизировать количество данных, передаваемых между серверами.

SQL Server создает интеллектуальные динамические планы, которые позволяют эффективно использовать распределенные запросы для доступа к данным в удаленных таблицах-элементах. 

* Обработчик запросов сначала использует OLE DB для получения определений ограничений CHECK для каждой таблицы-элемента. Это позволяет ему определить распределение ключевых значений между таблицами серверов.
* Обработчик запросов сравнивает диапазоны ключей, заданные в предложении `WHERE` инструкции SQL, со схемой распределения строк между таблицами-элементами. Затем обработчик запросов строит план выполнения, который использует распределенные запросы для получения только тех удаленных строк, которые требуются для завершения инструкции SQL. Кроме того, план выполнения строится таким образом, чтобы обращение к удаленным данным или метаданным выполнялось только в тот момент, когда они требуются.

Например, рассмотрим систему, в которой пользовательская таблица разделена на три секции на серверах Server1 (`CustomerID` от 1 до 3299999), Server2 (`CustomerID` от 3300000 до 6599999) и Server3 (`CustomerID` от 6600000 до 9999999).

Допустим, план выполнения, созданный для этого запроса, выполняется на сервере Server1:

```
SELECT *
FROM CompanyData.dbo.Customers
WHERE CustomerID BETWEEN 3200000 AND 3400000;
```

План выполнения этого запроса извлекает строки со значениями ключей `CustomerID` от 3200000 до 3299999 из локальной таблицы-элемента и вызывает распределенный запрос для получения строк со значениями ключей от 3300000 до 3400000 с сервера Server2.

Обработчик запросов сервера SQL Server также может встроить динамическую логику в планы выполнения инструкций SQL, если значения ключей при создании плана неизвестны. Рассмотрим следующую хранимую процедуру:

```
CREATE PROCEDURE GetCustomer @CustomerIDParameter INT
AS
SELECT *
FROM CompanyData.dbo.Customers
WHERE CustomerID = @CustomerIDParameter;
```

SQL Server не может предсказать, какое значение ключа будет выдавать параметр `@CustomerIDParameter` при выполнении процедуры. Поскольку значение ключа предсказать нельзя, обработчик запросов не может заранее определить, к какой таблице потребуется доступ. В этом случае SQL Server создает план выполнения с условной логикой, называемой динамическими фильтрами, для управления доступом к таблицам-элементам на основе значения входного параметра. Если предположить, что хранимая процедура `GetCustomer` выполнена на сервере Server1, логику плана выполнения можно представить следующим образом:

```
IF @CustomerIDParameter BETWEEN 1 and 3299999
   Retrieve row from local table CustomerData.dbo.Customer_33
ELSEIF @CustomerIDParameter BETWEEN 3300000 and 6599999
   Retrieve row from linked table Server2.CustomerData.dbo.Customer_66
ELSEIF @CustomerIDParameter BETWEEN 6600000 and 9999999
   Retrieve row from linked table Server3.CustomerData.dbo.Customer_99
```

Иногда SQL Server создает динамические планы выполнения даже для непараметризованных запросов. Оптимизатор может параметризовать запрос так, чтобы план выполнения можно было использовать повторно. Если оптимизатор параметризует запрос, ссылающийся на секционированное представление, он не будет знать, находятся ли нужные строки в заданной базовой таблице. В дальнейшем ему придется использовать динамические фильтры в планах выполнения.


## <a name="stored-procedure-and-trigger-execution"></a>Выполнение хранимых процедур и триггеров

SQL Server хранит только исходный код хранимых процедур и триггеров. При выполнении хранимой процедуры или триггера в первый раз исходный код компилируется в план выполнения. Если очередной вызов хранимой процедуры или триггера будет инициирован до устаревания плана выполнения, реляционный механизм обнаружит существующий план и использует его повторно. Если план устарел и был удален из памяти, будет создан новый план. Подобным образом выполняется обработка всех инструкций SQL в SQL Server. Основное преимущество хранимых процедур и триггеров SQL Server над пакетами динамического SQL заключается в том, что их инструкции SQL постоянны. Благодаря этому реляционный механизм может с легкостью сопоставлять их с любыми существующими планами выполнения. Это облегчает повторное использование планов хранимых процедур и триггеров.

Планы выполнения хранимых процедур и триггеров обрабатываются отдельно от плана выполнения пакета, вызвавшего хранимую процедуру или приведшего к срабатыванию триггера. Это способствует повторному использованию планов выполнения хранимых процедур и триггеров.

## <a name="execution-plan-caching-and-reuse"></a>Кэширование и повторное использование плана выполнения

В SQL Server есть пул памяти, предназначенный для хранения планов выполнения и буферов данных. Процентное соотношение размера пула, выделенного для планов выполнения и буферов данных, динамически изменяется в зависимости от состояния системы. Часть пула памяти, используемого для хранения планов выполнения, называется кэшем процедур.

В SQL Server планы выполнения состоят из следующих основных компонентов. 

* План запроса. Тело плана выполнения является реентерабельной структурой данных только для чтения, которую могут использовать пользователи в любом количестве. Оно называется планом запроса. План запроса не содержит контекста пользователя. В памяти содержится одна или две копии плана запроса (но не более): одна — для всех последовательных выполнений, а другая — для всех параллельных выполнений. Одна параллельная копия обслуживает все параллельные выполнения независимо от степени параллелизма. 
* Контекст выполнения. Для каждого пользователя, который в настоящий момент выполняет запрос, есть структура данных, относящихся к этому выполнению, например значения параметров. Эта структура данных называется контекстом выполнения. Структуры данных контекста выполнения являются повторно используемыми. Если пользователь выполняет запрос и одна из структур не используется, она повторно инициализируется контекстом нового пользователя. 

![execution_context](../relational-databases/media/execution-context.gif)

В SQL Server при выполнении инструкции SQL реляционный модуль сначала просматривает кэш процедур, проверяя, нет ли в нем плана выполнения для такой же инструкции. Служба SQL Server повторно использует любой план, который найдет, снижая издержки на повторную компиляцию инструкции SQL. Если не найдено ни одного существующего плана выполнения, SQL Server формирует для этого запроса новый план.

SQL Server реализует эффективный алгоритм поиска существующих планов выполнения для любой инструкции SQL. В большинстве систем ресурсы, затрачиваемые на поиск готового плана, всегда меньше ресурсов, затрачиваемых на повторную компиляцию каждой инструкции SQL.

Алгоритмы поиска соответствия инструкции SQL существующему неиспользуемому плану выполнения в кэше требуют, чтобы все ссылки на объекты были полными. Например, для первой из следующих инструкций `SELECT` соответствие существующему плану не будет найдено, а для второго — будет:

```
SELECT * FROM Person;

SELECT * FROM Person.Person;
```

### <a name="removing-execution-plans-from-the-procedure-cache"></a>Удаление планов выполнения из кэша процедур

Планы выполнения остаются в кэше процедур до тех пор, пока для их хранения остается достаточно памяти. При нехватке памяти для определения плана выполнения, который нужно удалить из кэша процедур, ядро СУБД использует подход на основе стоимости. Чтобы принять основанное на стоимости решение, ядро СУБД увеличивает и уменьшает переменную текущей стоимости для каждого плана выполнения, руководствуясь следующими факторами.

Когда пользовательский процесс добавляет в кэш план выполнения, он устанавливает текущую стоимость равной стоимости компиляции исходного запроса. Для нерегламентированных планов выполнения пользовательский процесс устанавливает значение текущей стоимости равным нулю. После этого каждый раз, когда пользовательский процесс ссылается на план выполнения, он сбрасывает текущую стоимость, делая ее равной исходной стоимости компиляции. Для нерегламентированных планов выполнения пользовательский процесс повышает значение текущей стоимости. Для всех планов максимальное значение текущей стоимости равно исходной стоимости компиляции.

Если не хватает памяти, ядро СУБД реагирует, удаляя планы выполнения из кэша процедур. Чтобы определить, какие планы следует удалить, ядро СУБД многократно проверяет состояние каждого плана выполнения и удаляет те из них, для которых текущая стоимость равна нулю. План выполнения с нулевой текущей стоимостью не удаляется автоматически при возникновении нехватки памяти. Он удаляется только после проверки ядром СУБД. Проверяя план выполнения, ядро СУБД приближает текущую стоимость к нулю, уменьшая ее, если в данный момент запрос не использует план.

Ядро СУБД многократно проверяет планы выполнения, пока не удалит достаточное их количество, чтобы удовлетворить требования к памяти. При нехватке памяти стоимость плана выполнения может увеличиться и уменьшиться несколько раз. После ликвидации нехватки памяти ядро СУБД прекращает уменьшать текущую стоимость неиспользуемых планов выполнения, и все планы выполнения остаются в кэше процедур, даже если их стоимость равна нулю.

Ядро СУБД использует монитор ресурсов и пользовательские потоки для освобождения памяти, занимаемой кэшем процедур, при возникновении нехватки памяти. Монитор ресурсов и пользовательские потоки могут проверять выполняющиеся параллельно планы, что позволяет уменьшать текущую стоимость для каждого неиспользуемого плана выполнения. Монитор ресурсов удаляет планы выполнения из кэша процедур при глобальной нехватке памяти. Он освобождает память для принудительного выполнения политик для системной памяти, памяти процессов, памяти пула ресурсов и максимального размера всех кэшей. 

Максимальный размер всех кэшей является функцией от размера буферного пула и не может превышать максимальный объем памяти сервера. Дополнительные сведения о настройке максимального объема памяти сервера см. в описании параметра `max server memory` в статье об `sp_configure`. 

Пользовательские потоки удаляют планы выполнения из кэша процедур, если существует нехватка памяти в одиночном кэше. Они обеспечивают выполнение политик для максимального размера кэша и максимума записей одиночного кэша. 

В следующих примерах показывается, какие планы выполнения удаляются из кэша процедур.

* План выполнения часто используется, поэтому его стоимость никогда не принимает значение ноль. Этот план остается в кэше процедур и не удаляется, пока имеется достаточный объем памяти, а его текущая стоимость не равна нулю.
* Нерегламентированный план выполнения вставляется и не используется до возникновения нехватки памяти. Поскольку нерегламентированные планы выполнения инициализируются текущей стоимостью, которая равна нулю, при проверке плана выполнения ядром СУБД обнаруживается нулевая текущая стоимость, а этот план удаляется из кэша процедур. Нерегламентированный план выполнения с нулевой текущей стоимостью остается в кэше процедур при наличии достаточного объема памяти.


Чтобы вручную удалить отдельный план выполнения или все планы, используйте команду [DBCC FREEPROCCACHE](../t-sql/database-console-commands/dbcc-freeproccache-transact-sql.md).

### <a name="recompiling-execution-plans"></a>Перекомпиляция планов выполнения

Некоторые изменения в базе данных могут привести к тому, что план выполнения станет неэффективным или неправильным в зависимости от нового состояния базы данных. SQL Server обнаруживает изменения, которые приводят к недействительности плана выполнения, и помечает такой план как неправильный. При следующем выполнении данного запроса план должен быть перекомпилирован. План может стать недействительным в следующих случаях. 

* Изменены таблица или представления, на которые ссылается запрос (`ALTER TABLE` или `ALTER VIEW`).
* Изменена одна процедура, которая удалит все планы для этой процедуры из кэша (`ALTER PROCEDURE`).
* Изменены индексы, используемые планом выполнения.
* Обновлена статистика, которая используется планом выполнения и сформирована либо явным образом по `UPDATE STATISTICS`, либо автоматически.
* Удалены индексы, используемые планом выполнения.
* Явный вызов `sp_recompile`.
* Частое изменение ключей (инструкциями `INSERT` или `DELETE` от пользователей, изменяющих таблицу, на которую ссылается запрос).
* Для таблиц с триггерами: значительный рост числа строк в таблицах inserted и deleted.
* Выполнение хранимой процедуры с помощью параметра `WITH RECOMPILE` .

Большинство перекомпиляций необходимы либо для обеспечения правильности работы инструкции, либо для потенциального ускорения работы плана выполнения.

В SQL Server 2000, независимо от того, какая из инструкций пакета вызвала перекомпиляцию, перекомпилируется весь пакет, переданный через хранимую процедуру, триггер, нерегламентированный пакет или подготовленную инструкцию. В SQL Server 2005 и более поздних версий перекомпилируется только инструкция пакета, вызвавшая перекомпиляцию. Из-за этого отличия счетчики перекомпиляции в SQL Server 2000 и более поздних версий несовместимы между собой. Кроме того, в SQL Server 2005 и более поздних версий больше типов перекомпиляции, что вызвано расширением набора возможностей.

Перекомпиляция на уровне инструкции дает выигрыш в производительности, поскольку в большинстве случаев перекомпиляция небольшого числа инструкций и связанных с этим потерь занимает меньше ресурсов в плане использования времени ЦП и затрат на блокировки. Этих потерь, таким образом, удается избежать для остальных инструкций пакета, которые в перекомпиляции не нуждаются.

Событие трассировки `SP:Recompile` приложения SQL Server Profiler выводит сведения о перекомпиляциях на уровне инструкций. В SQL Server 2000 это событие трассировки выдает отчет только о перекомпиляции пакетов. Затем заполняется столбец `TextData` этого события. Таким образом, практика трассировки `SP:StmtStarting` или `SP:StmtCompleted` для получения текста Transact-SQL, который вызвал перекомпиляцию, существовавшая в SQL Server 2000, больше не актуальна.

Событие трассировки `SQL:StmtRecompile` выводит сведения о перекомпиляциях на уровне инструкций. Оно может применяться для трассировки и отладки перекомпиляций. Событие `SP:Recompile` создается только для хранимых процедур и триггеров, а `SQL:StmtRecompile` — для хранимых процедур, триггеров, нерегламентированных пакетов, пакетов, которые выполняются с помощью `sp_executesql`, подготовленных запросов и динамического SQL.

Столбец `EventSubClass` для событий `SP:Recompile` и `SQL:StmtRecompile` содержит код в виде целого числа, обозначающий причину перекомпиляции. В следующей таблице перечислено значение для каждого из этих кодов.

|Значение EventSubClass    |Description    |
|----|----|
|1    |Изменение схемы.    |
|2    |Изменение статистики.    |
|3    |Отложенная компиляция.    |
|4    |Изменение параметра SET.    |
|5    |Изменение временной таблицы.    |
|6    |Изменение удаленного набора строк.    |
|7    |Разрешение`FOR BROWSE` изменено.    |
|8    |Изменение среды уведомлений о запросах.    |
|9    |Изменение секционированного представления.    |
|10    |Изменение параметров курсора.    |
|11    |`OPTION (RECOMPILE)` запрошено    |

> [!NOTE]
> Если для параметра базы данных `AUTO_UPDATE_STATISTICS` с помощью `SET` установлено значение `ON`, запросы перекомпилируются при условии, что они указывают на целевые таблицы или индексированные представления, для которых изменена статистика или в значительной степени изменена кратность со времени последнего выполнения. Это относится к стандартным пользовательским таблицам, временным таблицам, а также таблицам inserted и deleted, созданным триггерами DML. Если на производительность запроса оказывают влияние излишние перекомпиляции, измените значение этого параметра на `OFF`. Если для параметра базы данных `AUTO_UPDATE_STATISTICS` с помощью `SET` установлено значение `OFF`, перекомпиляции по причине изменения статистики или кратности не выполняются, за исключением таблиц inserted и deleted, созданных триггерами DML `INSTEAD OF` . Так как данные таблицы создаются в базе данных tempdb, перекомпиляция запросов, которые обращаются к этим таблицам, зависит от значения параметра `AUTO_UPDATE_STATISTICS` в базе данных tempdb. Обратите внимание, что в SQL Server 2000 запросы при изменении кратности или статистики продолжают выполняться в таблицах триггеров DML inserted и deleted, даже если для указанного параметра задано значение `OFF`.
 

### <a name="parameters-and-execution-plan-reuse"></a>Параметры и повторное использование планов выполнения

Использование параметров, включая маркеры параметров в приложениях ADO, OLE DB и ODBC, может повысить уровень использования планов выполнения.

> [!WARNING] 
> Использование параметров и маркеров параметров для хранения введенных конечными пользователями значений безопаснее, чем сцепление значений в строку, которая затем выполняется с помощью метода API доступа к данным, инструкции `EXECUTE` или хранимой процедуры `sp_executesql` .
 
Единственная разница между следующими двумя инструкциями `SELECT` — в значениях, сравниваемых в предложении `WHERE` :

```
SELECT * 
FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 1;
```
```
SELECT * 
FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 4;
```

Единственная разница между планами выполнения для этих запросов — в значении, хранимом для сравнения со столбцом `ProductSubcategoryID` . Несмотря на то что выявление факта формирования инструкциями одного и того же плана и его повторного использования — основная задача SQL Server, эта служба не всегда может это обнаружить в сложных инструкциях SQL.

Отделение констант от инструкции SQL с помощью параметров помогает реляционному механизму распознавать дубликаты планов. Параметры можно использовать следующими способами. 

* В Transact-SQL используйте `sp_executesql`: 

   ```
   DECLARE @MyIntParm INT
   SET @MyIntParm = 1
   EXEC sp_executesql
     N'SELECT * 
     FROM AdventureWorks2014.Production.Product 
     WHERE ProductSubcategoryID = @Parm',
     N'@Parm INT',
     @MyIntParm
   ```

   Этот метод рекомендуется для скриптов Transact-SQL, хранимых процедур и триггеров, динамически формирующих инструкции SQL. 


* В технологиях ADO, OLE DB и ODBC используются маркеры параметров. Маркеры параметров представляют собой знаки вопроса (?), заменяющие константу в инструкции SQL и привязываемые к программной переменной. Например, в приложении ODBC можно сделать следующее: 

   * использовать параметр `SQLBindParameter` для привязки целочисленной переменной к первому маркеру параметра в инструкции SQL;
   * поместить целочисленное значение в переменную;
   * выполнить инструкцию, указав маркер параметра (?): 

   ```
   SQLExecDirect(hstmt, 
     "SELECT * 
     FROM AdventureWorks2014.Production.Product 
     WHERE ProductSubcategoryID = ?",
     SQL_NTS);
   ```

   Если в приложениях используются маркеры параметров, поставщик OLE DB для SQL Server Native Client и драйвер ODBC для SQL Server Native Client, включенные в состав SQL Server, используют для отправки инструкций в SQL Server процедуру `sp_executesql` . 

* Чтобы проектировать хранимые процедуры, использующие указанные разработчиком параметры.

Если структура приложения не предусматривает явного создания параметров, можно воспользоваться оптимизатором запросов SQL Server для автоматической параметризации некоторых запросов с использованием установленного по умолчанию поведения простой параметризации. В качестве альтернативы можно настроить в оптимизаторе запросов принудительный учет параметризации всех запросов к базе данных, установив для параметра `PARAMETERIZATION` инструкции `ALTER DATABASE` значение `FORCED`.

При включенной принудительной параметризации может также иметь место и простая параметризация. Например, в соответствии с правилами принудительной параметризации следующий запрос не может быть параметризован.

```
SELECT * FROM Person.Address
WHERE AddressID = 1 + 2;
```

Однако он может быть параметризован согласно правилам простой параметризации. В случае неуспешной попытки принудительной параметризации впоследствии производятся попытки использования простой параметризации.

### <a name="simple-parameterization"></a>Простая параметризация

В SQL Server использование параметров или маркеров параметров в инструкциях Transact-SQL увеличивает возможность реляционного модуля применять существующие скомпилированные планы выполнения для новых инструкций SQL.

> [!WARNING] 
> Использование параметров и маркеров параметров для хранения введенных конечными пользователями значений безопаснее, чем сцепление значений в строку, которая затем выполняется с помощью метода API доступа к данным, инструкции `EXECUTE` или хранимой процедуры `sp_executesql` .

Если инструкция SQL выполняется без параметров, SQL Server неявно параметризует инструкцию, чтобы увеличить возможность ее противопоставления существующему плану выполнения. Данный процесс называется простой параметризацией. В SQL Server 2000 этот процесс назывался автоматической параметризацией.

Рассмотрим следующую инструкцию.

```
SELECT * FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 1;
```

Значение 1 в конце инструкции может быть указано в виде параметра. Реляционный механизм строит план выполнения для данного пакета, как если бы параметр был указан на месте значения 1. С помощью этой простой параметризации SQL Server распознает, что следующие две инструкции формируют, по сути, одинаковый план выполнения, и повторно использует первый план для второй инструкции.

```
SELECT * FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 1;
```
```
SELECT * FROM AdventureWorks2014.Production.Product 
WHERE ProductSubcategoryID = 4;
```

В процессе обработки сложных инструкций SQL реляционный механизм может с трудом определять, какие выражения могут быть параметризованы. Чтобы увеличить возможность реляционного модуля находить соответствующие существующие неиспользованные планы выполнения для сложных инструкций SQL, необходимо явно указать параметры с помощью процедуры sp_executesql или маркеров параметров. 

> [!NOTE]
> При использовании арифметических операторов (+, -, *, / или %) для явного или неявного преобразования постоянных значений типов данных int, smallint, tinyint или bigint в типы данных float, real, decimal или numeric SQL Server применяет специальные правила для вычисления типа и точности результатов выражения. Однако эти правила различаются в зависимости от того, параметризован запрос или нет. Таким образом, одинаковые выражения в запросах могут в некоторых случаях давать отличающиеся результаты.

При проведении простой параметризации SQL Server по умолчанию параметризует сравнительно небольшой класс запросов. Однако можно указать, чтобы все запросы в базе данных были параметризованы в соответствии с определенными ограничениями, настроив параметр `PARAMETERIZATION` команды `ALTER DATABASE` на `FORCED`. Уменьшая частоту компиляции запросов, эти действия улучшат производительность баз данных, которые испытывают большие объемы параллельных запросов.

Иначе можно указать параметризацию одного запроса и других, синтаксически равных, но отличающихся значениями параметра, запросов. 


### <a name="forced-parameterization"></a>Принудительная параметризация

Можно переопределить простую параметризацию, используемую по умолчанию в SQL Server, указав, что все инструкции `SELECT`, `INSERT`, `UPDATE`и `DELETE` в базе данных должны быть параметризованы (с учетом некоторых ограничений). Принудительная параметризация активируется путем установки для параметра `PARAMETERIZATION` значения `FORCED` в инструкции `ALTER DATABASE` . Принудительная параметризация может улучшить производительность некоторых баз данных, сократив частоту выполнения компиляции и перекомпиляции запросов. Базы данных, которым может пойти на пользу принудительная параметризация, — это, как правило, те, которым приходится выполнять большое количество параллельных запросов из источников наподобие приложений торговых точек.

Если параметру `PARAMETERIZATION` присвоено значение `FORCED`, любое литеральное значение, представленное в инструкции `SELECT`, `INSERT`, `UPDATE`или `DELETE` , заявленной в любой форме, преобразуется в аргумент в процессе компиляции запроса. Исключениями являются литералы, представленные в следующих конструкциях запроса. 

* Инструкции`INSERT...EXECUTE` .
* Инструкции в теле хранимых процедур, триггеров или определяемых пользователем функций. SQL Server уже использует повторно планы запросов для этих подпрограмм.
* Подготовленные инструкции, которые уже были параметризованы приложением на стороне клиента.
* Инструкции, содержащие вызовы метода XQuery, где метод представлен в контексте, в котором его аргументы обычно параметризуются, например в предложении `WHERE` . Если метод представлен в контексте, где его аргументы не параметризуются, остальная часть инструкции будет параметризована.
* Инструкции внутри курсора Transact-SQL. (Инструкции`SELECT` внутри курсоров API-интерфейса параметризуются.)
* Устаревшие конструкции запроса.
* Любая инструкция, выполняемая в контексте `ANSI_PADDING` или `ANSI_NULLS` со значением `OFF`.
* Инструкции, содержащие более 2 097 литералов, пригодных для параметризации.
* Инструкции, ссылающиеся на переменные, такие как `WHERE T.col2 >= @bb`.
* Инструкции, содержащие указание запроса `RECOMPILE` .
* Инструкции, содержащие предложение `COMPUTE` .
* Инструкции, содержащие предложение `WHERE CURRENT OF` .

Кроме того, в запросах не параметризуются следующие предложения (следует иметь в виду, что не параметризуются только предложения; другие предложения внутри того же запроса могут оказаться пригодными для принудительной параметризации).

* Список <select_list> любой инструкции `SELECT`. Сюда входят списки `SELECT` во вложенных запросах и списки `SELECT` внутри инструкций `INSERT`.
* Инструкции `SELECT` во вложенных запросах, представленные внутри инструкции `IF` .
* Предложения запроса `TOP`, `TABLESAMPLE`, `HAVING`, `GROUP BY`, `ORDER BY`, `OUTPUT...INTO`или `FOR XM`L.
* Аргументы, прямые или в качестве подвыражений, для `OPENROWSET`, `OPENQUERY`, `OPENDATASOURCE`, `OPENXML`или для любого оператора `FULLTEXT` .
* Аргументы pattern и escape_character предложения `LIKE` .
* Аргумент style предложения `CONVERT` .
* Целочисленные константы внутри предложения `IDENTITY` .
* Константы, указанные использованием синтаксиса расширения ODBC.
* Свертываемые выражения, являющиеся аргументами операторов +, -, *, / и %. При определении пригодности для принудительной параметризации SQL Server рассматривает выражение как свертываемое, если верно хотя бы одно из следующих условий.  
  * В выражении не представлены столбцы, переменные или вложенные запросы.  
  * Выражение содержит предложение `CASE` .  
* Аргументы для предложений указаний запросов. Сюда входит аргумент `number_of_rows` указания запроса `FAST` , аргумент `number_of_processors` указания запроса `MAXDOP` и числовой аргумент указания запроса `MAXRECURSION` .


Параметризация происходит на уровне отдельных инструкций Transact-SQL. Иными словами, параметризуются отдельные инструкции в пакете. После компиляции параметризированный запрос выполняется в контексте пакета, в котором он был изначально заявлен. Если план выполнения для запроса кэширован, можно определить, был ли параметризован запрос, обратившись к столбцу sql в динамическом административном представлении sys.syscacheobjects. Если запрос параметризован, имена и типы данных для этих параметров располагаются в этом столбце перед текстом отправленного пакета (например, так: @1 tinyint).

> [!NOTE]
> Имена аргументов произвольны. Пользователи или приложения не должны опираться на какой-либо конкретный порядок именования. Кроме того, в зависимости от версии SQL Server и пакетов обновления могут меняться имена параметров, выбор литералов, подлежащих параметризации, и разбивка параметризованного текста.
 
#### <a name="data-types-of-parameters"></a>Типы данных аргументов

Когда SQL Server параметризует литералы, аргументы преобразовываются в следующие типы данных.

* Целочисленные литералы, размер которых в ином случае соответствовал бы типу данных int, параметризуются в int. Большие целочисленные литералы, являющиеся частью предикатов, которые включают в себя любой оператор сравнения (в том числе <, \<=, =, !=, >, >=, !\<, !>, <>, `ALL`, `ANY`, `SOME`, `BETWEEN` и `IN`), параметризуются в numeric(38,0). Большие литералы, не являющиеся частью предикатов, которые включают в себя операторы сравнения, параметризуются в числовой тип с точностью достаточно большой, чтобы поддержать их размер, и с масштабом 0.
* Числовые литералы с фиксированной запятой, являющиеся частью предикатов, которые включают в себя операторы сравнения, параметризуются в числовой тип с точностью 38 и масштабом достаточно большим, чтобы поддержать их размер. Числовые литералы с фиксированной запятой, не являющиеся частью предикатов, которые включают в себя операторы сравнения, параметризуются в числовой тип с точностью и масштабом достаточно большими, чтобы поддержать их размер.
* Числовые литералы с плавающей запятой параметризуются в float(53).
* Строковые литералы не в формате Юникод параметризуются в varchar(8000), если размер литерала не превышает 8000 символов, и в varchar(max), если он больше 8000 символов.
* Строковые литералы в формате Юникод параметризуются в nvarchar(4000), если размер литерала не превышает 4000 символов Юникода, и в nvarchar(max), если он больше 4000 символов.
* Двоичные литералы параметризуются в varbinary(8000), если размер литерала не превышает 8000 байт. Если он больше 8000 байт, он преобразуется в varbinary(max).
* Денежные литералы параметризуются в тип money.

#### <a name="guidelines-for-using-forced-parameterization"></a>Рекомендации по использованию принудительной параметризации

Устанавливая для параметра `PARAMETERIZATION` значение FORCED, примите во внимание следующие сведения.

* Принудительная параметризация, в сущности, преобразует литеральные константы в запросе в параметры при компиляции запроса. Следовательно, оптимизатор запросов может выбирать не самые оптимальные планы для запросов. В частности, уменьшается вероятность того, что оптимизатор запросов сопоставит запрос с индексированным представлением или индексом по вычисляемому столбцу. Он может также выбирать не самые оптимальные планы для запросов, ориентированных на секционированные таблицы или распределенные секционированные представления. Принудительная параметризация не должна использоваться в средах, в значительной степени опирающихся на индексированные представления и индексы по вычисляемым столбцам. Параметр `PARAMETERIZATION FORCED` должны использовать только опытные администраторы баз данных и лишь после того, как они определят, что такое использование не повредит производительности.
* Распределенные запросы, ссылающиеся на более чем одну базу данных, пригодны для принудительной параметризации, если для параметра `PARAMETERIZATION` задано значение `FORCED` в базе данных, в контексте которой выполняется запрос.
* Установка для параметра `PARAMETERIZATION` на значения `FORCED` производит очистку всех планов запросов из кэша планов в базе данных за исключением тех, которые компилируются, перекомпилируются или выполняются в настоящий момент. Планы для запросов, которые компилируются или выполняются в момент изменения настроек, параметризуются при следующем выполнении запроса.
* Настройка параметра `PARAMETERIZATION` выполняется в режиме в сети и не требует монопольных блокировок на уровне базы данных.
* Текущая настройка параметра `PARAMETERIZATION` сохраняется при повторном присоединении или восстановлении базы данных.

Можно перекрывать поведение принудительной параметризации, предписав выполнение попытки простой параметризации для отдельного запроса, а также всех остальных запросов с таким же синтаксисом, отличающихся только значениями аргументов. Справедливо и обратное: можно потребовать выполнения попытки принудительной параметризации для отдельного набора синтаксически эквивалентных запросов, даже если принудительная параметризация в базе данных отключена. В этих целях используются[структуры планов](../relational-databases/performance/plan-guides.md) .

> [!NOTE]
> Если для параметра `PARAMETERIZATION` задано значение `FORCED`, то отчеты об ошибках могут отличаться от отчетов, формируемых при простой параметризации: число сообщений об ошибках в некоторых случаях больше, чем при простой параметризации, а номера строк, в которых возникают ошибки, могут указываться неверно.
 

### <a name="preparing-sql-statements"></a>Подготовка инструкций SQL

В реляционном механизме SQL Server введена полная поддержка подготовки инструкций SQL перед их выполнением. Если приложению требуется выполнить инструкцию SQL несколько раз, то оно может использовать API базы данных следующим образом. 

* Однократная подготовка инструкции. Инструкция SQL компилируется в план выполнения.
* Ранее скомпилированный план выполнения выполняется каждый раз при необходимости использовать эту инструкцию. Это избавляет от необходимости повторно компилировать инструкцию SQL при каждом последующем выполнении.   
  Подготовка и выполнение инструкций контролируется функциями и методами API. Это не входит в рамки языка Transact-SQL. Модель подготовки и выполнения инструкций SQL поддерживается поставщиком OLE DB для SQL Server Native Client, а также драйвером ODBC для SQL Server Native Client. При запросе на подготовку поставщик или драйвер отправляет в SQL Server инструкцию с запросом на подготовку инструкции. SQL Server компилирует план выполнения и возвращает его дескриптор поставщику или драйверу. При запросе на выполнение поставщик или драйвер отправляет на сервер запрос на выполнение плана, связанного с этим дескриптором. 


В SQL Server подготовленные инструкции нельзя применять для создания временных объектов. Подготовленные инструкции не могут содержать ссылки на системные хранимые процедуры, создающие временные объекты, такие как временные таблицы. Эти процедуры следует выполнять напрямую.

Злоупотребление моделью подготовки и выполнения может отрицательно сказаться на производительности. Если инструкция выполняется только один раз, то для прямого выполнения потребуется только один цикл приема-передачи с сервером. Для подготовки и выполнения инструкции SQL, которая выполняется только один раз, потребуется два таких цикла: один для подготовки и один для выполнения.

Подготовка инструкции более эффективна, если используются маркеры параметров. Предположим, что приложение случайно запросило сведения о продукте из образца базы данных `AdventureWorks` . Эти сведения можно извлечь двумя способами. 

Приложение может выполнять отдельный запрос по каждому необходимому продукту:

```
SELECT * FROM AdventureWorks2014.Production.Product
WHERE ProductID = 63;
```

Второй способ заключается в следующем. 

1. Приложение подготавливает инструкцию, содержащую маркер параметра (?):  
   ```
   SELECT * FROM AdventureWorks2014.Production.Product  
   WHERE ProductID = ?;
   ```
2. Затем оно связывает переменную программы с этим маркером.
3. Каждый раз, когда требуются сведения о продукте, приложение присваивает связанной переменной ключевое значение и выполняет инструкцию.


Второй способ более эффективен, если инструкция выполняется более трех раз.

В SQL Server модель подготовки и выполнения не дает существенного прироста производительности по сравнению с непосредственным выполнением из-за того, каким образом SQL Server повторно использует планы выполнения. В SQL Server предусмотрены эффективные алгоритмы для сопоставления текущих инструкций SQL и планов, созданных для предыдущих случаев выполнения той же инструкции SQL. Если приложение выполняет инструкцию SQL с маркерами параметров несколько раз, то SQL Server будет в дальнейшем использовать уже готовый план выполнения (если только этот план не будет удален из кэша процедур). Впрочем, у модели подготовки и выполнения есть следующие достоинства: 

* поиск плана производится путем идентификации дескриптора, что эффективнее алгоритмов, которые применяются для сопоставления инструкции SQL и существующих планов выполнения;
* приложение может управлять временем создания и повторного использования плана выполнения;
* Модель подготовки и выполнения можно переносить в другие базы данных, включая более ранние версии SQL Server.



## <a name="parallel-query-processing"></a>Параллельная обработка запросов

SQL Server обеспечивает параллельную обработку запросов, оптимизирующую выполнение запросов и операции с индексами на компьютерах, где установлено несколько микропроцессоров (ЦП). Благодаря возможностям параллельной обработки запроса и операций с индексами при помощи нескольких потоков операционной системы SQL Server выполняет эти операции быстрее и эффективнее.

Во время оптимизации запроса SQL Server пытается обнаружить запросы и операции с индексами, которые можно ускорить за счет параллельного выполнения. Для таких запросов SQL Server вставляет в план выполнения операторы обмена, чтобы подготовить запрос к параллельной обработке. Операторы обмена служат для управления процессом, перераспределения данных и управления потоком. К ним относятся логические операторы `Distribute Streams`, `Repartition Streams`и `Gather Streams` (в качестве подтипов), один или несколько из которых появляются в выводе инструкции Showplan плана запроса для параллельного запроса. 

После вставки операторов обмена получается план параллельного выполнения запроса. План параллельного выполнения запроса может использовать несколько потоков. План последовательного выполнения, который используется для обработки непараллельных запросов, использует только один поток. Фактическое количество потоков параллельного выполнения запроса определяется при инициализации плана выполнения запроса и зависит от сложности и степени параллелизма плана. Степень параллелизма определяет максимальное количество используемых ЦП, а не количество используемых потоков. Степень параллелизма устанавливается на уровне сервера и изменяется системной хранимой процедурой sp_configure. Это значение можно переопределить для отдельных инструкций запроса или индекса при помощи указания запроса `MAXDOP` или параметра индекса `MAXDOP` . 

Оптимизатор запросов SQL Server не использует план параллельного выполнения для запроса, если выполняется любое из следующих условий.

* Затраты на последовательное выполнение запроса не настолько высоки, чтобы альтернативой ему считался план параллельного выполнения. 
* План последовательного выполнения признан более быстрым, чем любой другой возможный план параллельного выполнения данного запроса.
* Запрос содержит скалярные или реляционные операторы, параллельное выполнение которых невозможно. Определенные операторы могут привести к выполнению участка запроса или всего плана целиком в последовательном режиме.


### <a name="degree-of-parallelism"></a>Степень параллелизма

SQL Server автоматически обнаруживает высшую степень параллелизма для каждого экземпляра параллельного выполнения запроса или операции языка DDL с индексами. Это осуществляется на основе следующих критериев. 

1. Работает ли SQL Server на компьютере, имеющем более одного микропроцессора или ЦП (таком как симметричный многопроцессорный компьютер (SMP)).  
  Использовать параллельные запросы могут только компьютеры, имеющие более одного ЦП. 

2. Достаточно ли доступных потоков.  
  Каждый запрос или операция с индексами требуют определенного числа потоков, подлежащих выполнению. Для выполнения параллельного плана требуется больше потоков, чем для выполнения последовательного плана, и число запрашиваемых потоков возрастает по мере увеличения степени параллелизма. Когда требование потока параллельного плана для особой степени параллелизма не может быть удовлетворено, ядро СУБД уменьшает степень параллелизма автоматически или полностью отказывается от параллельного плана в указанном контексте рабочей нагрузки. В таком случае начинается выполнение последовательного плана (один поток). 

3. Тип выполняемого запроса или операции с индексами.  
  Операции с индексами, которые создают или перестраивают индекс или удаляют кластеризованный индекс и запросы, интенсивно использующие циклы ЦП, являются лучшими кандидатами для параллельного плана. Например, хорошими кандидатами являются соединения больших таблиц, больших статистических выражений и сортировка больших результирующих наборов. Простые запросы, часто находящиеся в приложениях обработки транзакций, находят дополнительную координацию, запрашиваемую для выполнения запроса в параллельном перевешивании возможного повышения производительности. Чтобы отличить запросы, которые выигрывают от параллелизма, и запросы, которые не выигрывают, ядро СУБД сравнивает предполагаемую стоимость выполняемого запроса или операции с индексами со значением [cost threshold for parallelism](../database-engine/configure-windows/configure-the-cost-threshold-for-parallelism-server-configuration-option.md) . Хотя это не рекомендуется, пользователи могут менять значение по умолчанию (5) при помощи процедуры [sp_configure](../relational-databases/system-stored-procedures/sp-configure-transact-sql.md). 

4. Достаточно ли число строк, подлежащих обработке.  
  Если оптимизатор запросов устанавливает, что число строк слишком мало, то для распространения строк он не вставляет операторы преобразования валюты. Следовательно, операторы обрабатываются последовательно. Обработка операторов в последовательном плане позволяет избежать сценариев, когда стоимость запуска, распределения и координации превышает преимущества, достигнутые параллельной обработкой оператора.

5. Доступна ли статистика распределения.  
  Если наивысшая степень параллелизма невозможна, более низкие степени рассматриваются до того, как отвергается параллельный план.  
  Например, статистика распределения не может вычисляться при создании кластеризованного индекса на представлении, потому что кластеризованный индекс еще не существует. В таком случае ядро СУБД не может предоставить наивысшую степень параллелизма для операции с индексами. Однако некоторые операторы, такие как сортировка и сканирование, по-прежнему могут выигрывать от параллельной обработки.

> [!NOTE]
> Параллельные операции с индексами доступны только в выпусках SQL Server Developer Edition, Evaluation Edition и Enterprise Edition.
 
Во время выполнения ядро СУБД устанавливает, предусматривают ли описанные ранее текущая рабочая нагрузка системы и конфигурация параллельное выполнение. Если параллельное выполнение гарантировано, ядро СУБД устанавливает оптимальное число потоков и распределяет выполнение параллельного плана по этим потокам. Когда запрос или операция с индексами начинает выполнение на нескольких потоках для параллельного выполнения, такое же число потоков используется до тех пор, пока операция не будет завершена. Ядро СУБД перепроверяет оптимальное число решений потоков всякий раз при получении плана выполнения из кэша процедуры. Например, одно выполнение запроса может привести к использованию последовательного плана, последующее выполнение того же запроса может привести к параллельному плану, использующему три потока, а третье выполнение может привести к параллельному плану, использующему четыре потока.

В плане параллельного выполнения запроса операторы вставки, обновления и удаления обрабатываются последовательно. Однако предложение WHERE инструкции UPDATE или DELETE или часть SELECT инструкции INSERT могут обрабатываться параллельно. В таком случае изменения фактических данных последовательно применяются к базе данных.

Статические курсоры и курсоры, управляемые набором ключей, могут быть заполнены параллельными планами выполнения. Однако поведение динамических курсоров может поддерживаться только последовательным выполнением. Оптимизатор запросов всегда формирует последовательный план выполнения для запроса, являющегося частью динамического курсора.

#### <a name="overriding-degrees-of-parallelism"></a>Переопределение степеней параллелизма

Чтобы ограничить число процессоров для использования в выполнении параллельного плана, можно использовать параметр конфигурации сервера [max degree of parallelism](../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option.md) ([ALTER DATABASE SCOPED CONFIGURATION](../t-sql/statements/alter-database-scoped-configuration-transact-sql.md) в [!INCLUDE[ssSDS_md](../includes/sssds-md.md)] ). Для отдельного запроса и инструкций операции с индексами параметр max degree of parallelism можно переопределить, задав указание запроса MAXDOP или параметр индекса MAXDOP. Параметр MAXDOP предоставляет улучшенное управление через отдельные запросы и операции с индексами. Например, можно использовать параметр MAXDOP для управления, увеличивая или уменьшая число процессоров, выделенных для операции с индексами в сети. Таким образом, можно сбалансировать ресурсы, используемые операцией с индексами с теми текущими пользователями. Назначение параметру max degree of parallelism значения 0 позволяет SQL Server использовать все доступные процессоры (максимально допустимое количество процессоров равно 64) при выполнении параллельного плана. Назначение параметру MAXDOP значения 0 для запросов и индексов позволяет SQL Server использовать все доступные процессоры (максимально допустимое количество процессоров равно 64) для данных запросов и индексов при выполнении параллельного плана.


### <a name="parallel-query-example"></a>Пример параллельного запроса

В нижеследующем запросе подсчитывается количество заказов, размещенных в течение указанного квартала, начиная с 1 апреля 2000, в которых хотя бы один элемент из списка заказанных товаров был получен заказчиком позже фиксированной даты. В этом запросе представлен подсчет таких заказов, сгруппированных в соответствии со срочностью каждого заказа и отсортированных в возрастающем порядке. 

В этом примере используются теоретические имена таблицы и столбцов.

```
SELECT o_orderpriority, COUNT(*) AS Order_Count
FROM orders
WHERE o_orderdate >= '2000/04/01'
   AND o_orderdate < DATEADD (mm, 3, '2000/04/01')
   AND EXISTS
         (
          SELECT *
            FROM    lineitem
            WHERE l_orderkey = o_orderkey
               AND l_commitdate < l_receiptdate
         )
   GROUP BY o_orderpriority
   ORDER BY o_orderpriority
```

Предположите, что нижеследующие индексы определены в таблицах lineitem и orders.

```
CREATE INDEX l_order_dates_idx 
   ON lineitem
      (l_orderkey, l_receiptdate, l_commitdate, l_shipdate)

CREATE UNIQUE INDEX o_datkeyopr_idx
   ON ORDERS
      (o_orderdate, o_orderkey, o_custkey, o_orderpriority)
```

Вот один из возможных параллельных планов, созданный для запроса, показанного выше:

```
|--Stream Aggregate(GROUP BY:([ORDERS].[o_orderpriority])
                  DEFINE:([Expr1005]=COUNT(*)))
    |--Parallelism(Gather Streams, ORDER BY:
                  ([ORDERS].[o_orderpriority] ASC))
         |--Stream Aggregate(GROUP BY:
                  ([ORDERS].[o_orderpriority])
                  DEFINE:([Expr1005]=Count(*)))
              |--Sort(ORDER BY:([ORDERS].[o_orderpriority] ASC))
                   |--Merge Join(Left Semi Join, MERGE:
                  ([ORDERS].[o_orderkey])=
                        ([LINEITEM].[l_orderkey]),
                  RESIDUAL:([ORDERS].[o_orderkey]=
                        [LINEITEM].[l_orderkey]))
                        |--Sort(ORDER BY:([ORDERS].[o_orderkey] ASC))
                        |    |--Parallelism(Repartition Streams,
                           PARTITION COLUMNS:
                           ([ORDERS].[o_orderkey]))
                        |         |--Index Seek(OBJECT:
                     ([tpcd1G].[dbo].[ORDERS].[O_DATKEYOPR_IDX]),
                     SEEK:([ORDERS].[o_orderdate] >=
                           Apr  1 2000 12:00AM AND
                           [ORDERS].[o_orderdate] <
                           Jul  1 2000 12:00AM) ORDERED)
                        |--Parallelism(Repartition Streams,
                     PARTITION COLUMNS:
                     ([LINEITEM].[l_orderkey]),
                     ORDER BY:([LINEITEM].[l_orderkey] ASC))
                             |--Filter(WHERE:
                           ([LINEITEM].[l_commitdate]<
                           [LINEITEM].[l_receiptdate]))
                                  |--Index Scan(OBJECT:
         ([tpcd1G].[dbo].[LINEITEM].[L_ORDER_DATES_IDX]), ORDERED)
```

![parallel_plan](../relational-databases/media/parallel-plan.gif) План запроса со степенью параллелизма 4, использует соединение двух таблиц.

Иллюстрация демонстрирует план оптимизатора запросов, выполняемый со степенью параллелизма, равной 4, и включающий соединение двух таблиц.

Параллельный план содержит три оператора `Parallelism` . Оба оператора, `Index Seek` индекса `o_datkey_ptr` и `Index Scan` индекса `l_order_dates_idx` , выполняются параллельно. В результате образуется несколько исключающих потоков. Это может быть определено из ближайших операторов Parallelism над операторами `Index Scan` и `Index Seek` соответственно. Оба перераспределяют тип обмена. То есть они всего лишь перегруппируют данные между потоками и выдают в результате столько же потоков на выходе, сколько их было на входе. Количество потоков равно степени параллелизма.

Оператор `Parallelism `над оператором `l_order_dates_idx` `Index Scan` перераспределяет свои входные потоки с использованием значения `L_ORDERKEY` в качестве ключа. В этом случае те же значения `L_ORDERKEY` выдаются в том же выходном потоке. Одновременно в потоках выхода поддерживается порядок в столбце `L_ORDERKEY` для соответствия входному требованию оператора `Merge Join` .

Оператор `Parallelism` над оператором `Index Seek` перераспределяет свои входные потоки с использованием значения `O_ORDERKEY`. Так как его входные данные не сортируются по значениям столбца `O_ORDERKEY` , а он является столбцом соединения в операторе `Merge Join` , оператор Sort между операторами `Parallelism` и `Merge Join` обеспечивает сортировку входных данных для оператора `Merge Join` по столбцам соединения. Оператор `Sort` , как и оператор `Merge Join` , выполняется параллельно.

Первый оператор `Parallelism` соединяет результаты из нескольких потоков в один. Результаты частичной статистической обработки, выполняемой оператором `Stream Aggregate` под оператором `Parallelism` , затем собираются в единое значение `SUM` для каждого отдельного значения `O_ORDERPRIORITY` в операторе `Stream Aggregate` над оператором `Parallelism` . Поскольку этот план состоит из двух сегментов обмена со степенью параллелизма, равной 4, он использует восемь потоков.


### <a name="parallel-index-operations"></a>Параллельные операции с индексами

Планы запросов, построенные для операций создания или перестроения индекса либо удаления кластеризованного индекса, поддерживают возможность параллельной, многопоточной обработки на многопроцессорных компьютерах.

> [!NOTE]
> Параллельные операции с индексами доступны только в выпуске SQL Server 2008 Enterprise Edition.
 
В SQL Server используются одни и те же алгоритмы определения степени параллелизма (общего числа запускаемых отдельных потоков) как для операций с индексами, так и для других запросов. Максимальная степень параллелизма для операции с индексом определяется параметром конфигурации сервера [max degree of parallelism](../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option.md) . Значение max degree of parallelism можно переопределять для отдельных операций с индексами путем настройки параметра индекса MAXDOP в инструкциях CREATE INDEX, ALTER INDEX, DROP INDEX и ALTER TABLE.

Когда ядро СУБД строит план выполнения индекса, количество параллельных операций устанавливается на наиболее низкое из перечисленных ниже значений. 

* Число микропроцессоров (ЦП) в компьютере.
* Число, указанное в качестве параметра конфигурации сервера max degree of parallelism.
* Число ЦП, не превышающих порог загруженности рабочими потоками SQL Server.


Например, на компьютере с восемью ЦП, на котором значение max degree of parallelism равно 6, для операции с индексом создается не более шести параллельных потоков. Если пять ЦП на компьютере загружены рабочими потоками SQL Server сверх порогового значения при создании плана выполнения индекса, в этом плане задаются только три параллельных потока.

Главные фазы параллельных операций с индексами таковы. 

* Координирующий поток быстро и случайным образом просматривает таблицу для оценки распределения ключей индекса. Координирующий поток устанавливает ключевые границы, образующие число диапазонов ключей, равное степени параллелизма, где каждый диапазон по оценке должен покрывать примерно одинаковое число строк. Например, если в таблице 4 миллиона строк, а степень параллелизма равна 4, координирующий поток определит ключевые значения, ограничивающие четыре набора строк по миллиону каждый. Если для использования всех ЦП невозможно установить достаточное число диапазонов ключей, степень параллелизма соответствующим образом снижается.  
* Координирующий поток запускает число потоков, равное степени параллелизма операций, и ожидает завершения работы этих потоков. Каждый из потоков просматривает базовую таблицу, используя фильтр, получающий только строки с ключевыми значениями в пределах диапазона, назначенного данному потоку. Каждый поток выполняет построение индексной структуры для строк в своем диапазоне ключей. В случае секционированного индекса каждый из потоков выполняет построение указанного числа секций. Одни и те же секции между несколькими потоками не разделяются.  
* После завершения работы всех параллельных потоков координирующий поток связывает компоненты индекса в единый индекс. Эта фаза применяется только для операций с индексами в сети.

В отдельных инструкциях `CREATE TABLE` или `ALTER TABLE` могут содержаться несколько ограничений, требующих создания индекса. Такие множественные операции по созданию индекса выполняются последовательно, хотя каждая из них может быть параллельной операцией на многопроцессорном компьютере.


## <a name="distributted-query-architecture"></a>Архитектура распределенных запросов

Microsoft SQL Server поддерживает два метода обращения к разнородным источникам данных OLE DB в инструкциях языка Transact-SQL.

* Имена связанных серверов  
  Системные хранимые процедуры `sp_addlinkedserver` и `sp_addlinkedsrvlogin` используются для задания серверного имени источнику данных OLE DB. К объектам на этих связанных серверах можно обращаться в инструкциях языка Transact-SQL по четырехкомпонентным именам. Например, если имя связанного сервера `DeptSQLSrvr` определено для другого экземпляра SQL Server, для обращения к таблице на таком сервере используется следующая инструкция: 
  
  ```
  SELECT JobTitle, HireDate 
  FROM DeptSQLSrvr.AdventureWorks2014.HumanResources.Employee;
  ```

   Имя связанного сервера можно также указать в инструкции `OPENQUERY` для открытия набора строк из источника данных OLE DB. К этому набору строк можно обращаться в инструкциях языка Transact-SQL так же, как и к таблице. 

* Имена нерегламентированных соединителей  
  Для нечастых обращений к источнику данных используются функции `OPENROWSET` или `OPENDATASOURCE` , которым задаются данные, необходимые для подключения к связанному серверу. Затем можно обращаться к набору строк в инструкциях языка Transact-SQL тем же путем, что и к таблице. 
  
  ```
  SELECT *
  FROM OPENROWSET('Microsoft.Jet.OLEDB.4.0',
        'c:\MSOffice\Access\Samples\Northwind.mdb';'Admin';'';
        Employees);
  ```

В SQL Server для коммуникации между реляционным модулем и подсистемой хранилища используется технология OLE DB. Реляционный модуль разбивает каждую инструкцию языка Transact-SQL на последовательные операции над простыми наборами строк OLE DB, открываемые подсистемой хранилища из базовых таблиц. Это означает, что реляционный механизм может также открывать простые наборы строк OLE DB на любом источнике данных OLE DB.  
![oledb_storage](../relational-databases/media/oledb-storage.gif)  
В реляционном механизме используется прикладной программный интерфейс (API) OLE DB для открытия наборов строк на связанных серверах, выборки строк и управления транзакциями.

Для каждого источника данных OLE DB, доступ к которому осуществляется как к связанному серверу, на сервере с запущенной службой SQL Server должен быть поставщик OLE DB. Набор операций языка Transact-SQL, которые можно использовать с конкретным источником данных OLE DB, зависит от возможностей поставщика OLE DB.

Для каждого экземпляра SQL Server участники предопределенной роли сервера `sysadmin` могут включать или отключать использование нерегламентированных имен соединителей для поставщика OLE DB с помощью свойства SQL Server `DisallowAdhocAccess` . Если нерегламентированный доступ включен, любой пользователь, зарегистрированный на данном экземпляре, может выполнять инструкции SQL, содержащие имена нерегламентированных соединителей, обращающиеся к любым источникам данных в сети, доступ к которым возможен посредством данного поставщика OLE DB. Для управления доступом к источникам данных члены роли `sysadmin` могут отключить нерегламентированный доступ к определенному поставщику OLE DB, ограничивая таким образом пользователям доступ лишь к тем источникам данных, обращение к которым производится по именам связанных серверов, определенным администраторами. По умолчанию нерегламентированный доступ включен для поставщика OLE DB SQL Server и отключен для всех остальных поставщиков OLE DB.

Распределенные запросы могут давать пользователям доступ к другому источнику данных (например, файлам, нереляционным источникам данных типа службы Active Directory и т. д.) с помощью контекста безопасности учетной записи Microsoft Windows, под которой запущена служба SQL Server. Служба SQL Server может правильно олицетворять имена входа Windows, однако для имен входа SQL Server это невозможно. Это потенциально может открыть пользователю распределенного запроса доступ к другому источнику данных, для которого у него нет разрешения, но у учетной записи, под которой запущена служба SQL Server, такое разрешение есть. Для указания конкретных имен входа, которым будет разрешен доступ к соответствующему связанному серверу, используется процедура `sp_addlinkedsrvlogin` . Для нерегламентированных имен такой контроль недоступен, поэтому следует проявлять осторожность при включении нерегламентированного доступа к поставщику OLE DB.

По возможности SQL Server принудительно отправляет реляционные операции (соединения, ограничения, проекции, сортировки и группировки по операциям) к источнику данных OLE DB. По умолчанию SQL Server не просматривает базовую таблицу и не выполняет реляционных операций самостоятельно. Эта служба запрашивает поставщика OLE DB, чтобы определить уровень поддерживаемой им грамматики SQL, и на основе этих данных направляет поставщику максимально возможное число реляционных операций. 

SQL Server указывает поставщику OLE DB механизм возвращения статистики распределения ключевых значений в пределах источника данных OLE DB. Это позволяет оптимизатору запросов SQL Server лучше анализировать закономерность в соответствии данных из источника данных требованиям каждой инструкции SQL, что увеличивает способность оптимизатора создавать оптимальные планы выполнения. 


## <a name="query-processing-enhancements-on-partitioned-tables-and-indexes"></a>Улучшенные возможности обработки запросов для секционированных таблиц и индексов

В версии SQL Server 2008 повышена производительность обработки запросов к секционированным таблицам для нескольких параллельных планов, изменен способ представления параллельных и последовательных планов и улучшены сведения о секционировании, содержащиеся в планах времени компиляции и времени выполнения. В этом разделе описываются названные улучшения, содержится справочник об интерпретации планов выполнения запросов таблиц секционирования и индексов и дополнительные сведения об улучшении производительности запросов к секционированным объектам. 

> [!NOTE]
> Секционированные таблицы и индексы поддерживаются только в выпусках SQL Server Enterprise Edition, Developer Edition и Evaluation Edition.

### <a name="new-partition-aware-seek-operation"></a>Новая операция поиска, учитывающая секционирование

В SQL Server внутреннее представление секционированной таблицы изменено таким образом, что таблица представляется обработчику запросов как индекс по нескольким столбцам с `PartitionID` в качестве начального столбца. `PartitionID` представляет собой скрытый внутренний вычисляемый столбец для представления `ID` секции, содержащей определенную строку. Например, предположим, что таблица T, определенная как `T(a, b, c)`, секционирована по столбцу a и содержит кластеризованный индекс по столбцу b. В SQL Server эта секционированная таблица обрабатывается внутри как несекционированная таблица со схемой `T(PartitionID, a, b, c)` и кластеризованным индексом по составному ключу `(PartitionID, b)`. Это позволяет оптимизатору запросов выполнять операции поиска, основанные на `PartitionID` , по любой секционированной таблице или индексу. 

Устранение секций теперь осуществляется в этой операции поиска.

Кроме того, оптимизатор запросов расширен таким образом, что операция поиска или просмотра с одним условием может быть выполнена по `PartitionID` (в качестве логического начального столбца) и, возможно, по другим ключевым столбцам индекса, а затем может быть выполнен поиск второго уровня с другим условием по одному дополнительному столбцу или более для каждого уникального значения, удовлетворяющего операции поиска первого уровня. Операция, называемая "просмотр с пропуском", позволяет оптимизатору запросов выполнять операцию поиска или просмотра по одному условию для определения секций, к которым будет осуществляться доступ, и операцию поиска индекса второго уровня с помощью этого оператора для выборки строк из этих секций, удовлетворяющих другому условию. Например, рассмотрим следующий запрос.

```
SELECT * FROM T WHERE a < 10 and b = 2;
```

В данном примере, предположим, таблица T, определенная как `T(a, b, c)`, секционирована по столбцу a и содержит кластеризованный индекс по столбцу b. Границы секции для таблицы T определены следующей функцией секционирования:

```
CREATE PARTITION FUNCTION myRangePF1 (int) AS RANGE LEFT FOR VALUES (3, 7, 10);
```

Для разрешения запроса обработчик запросов выполняет операцию поиска первого уровня для нахождения каждой секции, содержащей строки, удовлетворяющие условию `T.a < 10`. Это позволяет выявить секции, к которым необходимо получить доступ. В каждой выявленной секции обработчик выполняет поиск второго уровня по кластеризованному индексу по столбцу b для нахождения строк, удовлетворяющих условию `T.b = 2` и `T.a < 10`. 

На следующем рисунке изображено логическое представление операции просмотра с пропуском. На нем изображена таблица T с данными в столбцах a и b. Секции пронумерованы от 1 до 4, а границы секций показаны вертикальными штриховыми линиями. Операция поиска первого уровня для секций (на рисунке не показана) определила, что секции 1, 2 и 3 удовлетворяют условию поиска, предполагаемого секционированием, определенным для таблицы и предиката по столбцу a. то есть `T.a < 10`. Путь, пройденный частью операции просмотра с пропуском, поиском второго уровня, изображен изогнутой линией. Фактически операция просмотра с пропуском выполняет поиск строк, удовлетворяющих условию `b = 2`в каждой их этих секций. Общие затраты на выполнение операции просмотра с пропуском соответствуют трем отдельным поискам по индексу.   
![skip_scan](../relational-databases/media/skip-scan.gif)


### <a name="displaying-partitioning-information-in-query-execution-plans"></a>Отображение сведений о секционировании в планах выполнения запросов

Планы выполнения запросов в секционированных таблицах и индексах могут быть исследованы с помощью инструкций `SET` языка Transact-SQL, `SET SHOWPLAN_XML` или `SET STATISTICS XML`, либо с помощью графического представления плана выполнения в среде SQL Server Management Studio. Например, план выполнения времени компиляции можно отобразить, щелкнув *Показать предполагаемый план выполнения* на панели инструментов редактора запросов, а план времени выполнения — щелкнув *Включить действительный план выполнения*. 

С помощью этих средств можно получить следующую информацию:

* операции, такие как `scans`, `seeks`, `inserts`, `updates`, `merges`и `deletes` , которые осуществляют доступ к таблицам и индексам;
* секции, к которым запрос получает доступ — например, в планах времени выполнения приведено общее число секций, к которым получен доступ, и диапазоны смежных секций, к которым получен доступ;
* когда операция просмотра с пропуском используется в операции поиска или просмотра для получения данных из одной секции или более.

#### <a name="partition-information-enhancements"></a>Улучшенные возможности информации о секции

SQL Server содержит расширенные сведения о секционировании как для планов времени компиляции, так и для планов времени выполнения. Планы выполнения теперь содержат следующую информацию.

* Дополнительный атрибут `Partitioned` указывает, что оператор, например `seek`, `scan`, `insert`, `update`, `merge`или `delete`, выполняется в отношении секционированной таблицы.  
* Новый элемент `SeekPredicateNew` с вложенным элементом `SeekKeys` , содержащим `PartitionID` в качестве начального ключевого столбца индекса и условия фильтра, определяющие операции поиска по диапазону в `PartitionID`. Наличие двух вложенных элементов `SeekKeys` указывает на то, что в отношении `PartitionID` используется операция просмотра с пропуском.   
* Сводные данные об общем числе секций, к которым получен доступ. Эта информация доступна только в планах времени выполнения. 

Для демонстрации отображения этой информации как в графическом плане выполнения, так и в отчете инструкции XML Showplan рассмотрим следующий запрос по секционированной таблице `fact_sales`. Этот запрос обновляет данные в двух секциях. 

```
UPDATE fact_sales
SET quantity = quantity * 2
WHERE date_id BETWEEN 20080802 AND 20080902;
```

На следующем рисунке показаны свойства оператора `Clustered Index Seek` в плане выполнения времени компиляции для этого запроса. Определение таблицы `fact_sales` и определение секции см. в подразделе "Пример" в этом разделе.  
![clustered_index_seek](../relational-databases/media/clustered-index-seek.gif)

#### <a name="partitioned-attribute"></a>Атрибут Partitioned

Когда оператор, такой как `Index Seek` , выполняется по секционированной таблице или индексу, в планах времени компиляции и времени выполнения появляется атрибут `Partitioned` со значением `True` (1). Этот атрибут не отображается, если его значение установлено как `False` (0).

Атрибут `Partitioned` может встречаться в следующих физических и логических операторах:  
* `Table Scan`  
* `Index Scan`  
* `Index Seek`  
* `Insert`  
* `Update`  
* `Delete`  
* `Merge`  

Как показано на предыдущей иллюстрации, этот атрибут отображается в свойствах оператора, в котором он определен. В отчете инструкции XML Showplan этот атрибут появляется как `Partitioned="1"` в узле `RelOp` оператора, в котором он определен.

#### <a name="new-seek-predicate"></a>Предикат New Seek

В выводе инструкции XML Showplan элемент `SeekPredicateNew` появляется в операторе, в котором он определен. Он может содержать до двух экземпляров вложенного элемента `SeekKeys` . Первый элемент `SeekKeys` определяет операцию поиска первого уровня на уровне идентификатора секции логического индекса. То есть эта операция поиска определяет секции, к которым должен быть осуществлен доступ для удовлетворения условий запроса. Второй элемент `SeekKeys` определяет часть операции просмотра с пропуском, поиск второго уровня, который производится в каждой секции, определенной поиском первого уровня. 

#### <a name="partition-summary-information"></a>Сводные данные по секциям

В планах времени выполнения сводка по секциям содержит данные о числе секций, к которым осуществлен доступ, и фактический перечень секций, к которым осуществлен доступ. С помощью этих данных можно проверить, к правильным ли секциям обращается запрос и исключены ли из рассмотрения остальные секции.

Предоставляется следующая информация: `Actual Partition Count`и `Partitions Accessed`. 

`Actual Partition Count` — это общее число секций, к которым запрос получает доступ.

`Partitions Accessed`в выводе инструкции XML Showplan — это сводные данные по секциям, которые появляются в новом элементе `RuntimePartitionSummary` в узле `RelOp` оператора, в котором он определен. В следующем примере показано содержимое элемента `RuntimePartitionSummary` , указывающее, что получен доступ только к двум секциям (секции 2 и 3).
```
<RunTimePartitionSummary>

    <PartitionsAccessed PartitionCount="2" >

        <PartitionRange Start="2" End="3" />

    </PartitionsAccessed>

</RunTimePartitionSummary>
```

#### <a name="displaying-partition-information-by-using-other-showplan-methods"></a>Отображение сведений о секционировании с помощью других методов Showplan

Методы Showplan `SHOWPLAN_ALL`, `SHOWPLAN_TEXT`и `STATISTICS PROFILE` не формируют сведения о секционировании, описанные в этом разделе, за следующим исключением. Как часть предиката `SEEK` , секции, к которым необходимо получить доступ, обозначаются предикатом по диапазону в вычисляемом столбце, представляющем идентификатор секций. В следующем примере показан предикат `SEEK` для оператора `Clustered Index Seek` . К секциям 2 и 3 происходит обращение, и оператор поиска производит фильтрацию по строкам, удовлетворяющим условию `date_id BETWEEN 20080802 AND 20080902`.
```
|--Clustered Index Seek(OBJECT:([db_sales_test].[dbo].[fact_sales].[ci]), 

        SEEK:([PtnId1000] >= (2) AND [PtnId1000] \<= (3) 

                AND [db_sales_test].[dbo].[fact_sales].[date_id] >= (20080802) 

                AND [db_sales_test].[dbo].[fact_sales].[date_id] <= (20080902)) 

                ORDERED FORWARD)
```

#### <a name="interpreting-execution-plans-for-partitioned-heaps"></a>Интерпретация планов выполнения для секционированной кучи

Секционированная куча обрабатывается как логический индекс по идентификатору секции. Устранение секций на секционированной куче представлено в плане выполнения в виде оператора `Table Scan` с предикатом `SEEK` по идентификатору секции. Следующий пример отображает сведения Showplan:
```
|-- Table Scan (OBJECT: ([db].[dbo].[T]), SEEK: ([PtnId1001]=[Expr1011]) ORDERED FORWARD)
```

#### <a name="interpreting-execution-plans-for-collocated-joins"></a>Интерпретация планов выполнения для выровненных соединений

Выравнивание соединений может возникать, когда две таблицы секционированы с использованием одной и той же функции или эквивалентных функций секционирования и столбцы секционирования из обеих сторон соединения указываются в условии соединения запроса. Оптимизатор запросов может сформировать план, в котором секции каждой таблицы, имеющие равные идентификаторы, соединяются отдельно. Выровненные соединения могут выполняться быстрее, чем невыровненные, поскольку требуют меньшего объема памяти и времени обработки. Оптимизатор выбирает невыровненный план или выровненный план исходя из расчета затрат.

В выровненных планах соединение `Nested Loops` считывает одну или более секций для соединяемых таблиц или индексов с внутренней стороны. Цифры в операторах `Constant Scan` представляют собой номера секций. 

Если для секционированных таблиц или индексов формируются параллельные планы для выровненных соединений, то между операторами соединения `Constant Scan` и `Nested Loops` появляется оператор Parallelism. В этом случае каждый из нескольких потоков на внешней стороне соединения считывает и работает на разных секциях. 

Следующий рисунок демонстрирует план параллельных запросов для выровненных соединений.   
![colocated_join](../relational-databases/media/colocated-join.gif)


#### <a name="parallel-query-execution-strategy-for-partitioned-objects"></a>Стратегия выполнения параллельных запросов для секционированных объектов

Обработчик запросов использует стратегию параллельного выполнения для запросов, производящих выборку из секционированных объектов. В рамках стратегии выполнения обработчик запросов определяет секции таблицы, необходимые для запроса, и долю потоков, которую следует выделить для каждой секции. В большинстве случаев обработчик запросов выделяет равное или почти равное количество потоков для каждой секции, а затем выполняет запрос параллельно на всех секциях. В следующих параграфах более подробно разъясняется выделение потоков.  
![thread1](../relational-databases/media/thread1.gif) Если число потоков меньше числа секций, обработчик запросов присваивает по одному потоку каждой отдельной секции, изначально оставляя несколько секций без назначенных потоков. Когда поток завершает работу с секцией, обработчик запросов присваивает его следующей секции. Это продолжается до тех пор, пока у каждой секции не будет по одному потоку. Это единственный случай, когда обработчик запросов перераспределяет потоки к другим секциям.  
Показывает поток, повторно назначенный после завершения. Если число потоков равно числу секций, обработчик запросов присваивает каждой секции по одному потоку. После того как поток заканчивает работу, он не перераспределяется к другой секции.  
![thread2](../relational-databases/media/thread2.gif)  
Если число потоков больше числа секций, обработчик запросов присваивает каждой секции одинаковое число потоков. Если число потоков не кратно числу секций, обработчик запросов выделяет по одному дополнительному потоку для некоторых секций, чтобы были использованы все доступные потоки. Следует заметить, что если существует только одна секция, ей будут присвоены все потоки. На диаграмме, приведенной ниже, показаны четыре секции и 14 потоков. Каждой секции присвоено по 3 потока, у двух секций есть дополнительные потоки; всего присвоено 14 потоков. После того как поток заканчивает работу, он не перераспределяется к другой секции.  
![thread3](../relational-databases/media/thread3.gif)  
Хотя в приведенных выше примерах показывается достаточно прямолинейный способ распределения потоков, реальная стратегия более сложна; она учитывает другие факторы, которые возникают при выполнении запроса. Например, если таблица секционирована и имеет кластеризованный индекс на столбце А, а в запросе используется предложение предиката `WHERE A IN (13, 17, 25)`, обработчик запросов выделит один или несколько потоков каждому из трех искомых значений из значений поиска (A=13, A=17 и A=25), а не каждой секции таблицы. Запрос необходимо выполнить только в секциях, содержащих эти значения; если все предикаты поиска будут расположены в одной секции таблицы, все потоки будут присвоены этой секции.

Другой пример: предположим, что таблица имеет четыре секции для столбца A с граничными точками (10, 20, 30), индекс на столбце B, а в запросе содержится предикат `WHERE B IN (50, 100, 150)`. Так как секции таблицы основаны на значениях A, значения столбца B могут появляться во всех секциях таблицы. Поэтому обработчик запросов будет искать каждое из этих трех значений столбца B (50, 100, 150) в каждой из четырех секций таблицы. Обработчик запросов распределит потоки пропорционально, чтобы эти 12 просмотров запроса могли выполняться параллельно.

|Секции таблицы основаны на столбце А    |Операции поиска для столбца B в каждой секции таблицы |
|----|----|
|Секция таблицы 1: A < 10     |B = 50, B = 100, B = 150 |
|Секция таблицы 2: A >= 10 AND A < 20     |B = 50, B = 100, B = 150 |
|Секция таблицы 3: A >= 20 AND A < 30     |B = 50, B = 100, B = 150 |
|Секция таблицы 4: A >= 30     |B = 50, B = 100, B = 150 |

### <a name="best-practices"></a>Рекомендации

Для увеличения производительности запросов, обращающихся к большому количеству данных из больших секционированных таблиц и индексов, предлагаются следующие рекомендации.

* Распределяйте каждую секцию по нескольким дискам.
* Чтобы снизить затраты на ввод-вывод, по возможности используйте сервер с достаточным объемом основной памяти, вмещающей секции, требующие частого доступа, или все секции.
* Если данные, по которым выполняется запрос, не помещаются в памяти, рекомендуется выполнить сжатие таблиц и индексов. Это позволит снизить затраты на ввод-вывод.
* Чтобы в полной мере реализовать возможности параллельной обработки запросов, используйте сервер с быстрыми процессорами и как можно большим числом процессорных ядер.
* Обеспечьте достаточную пропускную способность контроллера ввода-вывода для сервера. 
* Чтобы в полной мере реализовать возможности оптимизированного просмотра сбалансированного дерева, создайте кластеризованный индекс по каждой большой секционированной таблице.
* При массовой загрузке данных в секционированные таблицы следуйте рекомендациям [этого технического документа](http://go.microsoft.com/fwlink/?LinkId=154561).

### <a name="example"></a>Пример

В следующем примере показано создание тестовой базы данных, состоящей из одной таблицы с семью секциями. Чтобы при выполнении запросов в этом примере просматривать сведения о секционировании в планах времени компиляции и времени выполнения, следует пользоваться инструментами, описанными ранее. 

> [!NOTE]
> В данном примере в таблицу вставляется более 1 миллиона строк. В зависимости от имеющегося оборудования выполнение данного примера может занять несколько минут. Перед выполнением этого примера следует убедиться, что на диске 1,5 ГБ свободного места. 
 
```
USE master;
GO
IF DB_ID (N'db_sales_test') IS NOT NULL
    DROP DATABASE db_sales_test;
GO
CREATE DATABASE db_sales_test;
GO
USE db_sales_test;
GO
CREATE PARTITION FUNCTION [pf_range_fact](int) AS RANGE RIGHT FOR VALUES 
(20080801, 20080901, 20081001, 20081101, 20081201, 20090101);
GO
CREATE PARTITION SCHEME [ps_fact_sales] AS PARTITION [pf_range_fact] 
ALL TO ([PRIMARY]);
GO
CREATE TABLE fact_sales(date_id int, product_id int, store_id int, 
    quantity int, unit_price numeric(7,2), other_data char(1000))
ON ps_fact_sales(date_id);
GO
CREATE CLUSTERED INDEX ci ON fact_sales(date_id);
GO
PRINT 'Loading...';
SET NOCOUNT ON;
DECLARE @i int;
SET @i = 1;
WHILE (@i<1000000)
BEGIN
    INSERT INTO fact_sales VALUES(20080800 + (@i%30) + 1, @i%10000, @i%200, RAND() * 25, (@i%3) + 1, '');
    SET @i += 1;
END;
GO
DECLARE @i int;
SET @i = 1;
WHILE (@i<10000)
BEGIN
    INSERT INTO fact_sales VALUES(20080900 + (@i%30) + 1, @i%10000, @i%200, RAND() * 25, (@i%3) + 1, '');
    SET @i += 1;
END;
PRINT 'Done.';
GO
-- Two-partition query.
SET STATISTICS XML ON;
GO
SELECT date_id, SUM(quantity*unit_price) AS total_price
FROM fact_sales
WHERE date_id BETWEEN 20080802 AND 20080902
GROUP BY date_id ;
GO
SET STATISTICS XML OFF;
GO
-- Single-partition query.
SET STATISTICS XML ON;
GO
SELECT date_id, SUM(quantity*unit_price) AS total_price
FROM fact_sales
WHERE date_id BETWEEN 20080801 AND 20080831
GROUP BY date_id;
GO
SET STATISTICS XML OFF;
GO
```

