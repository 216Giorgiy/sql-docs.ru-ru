---
title: Безопасность на уровне строк | Документация Майкрософт
ms.custom: ''
ms.date: 03/29/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.reviewer: ''
ms.suite: sql
ms.technology: security
ms.tgt_pltfrm: ''
ms.topic: conceptual
helpviewer_keywords:
- access control predicates
- row level security
- security [SQL Server], predicate based access control
- row level security described
- predicate based security
ms.assetid: 7221fa4e-ca4a-4d5c-9f93-1b8a4af7b9e8
caps.latest.revision: 47
author: edmacauley
ms.author: edmaca
manager: craigg
monikerRange: = azuresqldb-current || >= sql-server-2016 || = sqlallproducts-allversions
ms.openlocfilehash: 2cf346f9fb2527e4abb92be41800cb94af0f6781
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
---
# <a name="row-level-security"></a>Безопасность на уровне строк
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]

  ![Графическая схема безопасности на уровне строк ](../../relational-databases/security/media/row-level-security-graphic.png "Графическая схема безопасности на уровне строк")  
  
 Безопасность на уровне строк позволяет пользователям управлять доступом к строкам в таблице базы данных в зависимости от характеристик пользователя, выполняющего запрос (например, членство или контекст выполнения).  
  
 Безопасность на уровне строк (RLS) упрощает проектирование и кодирование безопасности в приложении. RLS позволяет реализовать ограничения на доступ к строкам данных. Например, обеспечивать сотрудникам доступ только к тем строкам данных, которые имеют отношение к их отделу, или ограничивать доступ к только к тем данным клиента, которые относятся к их компании.  
  
 Логика ограничения находится на уровне базы данных, а не на отдалении от данных на другом уровне приложения. Система базы данных применяет ограничения доступа каждый раз, когда выполняется попытка доступа к данным с любого уровня. Это делает систему безопасности более надежной и устойчивой за счет уменьшения контактной зоны системы безопасности.  
  
 Реализуйте безопасность на уровне строк с помощью инструкции [CREATE SECURITY POLICY](../../t-sql/statements/create-security-policy-transact-sql.md)[!INCLUDE[tsql](../../includes/tsql-md.md)] и предикатов, созданных как [встроенные функции с табличным значением](../../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md).  
  
**Область применения**: [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] (с[!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] по [текущую версию](http://go.microsoft.com/fwlink/p/?LinkId=299658)), [!INCLUDE[sqldbesa](../../includes/sqldbesa-md.md)] ([Получить](http://azure.micosoft.com/documentation/articles/sql-database-preview-whats-new/?WT.mc_id=TSQL_GetItTag)).  
  

##  <a name="Description"></a> Описание  
 Безопасность на уровне строк поддерживает два типа предикатов безопасности.  
  
-   Предикаты фильтров автоматически фильтруют строки, доступные для операций чтения (SELECT, UPDATE и DELETE).  
  
-   Предикаты BLOCK явно блокируют операции записи (AFTER INSERT, AFTER UPDATE, BEFORE UPDATE, BEFORE DELETE), которые нарушают предикат.  
  
 Доступ к данным на уровне строк в таблице ограничен предикатом безопасности, определяемым как встроенная функция с табличным значением. Эта функция затем вызывается и принудительно исполняется политикой безопасности. Что касается предикатов фильтров, приложение не получает никаких признаков того, что строки были отфильтрованы из результирующего набора. Если все строки фильтруются, будет возвращен набор, имеющий значение NULL. Что касается предикатов блокировки, любые операции, которые нарушают предикат, будут завершаться ошибкой.  
  
 Предикаты фильтров применяются при считывании данных из базовой таблицы, и это затрагивает все операции Get: **SELECT**, **DELETE** (т. е. пользователь не может удалять отфильтрованные строки) и **UPDATE** (т. е. пользователь не может изменять отфильтрованные строки, но может изменять строки так, чтобы отфильтровать их впоследствии). Предикаты блокировки влияют на все операции записи.  
  
-   Предикаты AFTER INSERT и AFTER UPDATE могут блокировать обновление строк значениями, нарушающими предикат.  
  
-   Предикаты BEFORE UPDATE могут блокировать обновление строк, нарушающих предикат на данный момент.  
  
-   Предикаты BEFORE DELETE могут блокировать операции удаления.  
  
 Предикаты фильтров и блокировки, а также политики безопасности имеют следующие особенности:  
  
-   Вы можете определить функцию предиката, которая соединяется с другой таблицей или вызывает функцию. Если политика безопасности создана с использованием команды `SCHEMABINDING = ON`, команда join или функция доступна из запроса и работает должным образом без каких-либо дополнительных проверок разрешений. Если политика безопасности создана с использованием `SCHEMABINDING = OFF`, то для отправки запросов в целевую таблицу пользователям потребуются разрешения **SELECT** и **EXECUTE** в этих дополнительных таблицах и функциях.
  
-   Вы можете выполнить запрос к таблице, имеющей предикат безопасности, который определен, но отключен. Все строки, которые были бы отфильтрованы или заблокированы, не затрагиваются.  
  
-   Когда пользователь dbo, член роли **db_owner** или владелец таблицы выполняет запрос к таблице, для которой определена или включена политика безопасности, строки фильтруются или блокируются в соответствии с такой политикой безопасности.  
  
-   Попытка изменить схему таблицы, связанной политикой безопасности привязки к схеме, приведет к ошибке. Тем не менее можно изменить столбцы, на которые не ссылается предикат.  
  
-   Попытки добавить предикат в таблицу, которая уже имеет один определенный предикат для данной операции (независимо от того, включен он или выключен), приведет к ошибке.  
  
-   Что касается политик безопасности привязки к схеме, попытка изменить функцию, которая используется в качестве предиката в таблице в пределах политики безопасности, приведет к ошибке.  
  
-   Определение нескольких активных политик безопасности, содержащих неперекрывающиеся предикаты, завершается успешно.  
  
 Предикаты фильтров имеют следующие особенности.  
  
-   Определение политики безопасности, которая фильтрует строки таблицы. Приложение не знает, что любые строки были отфильтрованы для операций **SELECT**, **UPDATE**и **DELETE** , включая ситуации, когда все строки будут исключены. Приложение может **INSERT** любые строки независимо от того, будут ли они отфильтрованы во время любой другой операции.  
  
 Предикаты блокировки имеют следующие особенности.  
  
-   Предикаты блокировки для операций UPDATE разбиваются на отдельные операции BEFORE и AFTER. Следовательно нельзя, например, запретить пользователям обновлять строки значением, которое больше текущего. Если требуется такая логика, необходимо использовать триггеры с промежуточными таблицами DELETED и INSERTED, чтобы ссылаться как на новые, так и на старые значения.  
  
-   Оптимизатор не будет проверять предикат блокировки AFTER UPDATE, если не изменяется ни один из столбцов, используемых функцией предиката. Пример: Алисе запрещено изменять значение заработной платы, указывая сумму более 100 000, однако она должна иметь возможность изменить адрес сотрудника, зарплата которого уже больше 100 000 (и, таким образом, уже нарушает предикат).  
  
-   Изменения не вносились для пакетных API, в том числе BULK INSERT. Это означает, что предикаты блокировки AFTER INSERT будут применяться к операциям пакетной вставки так же, как к обычным операциям вставки.  
  
  
##  <a name="UseCases"></a> Способы применения  
 Ниже приведены примеры конструирования использования RLS.  
  
-   Больницы могут создать политику безопасности, которая позволяет медсестрам просматривать строки данных только их собственных пациентов.  
  
-   Банк может создать политику для ограничения доступа к строкам финансовых данных на основе бизнес-подразделения сотрудника либо на основе роли сотрудника в компании.  
  
-   Мультитенантное приложение может создать политику для обеспечения логического разделения строк каждого клиента от строк любых других клиентов. Эффективность достигается путем хранения данных для многих клиентов в одной таблице. Конечно каждый клиент можно видеть только свои строки данных.  
  
 Предикаты фильтров RLS функционально эквивалентны добавлению предложения **WHERE** . Предикат может по сложности сравниваться с определением деловой практики или предложение может быть простым как `WHERE TenantId = 42`.  
  
 При использовании более формальных терминов можно сказать, что RLS представляет управление доступом на основе предиката. Он поддерживает гибкую, централизованную оценку на основе предиката, которая может учитывать метаданные или другие критерии, определяемые администратором по своему усмотрению. Предикат используется как критерий для определения, имеет ли пользователь соответствующий доступ к данным на основе атрибутов пользователя. Управление доступом на основе метки можно реализовать с помощью управления доступом на основе предиката.  
  
  
##  <a name="Permissions"></a> Permissions  
 Создание, изменение или удаление политик безопасности требует разрешения **ALTER ANY SECURITY POLICY** . Создание или удаление политики безопасности требует разрешения **ALTER** для схемы.  
  
 Кроме того, для каждого добавляемого предиката требуются следующие разрешения:  
  
-   Разрешения**SELECT** и **REFERENCES** для функции используются как предикат.  
  
-   Разрешение**REFERENCES** для целевой таблицы, которая привязывается к политике.  
  
-   Разрешение**REFERENCES** для каждого столбца из целевой таблицы, используемого в качестве аргументов.  
  
 Политики безопасности применяются ко всем пользователям, включая пользователей dbo в базе данных. Пользователи dbo могут изменять или удалять политики безопасности, однако можно проводить аудит их изменений в политиках безопасности. Если привилегированным пользователям (например, sysadmin или db_owner) нужно видеть все строки для устранения неполадок или проверки данных, необходимо написать политику безопасности, разрешающую эти действия.  
  
 Если политика безопасности создается с использованием команды `SCHEMABINDING = OFF`, то для отправки запроса в целевую таблицу пользователям потребуется разрешение  **SELECT** или **EXECUTE** в функции предиката и любых дополнительных таблицах, представлениях и функциях, используемых в функции предиката. Если политика безопасности создана с использованием `SCHEMABINDING = ON` (по умолчанию), при запросе целевой таблицы пользователями эти проверки разрешений не проводятся.  
  
  
##  <a name="Best"></a> Рекомендации  
  
-   Настоятельно рекомендуется создать отдельную схему для объектов RLS (функцию предиката и политику безопасности).  
  
-   Разрешение **ALTER ANY SECURITY POLICY** предназначено для пользователей с высокими привилегиями (например, для диспетчера политики безопасности). Диспетчеру политики безопасности не требуется разрешение **SELECT** для таблиц, которые они защищают.  
  
-   Избегайте преобразования типов в функциях предиката, чтобы исключить потенциальные ошибки выполнения.  
  
-   Там где возможно, избегайте рекурсии в функциях предиката, чтобы не допустить снижения производительности. Оптимизатор запросов будет пытаться обнаружить прямые рекурсии, но не обязательно найдет косвенные рекурсии (т. е. когда вторая функция вызывает функцию предиката).  
  
-   Избегайте использования излишних соединений таблиц в функциях предиката для повышения производительности.  
  
 Избегайте реализации логики предикатов, зависящей от [параметров SET](../../t-sql/statements/set-statements-transact-sql.md)конкретного сеанса: хотя такое использование на практике маловероятно, функции предиката, логика которых зависит от некоторых параметров **SET** сеансов, могут вызвать утечку информации, если пользователи могут выполнять произвольные запросы. Например, функция предиката, которая неявно преобразует строку в **datetime** , может выполнять фильтрацию разных строк на основе параметра **SET DATEFORMAT** для текущего сеанса. Как правило, функции предикатов должны подчиняться следующим правилам.  
  
-   Функции предикатов не должны неявно преобразовать строки символов в типы данных **date**, **smalldatetime**, **datetime**, **datetime2** или **datetimeoffset** (и наоборот), поскольку на эти преобразования влияют параметры [SET DATEFORMAT (Transact-SQL)](../../t-sql/statements/set-dateformat-transact-sql.md) и [SET LANGUAGE (Transact-SQL)](../../t-sql/statements/set-language-transact-sql.md). Вместо этого используйте функцию **CONVERT** и явно задайте параметр стиля.  
  
-   Функции предикатов не должны зависеть от значения первого дня недели, поскольку это значение зависит от параметра [SET DATEFIRST (Transact-SQL)](../../t-sql/statements/set-datefirst-transact-sql.md).  
  
-   Функции предикатов не должны зависеть от арифметических или агрегатных выражений, возвращающих значение **NULL** в случае ошибки (например, при переполнении или делении на ноль), так как это поведение определяется параметрами [SET ANSI_WARNINGS (Transact-SQL)](../../t-sql/statements/set-ansi-warnings-transact-sql.md), [SET NUMERIC_ROUNDABORT (Transact-SQL)](../../t-sql/statements/set-numeric-roundabort-transact-sql.md) и [SET ARITHABORT (Transact-SQL)](../../t-sql/statements/set-arithabort-transact-sql.md).  
  
-   Функции предикатов не должны сравнивать сцепленные строки с параметром **NULL**, так как это поведение определяется параметром [SET CONCAT_NULL_YIELDS_NULL (Transact-SQL)](../../t-sql/statements/set-concat-null-yields-null-transact-sql.md).  
   
  
##  <a name="SecNote"></a> Примечание по безопасности. Атаки на стороне канала  
 **Злонамеренный диспетчер политики безопасности** . Важно иметь в виду, что злонамеренный диспетчер политики безопасности с достаточными разрешениями для создания политики безопасности конфиденциальных столбцов и имеющий разрешения на создание или изменение встроенных функций, возвращающих табличные значения, может вступить в тайный сговор с другим пользователем, который имеет отдельные разрешения на таблицу для выполнения эксфильтрации данных с помощью злонамеренно созданных встроенных функций, возвращающих табличные значения, разработанных для использования атак на стороне канала с целью вывода данных. Такие атаки требуют наличия тайного соглашения (или предоставления излишних разрешений злонамеренному пользователю) и скорее всего потребуют нескольких итераций изменения политики (требующих разрешения на удаление предиката, чтобы разорвать привязку к схеме), изменения встроенных функций, возвращающих табличные значения, и повторяющегося выполнения инструкций select для целевой таблицы. Настоятельно рекомендуется ограничить разрешения до необходимого уровня и отслеживать все подозрительные действия, такие как постоянно изменяющиеся политики и встроенные функции, возвращающие табличные значения, связанные с безопасностью на уровне строк.  
  
 **Тщательно созданные запросы** . Можно вызвать утечку информации с помощью тщательно созданных запросов. Например, `SELECT 1/(SALARY-100000) FROM PAYROLL WHERE NAME='John Doe'` дает возможность злоумышленнику узнать, что заработная платы Джона До (John Doe) составляет 100 000 долларов. Даже при наличии предиката безопасности для предотвращения ситуаций, когда злонамеренный пользователь может напрямую выполнять запросы о заработной плате других людей, пользователь может определить, когда запрос возвращает исключение деления на ноль.  
   
  
##  <a name="Limitations"></a> Совместимость с разными компонентами  
 Как правило, безопасность на уровне строк будет работать должным образом в разных компонентах. Однако существует несколько исключений. В этом разделе приводится несколько замечаний и пояснений по использованию безопасности на уровне строк в некоторых других компонентах [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
-   **DBCC SHOW_STATISTICS** предоставляет статистику по нефильтрованным данным и, таким образом, может вызвать утечку информации, которая в противном случае защищена политикой безопасности. Таким образом, чтобы иметь возможность просматривать объект статистики для таблицы, к которой применяется безопасность на уровне строк, пользователь должен быть владельцем таблицы либо членом предопределенной роли сервера sysadmin, предопределенной роли базы данных db_owner или db_ddladmin.  
  
-   Безопасность на уровне строк**Filestream** не совместима с компонентом Filestream.  
  
-   Безопасность на уровне строк**Polybase** не совместима с компонентом Polybase.  
  
-   **Оптимизированные для памяти таблицы**Встроенная функция с табличным значением, используемая в качестве предиката безопасности для таблицы, оптимизированной для памяти, должна быть определена с помощью параметра `WITH NATIVE_COMPILATION` . Этот параметр позволяет блокировать функции языка, не поддерживаемые в оптимизированных для памяти таблицах, и выдавать соответствующую ошибку во время создания. Дополнительные сведения см. в разделе **Безопасность на уровне строк в таблицах, оптимизированных для памяти** статьи [Вводные сведения о таблицах, оптимизированных для памяти](../../relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables.md).  
  
-   **Индексированные представления** . Как правило, политики безопасности можно создавать на основе представлений, а представления можно создавать на основе таблиц, связанных политиками безопасности. Тем не менее индексированные представления нельзя создать на основе таблиц с политикой безопасности, так как операции поиска строк через индекс будут обходить политику.  
  
-   **Отслеживание измененных данных** . Система отслеживания измененных данных может вызвать утечку целых строк, которые должны быть отфильтрованы, предоставляя доступ членам **db_owner** или пользователям, являющимся членами "шлюзовой" роли, указанной при включении этой системы для таблицы. (Примечание. Для этого параметра можно явно задать значение **NULL** , чтобы все пользователи имели доступ к измененным данным.) В результате параметр **db_owner** и члены такой шлюзовой роли могут просматривать все изменения данных в таблице даже при наличии политики безопасности для таблицы.  
  
-   **Отслеживания изменений** . Функция отслеживания изменений может вызвать утечку первичного ключа строк, которые должны быть отфильтрованы, предоставляя доступ пользователям с разрешениями **SELECT** и **VIEW CHANGE TRACKING** . Доступ к фактическим значениям данных не предоставляется, становится известно только то, что столбец A был обновлен (вставлен или удален) для строки с первичным ключом B. Это создает проблему, если первичный ключ содержит конфиденциальные элементы, например номер социального страхования. Тем не менее на практике для получения последних данных инструкция **CHANGETABLE** почти всегда объединена с исходной таблицей.  
  
-   **Полнотекстовый поиск** . Можно прогнозировать снижение производительности для запросов, использующих следующие функции полнотекстового и семантического поиска, из-за введения дополнительного соединения для применения безопасности на уровне строк и блокирования утечки первичных ключей строк, которые должны быть отфильтрованы: **CONTAINSTABLE**, **FREETEXTTABLE**, semantickeyphrasetable, semanticsimilaritydetailstable, semanticsimilaritytable.  
  
-   **Индексы columnstore** . Безопасность на уровне строк совместима как с кластеризованными, так и с некластеризованными индексами columnstore. Тем не менее, поскольку безопасность на уровне строк применяет функцию, оптимизатор может изменить план запроса таким образом, чтобы пакетный режим не использовался.  
  
-   **Секционированные представления** . Предикаты блокировки нельзя определить в секционированных представлениях, и секционированные представления нельзя создавать на основе таблиц, использующих предикаты блокировки. Предикаты фильтров совместимы с секционированными представлениями.  
  
-   **Темпоральные таблицы** совместимы с безопасностью на уровне строк. Тем не менее предикаты безопасности в текущей таблице не реплицируются автоматически в прежнюю таблицу. Чтобы применить политику безопасности для текущей и прежней таблиц, необходимо по отдельности добавить предикат безопасности в каждую таблицу.  
  
  
##  <a name="CodeExamples"></a> Примеры  
  
###  <a name="Typical"></a> A. Сценарий для пользователей, проходящих проверку подлинности в базе данных  
 В этом коротком примере создаются три пользователя, создается и заполняется таблица с 6 строками, а затем создается встроенная функция, возвращающая табличное значение и политика безопасности для таблицы. Пример показывает как фильтруются отдельные инструкции для разных пользователей.  
  
 Создайте три учетные записи пользователей, демонстрирующие разные возможности доступа.  
  
```sql  
CREATE USER Manager WITHOUT LOGIN;  
CREATE USER Sales1 WITHOUT LOGIN;  
CREATE USER Sales2 WITHOUT LOGIN;  
```  
  
 Создайте простую таблицу для хранения данных.  
  
```  
CREATE TABLE Sales  
    (  
    OrderID int,  
    SalesRep sysname,  
    Product varchar(10),  
    Qty int  
    );  
```  
  
 Заполните таблицу 6 строками данных, показывающими 3 заказа для каждого торгового представителя.  
  
```  
INSERT Sales VALUES   
(1, 'Sales1', 'Valve', 5),   
(2, 'Sales1', 'Wheel', 2),   
(3, 'Sales1', 'Valve', 4),  
(4, 'Sales2', 'Bracket', 2),   
(5, 'Sales2', 'Wheel', 5),   
(6, 'Sales2', 'Seat', 5);  
-- View the 6 rows in the table  
SELECT * FROM Sales;  
```  
  
 Предоставьте доступ для чтения к таблице для каждого из пользователей.  
  
```  
GRANT SELECT ON Sales TO Manager;  
GRANT SELECT ON Sales TO Sales1;  
GRANT SELECT ON Sales TO Sales2;  
```  
  
 Создайте новую схему и встроенную функцию, возвращающую табличное значение. Функция возвращает 1, если строка в столбце SalesRep та же, что и пользователь, выполняющий запрос (`@SalesRep = USER_NAME()`) или, если пользователь, выполняющий запрос, является пользователем Manager (`USER_NAME() = 'Manager'`).  
  
```  
CREATE SCHEMA Security;  
GO  
  
CREATE FUNCTION Security.fn_securitypredicate(@SalesRep AS sysname)  
    RETURNS TABLE  
WITH SCHEMABINDING  
AS  
    RETURN SELECT 1 AS fn_securitypredicate_result   
WHERE @SalesRep = USER_NAME() OR USER_NAME() = 'Manager';  
```  
  
 Создайте политику безопасности, добавляя функцию в качестве предиката фильтра. Состоянию должно быть присвоено значение ON для включения политики.  
  
```  
CREATE SECURITY POLICY SalesFilter  
ADD FILTER PREDICATE Security.fn_securitypredicate(SalesRep)   
ON dbo.Sales  
WITH (STATE = ON);  
```  
  
 Теперь протестируйте предикат фильтрации при выборе из таблицы Sales, как для каждого пользователя.  
  
```  
EXECUTE AS USER = 'Sales1';  
SELECT * FROM Sales;   
REVERT;  
  
EXECUTE AS USER = 'Sales2';  
SELECT * FROM Sales;   
REVERT;  
  
EXECUTE AS USER = 'Manager';  
SELECT * FROM Sales;   
REVERT;  
```  
  
 Пользователь Manager должен видеть все 6 строк. Пользователи Sales1 и Sales2 должны видеть только свои продажи.  
  
 Измените политику безопасности, чтобы отключить политику.  
  
```  
ALTER SECURITY POLICY SalesFilter  
WITH (STATE = OFF);  
```  
  
 Теперь пользователи Sales1 и Sales2 могут видеть все 6 строк.  
  
  
###  <a name="MidTier"></a> Б. Сценарий для пользователей, подключающихся к базе данных через приложение среднего уровня  
 В этом примере показано, как приложение среднего уровня может реализовать фильтрацию подключений, когда пользователи приложения (или клиенты) совместно используют того же пользователя [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] (приложение). Приложение задает идентификатор пользователя текущего приложения в [SESSION_CONTEXT (Transact-SQL)](../../t-sql/functions/session-context-transact-sql.md) после подключения к базе данных, а затем политики безопасности прозрачно фильтруют строки, которые не должны быть видимыми для данного идентификатора, а также запрещают пользователю вставлять строки для другого ИД пользователя. Другие изменения приложения не требуются.  
  
 Создайте простую таблицу для хранения данных.  
  
```  
CREATE TABLE Sales (  
    OrderId int,  
    AppUserId int,  
    Product varchar(10),  
    Qty int  
);  
```  
  
 Заполните таблицу 6 строками данных, показывающими 3 заказа для каждого пользователя приложения.  
  
```  
INSERT Sales VALUES   
    (1, 1, 'Valve', 5),   
    (2, 1, 'Wheel', 2),   
    (3, 1, 'Valve', 4),  
    (4, 2, 'Bracket', 2),   
    (5, 2, 'Wheel', 5),   
    (6, 2, 'Seat', 5);  
```  
  
 Создайте пользователя с низким уровнем привилегий, который будет использоваться приложением для подключения.  
  
```  
-- Without login only for demo  
CREATE USER AppUser WITHOUT LOGIN;   
GRANT SELECT, INSERT, UPDATE, DELETE ON Sales TO AppUser;  
  
-- Never allow updates on this column  
DENY UPDATE ON Sales(AppUserId) TO AppUser;  
```  
  
 Создайте новую схему и предикат функции, которая будет использовать идентификатор пользователя приложения, сохраняемый в **SESSION_CONTEXT** , для фильтрации строк.  
  
```  
CREATE SCHEMA Security;  
GO  
  
CREATE FUNCTION Security.fn_securitypredicate(@AppUserId int)  
    RETURNS TABLE  
    WITH SCHEMABINDING  
AS  
    RETURN SELECT 1 AS fn_securitypredicate_result  
    WHERE  
        DATABASE_PRINCIPAL_ID() = DATABASE_PRINCIPAL_ID('AppUser')    
        AND CAST(SESSION_CONTEXT(N'UserId') AS int) = @AppUserId;   
GO  
```  
  
 Создайте политику безопасности, которая добавляет эту функцию в качестве предиката фильтра и предиката блокировки для `Sales`. Предикату блокировки требуется только операция **AFTER INSERT**, поскольку **BEFORE UPDATE** и **BEFORE DELETE** уже отфильтрованы, а **AFTER UPDATE** не требуется, так как для столбца `AppUserId` нельзя указать другие значения из-за разрешения столбца, которое было задано ранее.  
  
```  
CREATE SECURITY POLICY Security.SalesFilter  
    ADD FILTER PREDICATE Security.fn_securitypredicate(AppUserId)   
        ON dbo.Sales,  
    ADD BLOCK PREDICATE Security.fn_securitypredicate(AppUserId)   
        ON dbo.Sales AFTER INSERT   
    WITH (STATE = ON);  
```  
  
 Теперь мы можем имитировать фильтрацию подключения путем выбора из таблицы `Sales` после задания разных идентификаторов пользователей в **SESSION_CONTEXT**. На практике приложение отвечает за задание идентификатора текущего пользователя в **SESSION_CONTEXT** после открытия подключения.  
  
```  
EXECUTE AS USER = 'AppUser';  
EXEC sp_set_session_context @key=N'UserId', @value=1;  
SELECT * FROM Sales;  
GO  
  
--  Note: @read_only prevents the value from changing again   
--  until the connection is closed (returned to the connection pool)  
EXEC sp_set_session_context @key=N'UserId', @value=2, @read_only=1;   
  
SELECT * FROM Sales;  
GO  
  
INSERT INTO Sales VALUES (7, 1, 'Seat', 12); -- error: blocked from inserting row for the wrong user ID  
GO  
  
REVERT;  
GO  
```  
  
## <a name="see-also"></a>См. также:  
 [CREATE SECURITY POLICY (Transact-SQL)](../../t-sql/statements/create-security-policy-transact-sql.md)   
 [ALTER SECURITY POLICY (Transact-SQL)](../../t-sql/statements/alter-security-policy-transact-sql.md)   
 [DROP SECURITY POLICY (Transact-SQL)](../../t-sql/statements/drop-security-policy-transact-sql.md)   
 [CREATE FUNCTION (Transact-SQL)](../../t-sql/statements/create-function-transact-sql.md)   
 [SESSION_CONTEXT (Transact-SQL)](../../t-sql/functions/session-context-transact-sql.md)   
 [sp_set_session_context (Transact-SQL)](../../relational-databases/system-stored-procedures/sp-set-session-context-transact-sql.md)   
 [sys.security_policies (Transact-SQL)](../../relational-databases/system-catalog-views/sys-security-policies-transact-sql.md)   
 [sys.security_predicates (Transact-SQL)](../../relational-databases/system-catalog-views/sys-security-predicates-transact-sql.md)   
 [Создание определяемых пользователем функций (компонент Database Engine)](../../relational-databases/user-defined-functions/create-user-defined-functions-database-engine.md)  
  
  
