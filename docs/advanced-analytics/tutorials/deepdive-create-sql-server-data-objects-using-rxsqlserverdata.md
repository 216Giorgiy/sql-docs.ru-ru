---
title: "Создание объектов данных SQL Server с помощью функции RxSqlServerData | Документация Майкрософт"
ms.custom: 
ms.date: 05/18/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology: r-services
ms.tgt_pltfrm: 
ms.topic: article
applies_to: SQL Server 2016
dev_langs: R
ms.assetid: bcf5f7ff-795b-4815-b163-bcddd496efce
caps.latest.revision: "18"
author: jeannt
ms.author: jeannt
manager: jhubbard
ms.workload: On Demand
ms.openlocfilehash: c6208de7eedf66640ab2b8131a4b73c51e6fbaba
ms.sourcegitcommit: 531d0245f4b2730fad623a7aa61df1422c255edc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/01/2017
---
# <a name="create-sql-server-data-objects-using-rxsqlserverdata"></a>Создание объектов данных SQL Server с помощью функции RxSqlServerData

Теперь, когда вы создали базу данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и получили необходимые разрешения для работы с данными, вы создадите объекты в R, позволяющие работать с данными как на сервере, так и на рабочей станции.

## <a name="create-the-sql-server-data-objects"></a>Создание объектов данных SQL Server

В этом шаге вы создадите и заполните две таблицы с помощью R. Обе таблицы содержат вымышленные данные по мошенническим операциям с кредитными картами. Одна таблица используется для обучения моделей, а другая — для анализа.

Для создания таблиц на удаленном сервере [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] используется функция **RxSqlServerData** из пакета **RevoScaleR** .

> [!TIP]
> Если вы используете средства R для Visual Studio, выберите **Средства R** на панели инструментов и щелкните **Windows** , чтобы открыть параметры для отладки и просмотра переменных R.

### <a name="create-the-training-data-table"></a>Создание таблицы данных для обучения

1. Укажите строку подключения к базе данных в переменной R. Здесь приведены два примера допустимых строк подключения ODBC для SQL Server: один с использованием имени для входа SQL и второй для встроенной проверки подлинности Windows (рекомендуется).

    **Использование имени для входа SQL**
    ```R
    sqlConnString <- "Driver=SQL Server;Server=instance_name; Database=DeepDive;Uid=user_name;Pwd=password"
    ```

    **Использование проверки подлинности Windows**
    ```R
    sqlConnString <- "Driver=SQL Server;Server=instance_name;Database=DeepDive;Trusted_Connection=True"
    ```

    Измените имя экземпляра, имя базы данных, имя пользователя и пароль на нужные.
  
2. Укажите имя таблицы, которую нужно создать, и сохраните его в переменной R.
  
    ```R
    sqlFraudTable <- "ccFraudSmall"
    ```
  
    Так как имена экземпляра и базы данных уже указаны в строке подключения, при объединении этих двух переменных *полное* имя новой таблицы принимает вид _имя экземпляра.имя базы данных.схема.ccFraudSmall_.
  
3.  Перед созданием экземпляра объекта источника данных добавьте строку, в которой указывается дополнительный параметр *rowsPerRead*.  Параметр *rowsPerRead* управляет тем, сколько строк данных считывается в каждый пакет.
  
    ```R
    sqlRowsPerRead = 5000
    ```
  
    Хотя этот параметр необязателен, он важен для управления использованием памяти и обеспечения эффективных вычислений.  Большинство расширенных аналитических функций в [!INCLUDE[rsql_productname](../../includes/rsql-productname-md.md)] обрабатывают данные блоками и накапливают промежуточные результаты, возвращая итоговые результаты вычислений после считывания всех данных.
  
    Если значение этого параметра слишком велико, доступ к данным может замедлиться из-за нехватки памяти для эффективной обработки такого большого блока данных.  Если значение параметра *rowsPerRead* в некоторых системах слишком мало, возможно снижение производительности.
  
    В этом пошаговом руководстве будет использоваться размер обрабатываемого пакета, задаваемый экземпляром [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и определяющий число строк в каждом блоке. Это значение сохраняется в переменной *sqlRowsPerRead*.  Мы рекомендуем экспериментировать со значением этого параметра при работе с большим набором данных.
  
4.  Наконец Определите переменную для нового объекта источника данных и передачи аргументов, определенных ранее в конструктор RxSqlServerData. Обратите внимание, что при этом происходит только создание, но не заполнение объекта источника данных.
  
    ```R
    sqlFraudDS <- RxSqlServerData(connectionString = sqlConnString,
       table = sqlFraudTable,
       rowsPerRead = sqlRowsPerRead)
    ```

#### <a name="to-create-the-scoring-data-table"></a>Создание таблицы с данными для анализа

Аналогичным образом вы создадите таблицу, содержащую данные для оценки.

1. Создайте переменную R *sqlScoreTable*для хранения имени таблицы, используемой для оценки.
  
    ```R
    sqlScoreTable <- "ccFraudScoreSmall"
    ```
  
2. Предоставить эту переменную в качестве аргумента функции RxSqlServerData для определения второй объект источника данных, *sqlScoreDS*.
  
    ```R
    sqlScoreDS \<- RxSqlServerData(connectionString = sqlConnString,
       table = sqlScoreTable, rowsPerRead = sqlRowsPerRead)
    ```

Так как вы уже определили строку подключения и другие переменные в качестве переменных в рабочем пространстве R, теперь можно легко создавать источники данных для других таблиц, представлений или запросов. Просто укажите другое имя таблицы.

Далее в этом учебнике вы узнаете, как создать объект источника данных на основе запроса SQL.

## <a name="load-data-into-sql-tables-using-r"></a>Загрузка данных в таблицы SQL с помощью языка R

Теперь, когда вы создали таблицы [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , можете загрузить в них данные с помощью соответствующей функции **Rx** .

**RevoScaleR** пакет содержит функции, поддерживающие множества различных источников данных: для текстовых данных RxTextData будет использоваться для создания объекта источника данных. Имеются также дополнительные функции для создания объектов источников данных на основе Hadoop, ODBC и других типов данных.

> [!NOTE]
> Для задач, описываемых в этом разделе, требуются разрешения на выполнение DDL в базе данных.

### <a name="load-data-into-the-training-table"></a>Загрузка данных в таблицу обучения

1. Создайте переменную R *ccFraudCsv*и присвоить переменной путь к файлу для CSV-файл, содержащий данные образца.
  
    ```R
    ccFraudCsv <- file.path(rxGetOption("sampleDataDir"), "ccFraudSmall.csv")
    ```
  
    Обратите внимание на функцию служебной программы **rxGetOption**. Эта функция входит в пакет **RevoScaleR** и призвана помочь в настройке параметров, связанных с локальными и удаленными контекстами вычисления, и управлении ими. К этим параметрам относятся общий каталог по умолчанию, число процессоров (ядер), используемых при вычислениях, и т. д.  Этот вызов полезно, так как он получает образцы из правильная библиотека независимо от того, на котором выполняется код. Например, запустите функцию на сервере SQL Server и на компьютере разработчика и посмотрите различия.
  
2. Определение переменной для хранения новых данных и использовать функцию RxTextData для указания источника текстовых данных.
  
    ```R
    inTextData <- RxTextData(file = ccFraudCsv,      colClasses = c(
        "custID" = "integer", "gender" = "integer", "state" = "integer",
        "cardholder" = "integer", "balance" = "integer",
        "numTrans" = "integer",
        "numIntlTrans" = "integer", "creditLine" = "integer",
        "fraudRisk" = "integer"))
    ```
  
    Аргумент *colClasses* важен. С его помощью указывается тип данных, который назначается каждому столбцу данных, загружаемому из текстового файла. В этом примере все столбцы обрабатываются как текстовые, кроме именованных столбцов, которые обрабатываются как целочисленные.
  
3. На этом этапе может потребоваться приостановить немного и просмотреть базу данных в [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)].  Обновите список таблиц в базе данных.
  
    Вы увидите, что хотя объекты данных R были созданы в локальном рабочем пространстве, таблицы в базе данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] еще не созданы. Кроме того данные не была загружена из текстового файла в переменную R.
  
4. Теперь вызовите функцию **rxDataStep** , чтобы вставить данные в таблицу [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .
  
    ```R
    rxDataStep(inData = inTextData, outFile = sqlFraudDS, overwrite = TRUE)
    ```
  
    При отсутствии проблем со строкой подключения после небольшой паузы должны появиться результаты наподобие следующих:
  
      *Всего строк записано: 10000, Общее время: 0,466*

      *Строк считано: 10000, Всего строк обработано: 10000, Общее время фрагмента: 0,577 секунды*
  
5. С помощью [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]обновите список таблиц. Чтобы убедиться в каждой переменной имеет типов данных и успешно импортирован, щелкните правой кнопкой мыши таблицу в [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)] и выберите **выделить 1000 верхних строк**.

### <a name="load-data-into-the-scoring-table"></a>Загрузка данных в таблицу оценки

1. Чтобы загрузить в базу данных набор данных, служащий для анализа, необходимо выполнить те же действия.
  
    Сначала укажите путь к исходному файлу.
  
    ```R
    ccScoreCsv <- file.path(rxGetOption("sampleDataDir"), "ccFraudScoreSmall.csv")
    ```
  
2. Функция RxTextData используется для получения данных и сохранить его в переменной, *inTextData*.
  
    ```R
    inTextData <- RxTextData(file = ccScoreCsv,      colClasses = c(
        "custID" = "integer", "gender" = "integer", "state" = "integer",
        "cardholder" = "integer", "balance" = "integer",
        "numTrans" = "integer",
        "numIntlTrans" = "integer", "creditLine" = "integer"))
    ```
  
3.  Вызовите функцию rxDataStep перезаписать текущую таблицу с новой схемой и данными.
  
    ```R
    rxDataStep(inData = inTextData, sqlScoreDS, overwrite = TRUE)
    ```
  
    - Аргумент *inData* определяет используемый источник данных.
  
    - Аргумент *outFile* определяет таблицу в [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , в которой нужно сохранить данные.
  
    - Если таблица уже существует и параметр *overwrite* не используется, результаты будут вставлены без усечения.
  
Если соединение установлено успешно, вы увидите сообщение, информирующее о завершении и указывающее время, необходимое для записи данных в таблицу:

*Всего строк записано: 10000, Общее время: 0,384*

*Строк считано: 10000, Всего строк обработано: 10000, Общее время фрагмента: 0,456 секунды*

## <a name="more-about-rxdatastep"></a>Дополнительные сведения о функции rxDataStep

**RxDataStep** — это мощный инструмент, можно выполнять несколько преобразований на кадр данных R для преобразования данных в представление, необходимые для назначения. В этом случае данные предназначены для [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].

Преобразования данных, также можно указать с помощью функций R в аргументах rxDataStep. Вы увидите примеры этих операций в более поздней версии.

## <a name="next-step"></a>Следующий шаг

[Запрашивать и изменять данных SQL Server](../../advanced-analytics/tutorials/deepdive-query-and-modify-the-sql-server-data.md)

## <a name="previous-step"></a>Предыдущий шаг

[Работа с данными SQL Server, с помощью R](../../advanced-analytics/tutorials/deepdive-work-with-sql-server-data-using-r.md)

