---
title: Создание простого моделирования (SQL и R глубокое погружение в обработку) | Документация Майкрософт
ms.prod: sql
ms.technology: machine-learning
ms.date: 04/15/2018
ms.topic: tutorial
author: HeidiSteen
ms.author: heidist
manager: cgronlun
ms.openlocfilehash: b0db5fdfd177f1303432659f7a96b0fbf111c000
ms.sourcegitcommit: 50b60ea99551b688caf0aa2d897029b95e5c01f3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/15/2018
ms.locfileid: "51698242"
---
# <a name="create-a-simple-simulation-sql-and-r-deep-dive"></a>Создание простого моделирования (SQL и R глубокое погружение в обработку)
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md-winonly](../../includes/appliesto-ss-xxxx-xxxx-xxx-md-winonly.md)]

Эта статья содержит последний шаг в учебнике углубленное рассмотрение обработки и анализа данных об использовании [RevoScaleR](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/revoscaler) с SQL Server.

До сих пор вы уже использовали функций R, которые предназначены специально для передачи данных между [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и локальным контекстом вычисления. Однако предположим, что вы написали пользовательскую функцию R и хотите выполнить ее в контексте сервера.

Вы можете вызвать произвольную функцию в контексте компьютера [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] с помощью функции [rxExec](https://docs.microsoft.com/machine-learning-server/r-reference/revoscaler/rxexec) . Можно также использовать **rxExec** явно распределить нагрузку по ядрам в одном сервере.

На этом занятии вы использовать удаленный сервер для создания простого моделирования. Моделирование не требует данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . В примере просто демонстрируется разработка пользовательской функции и ее вызов с помощью функции **rxExec** .

Более сложный пример использования **rxExec**, см. в статье: [параллелизма грубое детализации с помощью foreach и rxExec](https://blog.revolutionanalytics.com/2015/04/coarse-grain-parallelism-with-foreach-and-rxexec.html)

## <a name="create-the-custom-function"></a>Создайте пользовательскую функцию

Популярная азартная игра заключается в бросании двух кубиков, причем действуют указанные ниже правила.

- Если при первом броске выпала сумма очков 7 или 11, вы выигрываете.
- Если выпала сумма очков 2, 3 или 12, вы проигрываете.
- Если выпала сумма 4, 5, 6, 8, 9 или 10, это число становится "пойнтом", и нужно продолжать бросать кости, пока снова не выпадет "пойнт" (выигрыш) или сумма 7 (проигрыш).

Эту игру легко смоделировать в R, создав пользовательскую функцию, которую затем можно выполнять много раз.

1.  Создайте пользовательскую функцию, используя следующий код R:
  
    ```R
    rollDice <- function()
    {
        result <- NULL
        point <- NULL
        count <- 1
            while (is.null(result))
            {
                roll <- sum(sample(6, 2, replace=TRUE))
  
                if (is.null(point))
                { point <- roll }
                if (count == 1 && (roll == 7 || roll == 11))
                {  result <- "Win" }
                else if (count == 1 && (roll == 2 || roll == 3 || roll == 12))
                { result \<- "Loss" }
                else if (count > 1 && roll == 7 )
                { result \<- "Loss" }
                else if (count > 1 && point == roll)
                { result <- "Win" }
                else { count <- count + 1 }
            }
            result
    }
    ```
  
2.  Чтобы смоделировать одну игру в кости, выполните функцию.
  
    ```R
    rollDice()
    ```
  
    Выиграли вы или проиграли?
  
Теперь давайте посмотрим, как можно использовать **rxExec** многократное выполнение функции, чтобы создать моделирование, позволяющее определить вероятность выигрыша.

## <a name="create-the-simulation"></a>Создание моделирования

Чтобы выполнить произвольную функцию в контексте компьютера [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , следует вызвать функцию **rxExec** . Несмотря на то что **rxExec** также поддерживает распределенное выполнение функции в параллельном режиме между узлами или ядер в контексте сервера, здесь ее запусков пользовательскую функцию, на компьютере SQL Server.

1. Вызовите эту пользовательскую функцию в качестве аргумента **rxExec**вместе с другими параметрами, которые изменяют симулятор.
  
    ```R
    sqlServerExec <- rxExec(rollDice, timesToRun=20, RNGseed="auto")
    length(sqlServerExec)
    ```
  
    - Аргумент *timesToRun* позволяет указать, сколько раз должна выполняться функция.  В этом случае кости бросаются 20 раз.
  
    - Аргументы *RNGseed* и *RNGkind* позволяют управлять генерацией случайных чисел. Если параметр *RNGseed* имеет значение **auto**, в каждом рабочем процессе инициализируется параллельный поток случайных чисел.
  
2. Функция **rxExec** создает список с одним элементом для каждого запуска, однако, пока список не заполнится, практически ничего происходить не будет. Когда все итерации будут завершены, строка, начинающаяся с `length` , вернет значение.
  
    После этого можно перейти к следующему шагу, чтобы получить сводку по выигрышам и проигрышам.
  
3. Преобразуйте полученный список в вектор с помощью функции R `unlist` и обобщите результаты с помощью функции `table` .
  
    ```R
    table(unlist(sqlServerExec))
    ```
  
    Результаты должны выглядеть примерно так:
  
     *Проигрыш выигрыш* *12 8*

## <a name="conclusions"></a>Заключение

В этом учебнике вы научились выполнять следующие задачи:
  
-   получать данные [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для использования при анализе;
  
-   создавать и изменять источники данных в R;
  
-   передавать модели, данные и диаграммы между рабочей станцией и сервером [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .
  

Если вы хотите поэкспериментировать с помощью этих методов, с помощью набора данных большего размера 10 миллионов наблюдений, файлы данных доступны на веб-сайте Revolution analytics: [индекса наборов данных](https://packages.revolutionanalytics.com/datasets)

Чтобы повторно использовать в этом пошаговом руководстве с большими файлами данных, загрузить данные и измените каждый источник данных следующим образом:

1. Измените переменные `ccFraudCsv` и `ccScoreCsv` чтобы они указывали на новые файлы данных
2. Измените имя таблицы, указанной в *sqlFraudTable* для `ccFraud10`
3. Измените имя таблицы, указанной в *sqlScoreTable* для `ccFraudScore10`

## <a name="additional-samples"></a>Дополнительные примеры

Теперь, когда вы научились использовать контексты вычислений и функции RevoScaler для передачи и преобразования данных, проверьте следующие учебники:

[Учебные материалы по R для служб машинного обучения](machine-learning-services-tutorials.md)
## <a name="previous-step"></a>Предыдущий шаг

[Перенос данных между SQL Server и файлом XDF](../../advanced-analytics/tutorials/deepdive-move-data-between-sql-server-and-xdf-file.md)
