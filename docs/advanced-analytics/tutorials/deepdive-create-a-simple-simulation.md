---
title: "Занятие 5. Создание простого моделирования (глубокое погружение в обработку и анализ данных) | Документация Майкрософт"
ms.custom: 
ms.date: 05/18/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology:
- r-services
ms.tgt_pltfrm: 
ms.topic: article
applies_to:
- SQL Server 2016
dev_langs:
- R
ms.assetid: f420b816-ddab-4a1a-89b9-c8285a2d33a3
caps.latest.revision: 16
author: jeannt
ms.author: jeannt
manager: jhubbard
ms.translationtype: MT
ms.sourcegitcommit: 876522142756bca05416a1afff3cf10467f4c7f1
ms.openlocfilehash: e5bbd69bba01da2aacd3b8912aebac6b4e1c28a1
ms.contentlocale: ru-ru
ms.lasthandoff: 09/01/2017

---
# <a name="create-a-simple-simulation"></a>Создание простого моделирования

До сих пор вы уже использовали функций R, разработанных специально для перемещения данных между [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и локального контекста вычислений. Однако предположим, что вы написали пользовательскую функцию R и хотите выполнить ее в контексте сервера.

Вы можете вызвать произвольную функцию в контексте компьютера [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] с помощью функции **rxExec** . Также можно rxExec явно распределения работы между ядрами на одном серверном узле.

На этом занятии вы используете удаленный сервер для создания простого моделирования. Моделирование не требует какой-либо [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] данных; в примере показано только как проектировать пользовательскую функцию и затем вызвать ее с помощью функции rxExec.

Более сложный пример использования rxExec, см. в этой статье: [крупной гранулярности параллелизм с foreach и rxExec](http://blog.revolutionanalytics.com/2015/04/coarse-grain-parallelism-with-foreach-and-rxexec.html)

## <a name="create-the-function"></a>Создание функции

Популярная азартная игра заключается в бросании двух кубиков, причем действуют указанные ниже правила.

- Если при первом броске выпала сумма очков 7 или 11, вы выигрываете.
- Если выпала сумма очков 2, 3 или 12, вы проигрываете.
- Если выпала сумма 4, 5, 6, 8, 9 или 10, это число становится "пойнтом", и нужно продолжать бросать кости, пока снова не выпадет "пойнт" (выигрыш) или сумма 7 (проигрыш).

Эту игру легко смоделировать в R, создав пользовательскую функцию, которую затем можно выполнять много раз.

1.  Создайте пользовательскую функцию, используя следующий код R:
  
    ```R
    rollDice <- function()
    {
        result <- NULL
        point <- NULL
        count <- 1
            while (is.null(result))
            {
                roll <- sum(sample(6, 2, replace=TRUE))
  
                if (is.null(point))
                { point <- roll }
                if (count == 1 && (roll == 7 || roll == 11))
                {  result <- "Win" }
                else if (count == 1 && (roll == 2 || roll == 3 || roll == 12))
                { result \<- "Loss" }
                else if (count > 1 && roll == 7 )
                { result \<- "Loss" }
                else if (count > 1 && point == roll)
                { result <- "Win" }
                else { count <- count + 1 }
            }
            result
    }
    ```
  
2.  Чтобы смоделировать одну игру в кости, выполните эту функцию.
  
    ```R
    rollDice()
    ```
  
    Выиграли вы или проиграли?
  
Теперь посмотрим, как можно выполнять функцию многократно, чтобы создать моделирование, позволяющее определить вероятность выигрыша.

## <a name="create-the-simulation"></a>Создание моделирования

Для запуска в контексте произвольная функция [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] компьютера, можно вызвать функцию rxExec. Несмотря на то, что rxExec также поддерживает распределенные выполнение функции в параллельном режиме между узлами или ядер в контексте сервера, здесь будет используется только для запуска вашей пользовательской функции на сервере.

1. Вызывайте пользовательскую функцию как аргумент rxExec, а также другие параметры, изменяющие моделирование.
  
    ```R
    sqlServerExec <- rxExec(rollDice, timesToRun=20, RNGseed="auto")
    length(sqlServerExec)
    ```
  
    - Аргумент *timesToRun* позволяет указать, сколько раз должна выполняться функция.  В этом случае кости бросаются 20 раз.
  
    - Аргументы *RNGseed* и *RNGkind* позволяют управлять генерацией случайных чисел. Если параметр *RNGseed* имеет значение **auto**, в каждом рабочем процессе инициализируется параллельный поток случайных чисел.
  
2. Функция rxExec создает список с одним элементом для каждого запуска; Тем не менее вы не увидите много происходит до завершения списка. Когда все итерации будут завершены, строка, начинающаяся с `length` , вернет значение.
  
    После этого можно перейти к следующему шагу, чтобы получить сводку по выигрышам и проигрышам.
  
3. Преобразуйте полученный список в вектор с помощью функции R `unlist` и обобщите результаты с помощью функции `table` .
  
    ```R
    table(unlist(sqlServerExec))
    ```
  
    Результаты должны выглядеть примерно так:
  
     *Потеря Win* *12 8*

## <a name="conclusions"></a>Заключение

В этом учебнике вы научились выполнять следующие задачи:
  
-   получать данные [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для использования при анализе;
  
-   создавать и изменять источники данных в R;
  
-   передавать модели, данные и диаграммы между рабочей станцией и сервером [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .
  
>  [!TIP]
> 
> При желании поэкспериментировать с этих методов, с помощью набора данных большего размера 10 миллионов наблюдений, файлы данных будут доступны на веб-сайте Revolution analytics: [индекса наборов данных](http://packages.revolutionanalytics.com/datasets)
>   
> Чтобы повторно использовать в данном пошаговом руководстве с большими файлами данных, загрузить данные, а затем измените каждый источник данных следующим образом:
>  - Задайте переменные *ccFraudCsv* и *ccScoreCsv* так, чтобы они указывали на новые файлы данных.
>  - Измените имя таблицы, указанное в *sqlFraudTable* , на *ccFraud10*
>  - Измените имя таблицы, указанное в *sqlScoreTable* , на *ccFraudScore10*

## <a name="previous-step"></a>Предыдущий шаг

[Перемещение данных между SQL Server и XDF-файла](../../advanced-analytics/tutorials/deepdive-move-data-between-sql-server-and-xdf-file.md)



