---
title: "Преобразование кода на языке R для использования в службах R | Документация Майкрософт"
ms.custom: SQL2016_New_Updated
ms.date: 06/29/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology: r-services
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: R
ms.assetid: 0b11ab52-b2f9-4a4f-b1ab-68ba09c8adcc
caps.latest.revision: "13"
author: jeannt
ms.author: jeannt
manager: jhubbard
ms.workload: Inactive
ms.openlocfilehash: d403b716d6be6c571f4de76a25ba3f6f7f5c4e8d
ms.sourcegitcommit: 9678eba3c2d3100cef408c69bcfe76df49803d63
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2017
---
# <a name="converting-r-code-for-use-in-r-services"></a>Преобразование кода на языке R для использования в службах R

При перемещении кода R из R Studio или других средах SQL Server часто код работает без дальнейших изменений при добавлении  *@script*  параметр [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md). Это особенно верно, если создано решение с помощью **RevoScaleR** функции, сделав его сравнительно легко изменить контекстов выполнения.

Тем не менее для выполнения в SQL Server код R обычно требуется изменить, чтобы получить более тесную интеграцию с [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и избежать дорогостоящей передачи данных.

Примеры выполнения кода R в SQL Server можно просмотреть в этих пошаговых руководствах:

+ [Аналитика в базе данных для разработчиков SQL](../tutorials/sqldev-in-database-r-for-sql-developers.md) показано, как сделать код R более удобным путем помещения его в хранимых процедурах

+ [Решение обработки и анализа данных и всестороннее](../tutorials/walkthrough-data-science-end-to-end-walkthrough.md) включает сравнение конструируются в T-SQL и R

## <a name="how-the-data-science-process-changes-in-sql-server"></a>Как меняется процесс обработки и анализа данных в SQL Server

При работе в изолированной среде разработки R например [!INCLUDE[rsql_rtvs_md](../../includes/rsql-rtvs-md.md)] или RStudio, типичный рабочий процесс — извлекают данные на компьютере, последовательно, анализировать данные и записывают или отображения результатов. Тем не менее при переносе кода автономный R для SQL Server большая часть этого процесса может быть упрощена или делегировать с другими средствами SQL Server. Кроме того такой подход может повысить производительность во многих случаях.

| Внешний код | R в SQL Server |
|-------|-------|
| Прием данных| Определите входные данные как SQL-запроса. Избегайте перемещения данных. |
| Сводное представление и визуализация данных| Графики можно экспортировать как изображения или отправить по удаленной рабочей станции.|
|Формирование признаков| Используйте R в базе данных, если вы не хотите изменять код, но просмотрите Оптимизация запросов. Проверьте, это может оказаться более эффективным для вызова функции T-SQL или пользовательского определяемые пользователем функции.|
|Очистка данных в рамках процесса анализа| Выполните конструируются извлечения признаков и очистка данных как часть рабочие процессы данных заранее.|
|Вывод прогнозов в файл| Вывод прогнозов в таблицу, чтобы избежать перемещения данных. Функции в хранимых процедурах для прямого доступа предсказания Wrap приложениями.|

## <a name="best-practices"></a>Рекомендации

+ Запишите зависимости, например требуемые пакеты, заранее. В среде разработки и тестирования допустимо устанавливать пакеты как часть кода, но это не рекомендуется делать в рабочей среде. Обратитесь к администратору, чтобы установить и протестировать пакеты до развертывания кода.

+ Составьте контрольный список возможных проблем с типами данных. Документ схемы в каждом разделе код ожидаемые результаты.

+ Определите основные источники данных, например данные для обучения модели, входные данные для создания прогнозов и дополнительные источники, такие как факторы, дополнительные переменные группирования и т. д. Сопоставьте самый большой набор данных со входным параметром процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md).

+ Измените инструкции входных данных таким образом, чтобы они работали непосредственно в базе данных. Вместо перемещения данных в локальный файл CSV или сделав повторные вызовы ODBC, можно получить более высокую производительность с помощью SQL-запросы или представления, которые могут быть запущены напрямую к базе данных, без перемещения данных.

+ Используйте планы запросов SQL Server для определения задач, которые могут выполняться параллельно. Если входящий запрос может выполняться параллельно, задайте `@parallel=1` как часть аргументов [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md). Параллельная обработка с использованием этого параметра обычно поддерживается, если SQL Server может работать с секционированными таблицами или распределять запрос между несколькими процессами и выполнять статистическую обработку результатов в конце.

  Параллельная обработка с использованием этого параметра обычно не поддерживается, если для обучения моделей применяются алгоритмы, требующие считывания всех данных, или если требуется создать агрегаты.

+ Где возможно, замените обычные функции R функциями **ScaleR**, поддерживающими распределенное выполнение. Дополнительные сведения см. в разделе [сравнения базы R и функции r. шкалы](https://docs.microsoft.com/r-server/r-reference/revoscaler/revoscaler-compared-to-base-r).

+ Определите, нет ли в коде R действий, которые можно выполнять отдельно или более эффективно с помощью вызова отдельной хранимой процедуры. Например, вы можете выполнять формирование или извлечение признаков отдельно и добавлять значения в новый столбец. 

  Используйте T-SQL, а не в коде R для вычислений с множествами. Пример решения R, сравнивающий определяемых пользователем функций и R для задач разработки компонентов см. в разделе [Пошаговое руководство для начала до конца обработки и анализа данных](../tutorials/walkthrough-data-science-end-to-end-walkthrough.md).

+ Используйте пакет R **sqlrutils** для преобразования кода в одной функции с четко определенные входные и выходные данные, которые можно легко сопоставить с параметрами хранимой процедуры. Дополнительные сведения и примеры см. в разделе [SqlRUtils](../r/generating-an-r-stored-procedure-for-r-code-using-the-sqlrutils-package.md).


## <a name="restrictions"></a>Ограничения

 При преобразовании кода R учитывайте следующие ограничения.

### <a name="data-types"></a>Типы данных

-   Все типы данных R поддерживаются. Тем не менее [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] поддерживает больше типов данных, чем R, поэтому при отправке данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] в R и наоборот выполняются неявные преобразования типов данных. Может также потребоваться для явного приведения или преобразования некоторых данных.

- Значения NULL поддерживаются. Использует R `na` конструкция данных для представления отсутствующие значения, что похоже на значение null.

Дополнительные сведения см. в разделе [библиотеки R и типы данных](../r/r-libraries-and-data-types.md).

### <a name="inputs-and-outputs"></a>Входы и выходы

+ Вы можете определить только один входной набор данных как часть параметров хранимых процедур. Входным запросом для хранимой процедуры может быть любая допустимая одиночная инструкция SELECT. Мы рекомендуем использовать входные данные для больших наборов данных и получение небольших наборов данных, при необходимости с помощью вызова RODBC.

+ Вызовы хранимых процедур, предшествует EXECUTE нельзя использовать в качестве входных данных для [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md).

+ Все столбцы во входном наборе данных должны быть сопоставлены с переменными в скрипте R. Переменные сопоставляются автоматически по имени. Например предположим, что R-скриптов содержит формулу, похожее на следующее:
    
    ```R
    formula <- ArrDelay ~ CRSDepTime + DayOfWeek + CRSDepHour:DayOfWeek
    ```
    
     Если во входном наборе данных не содержит столбцы с совпадающими именами ArrDelay, CRSDepTime, DayOfWeek, CRSDepHour и DayOfWeek, возникает ошибка.

+ Кроме того, в качестве входных данных можно ввести несколько скалярных параметров. Тем не менее все переменные, передаваемые в качестве параметров хранимой процедуры [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md), должны быть сопоставлены с переменными в коде R. По умолчанию переменные сопоставляются по имени.

+ Чтобы включить скалярные входные переменные в результат выполнения кода R, просто добавьте ключевое слово **OUTPUT** при определении переменной.

+ В [!INCLUDE[rsql_productname](../../includes/rsql-productname-md.md)] код R может вывести только один набор данных как объект data.frame. Однако можно также выводить несколько скалярных выходных данных, включая графики в двоичном формате и модели в формате varbinary.

+ Обычно вы можете выводить набор данных, возвращаемый скриптом R, не указывая имена выходных столбцов, с помощью параметра WITH RESULT SETS UNDEFINED. Тем не менее все переменные в скрипте R, которые требуется вывести, должны быть сопоставлены с выходными параметрами SQL.

+ Если скрипт R использует аргумент `@parallel=1`, необходимо определить схему вывода. Дело в том, что SQL Server может распределить запрос между несколькими параллельными процессами и собирать результаты в конце. Таким образом должны быть определены со схемой выходных данных, перед созданием параллельной обработки.

### <a name="dependencies"></a>Зависимости

 + Не рекомендуется устанавливать пакеты из кода R. На сервере SQL Server следует заранее установить пакетов.
 
  Не забудьте установить пакеты в библиотеке пакета по умолчанию, используемый службами машины обучения. Дополнительные сведения см. в разделе [R пакета управления для SQL Server](../r/r-package-management-for-sql-server-r-services.md)
