---
title: "R и оптимизации данных (службы R) | Microsoft Docs"
ms.custom: ""
ms.date: "03/10/2017"
ms.prod: "sql-server-2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "r-services"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: b6104878-ed19-47a7-ac37-21e4d6e2a1af
caps.latest.revision: 13
author: "jeannt"
ms.author: "jeannt"
manager: "jhubbard"
caps.handback.revision: 10
---
# R и оптимизации данных (службы R)
В этом разделе описаны методы для обновления кода R для повышения производительности или предотвращения известных проблем.

## Контекст вычисления

[!INCLUDE[rsql_productname](../../includes/rsql-productname-md.md)] можно использовать любой __локального__ или __SQL__ вычисления контекста при выполнении анализа. При использовании __локального__ контекста вычисления, анализ выполняется на клиентском компьютере и данных должен быть получен от [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)] по сети. Снижение производительности, вызванных на передачу по сети зависит от объема передаваемых данных скорости сети, а другие передачу данных по сети происходит одновременно.

Если контекст вычисления __SQL Server__, а затем аналитические функции выполняются в [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)]. Данные является локальным для задач анализа, чтобы появилась не нагрузку на сеть. 

При работе с большими наборами данных, следует всегда использовать контекст вычисления SQL.

## Факторы

Язык R преобразует строки из таблиц в факторов. Многие объекты источника данных принимать `colInfo` как параметр для управления, как обрабатываются столбцы. Например `c(“fruit” = c(type = “factor”, levels=as.character(c(1:3)), newLevels=c(“apple”, “orange”, “banana”)))` будет использовать целые числа 1, 2 и 3 из таблицы и обрабатывать их как факторов с уровнями `apple`, `orange`, и `banana`. 

Ученые данные часто используют переменных факторов в формуле их; Однако с помощью факторов, если источник данных представляет собой целое число повлечет за собой производительность как целые числа преобразуются в строки во время выполнения. Однако, если столбец содержит строки, можно указать уровни опережает время с помощью `colInfo`. В этом случае будет эквивалентную инструкцию  `c(“fruit” = c(type = “factor”, levels= c(“apple”, “orange”, “banana”)))`, который считает строки факторов их чтения. 

Чтобы избежать выполнения преобразований, рассмотрите возможность хранения уровни как целые числа в таблице и использует их, как описано в первом примере формулы. Если нет семантические различия при формировании модели, этот подход может привести к лучшей производительности.

## Преобразование данных

Ученые данные часто используются функции преобразования, написанные на R в процессе анализа. Функции преобразования должен применяться к каждой строке, полученных из таблицы. В [!INCLUDE[rsql_productname](../../includes/rsql-productname-md.md)], это преобразование происходит в пакетном режиме и включает обмен данными между интерпретатора R, а также модуль аналитики. Чтобы выполнить преобразование, перемещения данных из SQL подсистема аналитики, а затем процесс интерпретатора R и обратно. Таким образом с помощью преобразований может составляет значительные негативно сказывается на производительности алгоритма, в зависимости от объема данных участвует.

Это более эффективно все необходимые столбцы в таблице или представлении, прежде чем выполнять анализ, как это позволяет избежать преобразования во время вычисления. Если это не позволяет добавлять дополнительные столбцы к существующим таблицам, рассмотрите возможность создания другой таблицы или представления со столбцами, преобразованные и используйте соответствующий запрос для получения данных.

## Пакетная обработка

Источник данных SQL (`RxSqlServerData`) имеет параметр для указания размера пакета с помощью параметра `rowsPerRead`. Этот параметр задает количество строк для обработки одновременно. Во время выполнения алгоритмы считывает указанный номерами строк в каждом пакете. По умолчанию значение этого параметра равным 50 000, чтобы гарантировать, что алгоритмы можно выполнять даже на компьютерах с недостаточным объемом памяти. Если на компьютере недостаточно памяти, увеличение этого значения 500 000 или даже миллионов могут помочь повысить производительность, особенно для больших таблиц. 

Увеличение этого значения может не всегда повысить качество результатов, может потребоваться несколько экспериментов, чтобы определить оптимальное значение. Преимущества этого будет явно, как на большой набор данных с несколькими процессами (`numTasks` присвоено значение больше, чем `1`).

## Параллельная обработка

Для повышения производительности работы rx аналитические функции внутри [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)], [!INCLUDE[rsql_productname](../../includes/rsql-productname-md.md)] зависит от параллельной обработки с помощью доступных ядер на [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)] компьютере. Существует два способа достижения параллелизации с [!INCLUDE[rsql_productname](../../includes/rsql-productname-md.md)]:

* При использовании `sp_execute_external_script` хранимой процедуры для выполнения скрипта R, установите `@parallel` параметра `1`. Это полезно для сценариев R, не использующие RevoScaleR функций, которые обычно имеют префикс «rx». Если скрипт использует функции RevoScaleR, параллельная обработка осуществляется автоматически и не задавайте `@parallel` для `1`.

    Если сценарий R могут выполняться параллельно, а [!INCLUDE[tsql_md](../../includes/tsql-md.md)] запроса могут выполняться параллельно, затем [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)] будет создано несколько параллельных процессов (до __Максимальная степень параллелизма MAXDOP__ для [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)],) и выполнять один сценарий для всех процессов. Каждый процесс получает только часть данных, поэтому это не является полезным со сценариями, которые необходимо просматривать все данные, такие как при обучении модели. Тем не менее она полезна при выполнении задач, таких как пакетный прогноз в параллельном режиме. Дополнительные сведения об использовании параллелизма с [sp_execute_external_script](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md), в разделе __Дополнительные советы по: параллельной обработки__ раздел [с помощью кода R в Transact-SQL](../../advanced-analytics/r-services/using-r-code-in-transact-sql-sql-server-r-services.md).

* При использовании функций rx с контекстом вычислений SQL Server, установите `numTasks` число процессов, которые вы хотите создать. Фактическое число процессов, созданных определяется [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)], и может быть меньше запрошенного. Количество процессов, созданных никогда не может быть более чем __MAXDOP__.

    Если сценарий R могут выполняться параллельно, а [!INCLUDE[tsql_md](../../includes/tsql-md.md)] запроса могут выполняться параллельно, затем [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)] создаст несколько параллельных процессов при выполнении функций rx.

Количество процессов, которые будут созданы зависит от ряда факторов, таких как управление ресурсами, текущее использование ресурсов, другие сеансы и план выполнения запроса для запроса, используемого с помощью скрипта R. 

### Параллелизация запросов

Чтобы убедиться, что данные можно проанализировать в параллельном режиме, следует заключить запрос, используемый для извлечения данных таким образом, что он может визуализироваться для параллельного выполнения. 

[!INCLUDE[rsql_productname](../../includes/rsql-productname-md.md)] Работа с источниками данных SQL с помощью поддерживает `RxSqlServerData` для указания источника. Источником может быть таблицей или запросом. Например в следующих примерах кода и определения R объект источника данных, основанную на запросе SQL:
~~~~
RxSqlServerData(table=”airline”, connectionString = sqlConnString)
~~~~

~~~~
RxSqlServerData(sqlquery=”select [ArrDelay],[CRSDepTime],[DayOfWeek] from airlineWithIndex where rowNum <= 100000”, connectionString = sqlConnString)
~~~~ 

Как алгоритмы analytics извлечения больших объемов данных из таблиц, важно убедиться, что запрос, приведенный в `RxSqlServerData` оптимизирован для параллельного выполнения. Запрос, который не приводит к план параллельного выполнения может привести в один процесс для вычисления.

[!INCLUDE[ssManStudioFull_md](../../includes/ssmanstudiofull-md.md)] можно использовать для анализа плана выполнения и повысить производительность запроса. Например отсутствующий индекс для таблицы может влиять на время, затраченное на выполнение запроса. В разделе [Наблюдение и настройка производительности](../../relational-databases/performance/monitor-and-tune-for-performance.md) Подробнее.

Контроль над другим, может повлиять на производительность при запрос возвращает больше столбцов, чем необходимо. Например, если таблица содержит столбцы 30 формулы зависит только 3 столбца, не используйте запрос такие как `select *` или выбирает больше столбцов, чем требуется.

> [!NOTE]
> Если таблица, указанная в источнике данных, вместо запроса [!INCLUDE[rsql_productname](../../includes/rsql-productname-md.md)] внутренне будет определить необходимые столбцы для выборки из таблицы, однако такой подход вряд ли приведет параллельного выполнения.

## Параметры алгоритма

Многие алгоритмы обучения rx поддерживает параметры для управления созданием обучения модели. Хотя точность и правильность модели важна, производительность этого алгоритма может иметь существенный. Можно изменить параметры обучения модели параметра для повышения скорости вычислений, и во многих случаях можно повысить производительность без уменьшения точность и правильность. 

Например `rxDTree` поддерживает `maxDepth` параметр, который управляет глубина дерева максимальное. Как `maxDepth` — увеличивается, возможно снижение производительности, поэтому важно проанализировать преимущества увеличение глубины и влияние на производительность. 

Один из параметров, которые могут использоваться с `rxLinMod` и `rxLogit` — `cube` аргумент. Этот аргумент может использоваться при первой зависимой переменной формулы фактором в качестве переменной. Если `cube` имеет значение `TRUE`, выполняется регрессии с помощью секционированных обратное, он может быстрее и использует меньше памяти, чем стандартные регрессии вычисления. Если формула содержит большое количество переменных, выигрыш в производительности может быть существенным.

 [RevoScaleR](https://msdn.microsoft.com/microsoft-r/scaler/scaler) руководство пользователя имеет некоторые полезные сведения для управления модель подходит для различных алгоритмов. Например, с помощью `rxDTree` можно управлять баланс между время сложность и прогнозирования точности путем настройки параметров, таких как `maxNumBins`, `maxDepth`, `maxComplete`, и `maxSurrogate`. Увеличение глубины для за 10 или 15 можно сделать вычислений очень дорого.

Дополнительные сведения о настройке производительности для `rxDForest` и `rxDTree`, в разделе [параметров для rxDForest или rxDTree производительности](https://support.microsoft.com/kb/3104235).

## Модель и прогноз

После завершения обучения и выбрать оптимальную модель, рекомендуется хранить модели в базе данных, чтобы она становится доступна для прогнозов. Для обработки онлайн-транзакций, которая требует прогноза, загрузку предварительно вычисленных модели из базы данных для прогноза очень эффективна. Примеры сценариев этот способ используется для сериализации и сохранения модели в таблице базы данных. Для прогноза модель десериализованных из базы данных.

Некоторые модели, созданные алгоритмы, такие как lm или glm может быть довольно большим, особенно в том случае, когда используются на больших наборах данных. Существуют ограничения на размер данных, которые могут храниться в [!INCLUDE[ssNoVersion_md](../../includes/ssnoversion-md.md)]. Модель следует очистить перед их сохранением в базу данных.

> [!NOTE] Если быстро прогноза с помощью хранимых моделей и интеграция аналитики в приложение сценарий является важным, мы рекомендуем __DeployR__. Можно легко интегрировать analytics R внутри рабочего стола, мобильный, мониторинга и веб-приложений. В частности идеально подходит для хранения модели и затем выполняет одну строку прогноза с помощью хранимых модели. Дополнительные сведения см. в разделе [о DeployR](https://msdn.microsoft.com/microsoft-r/rserver/deployr-about).

## См. также:
[Управление ресурсами](../../advanced-analytics/r-services/resource-governance-for-r-services.md)
[регулятора ресурсов](../../relational-databases/resource-governor/resource-governor.md)

[СОЗДАНИЕ ПУЛА ВНЕШНИХ РЕСУРСОВ](../../t-sql/statements/create-external-resource-pool-transact-sql.md)

 [SQL Server R служб настройки руководства по повышению производительности](../../advanced-analytics/r-services/sql-server-r-services-performance-tuning.md)
 
 [Настройка SQL Server для служб R](../../advanced-analytics/r-services/sql-server-configuration-r-services.md)
 
 [Исследование производительности](../../advanced-analytics/r-services/performance-case-study-r-services.md)
 