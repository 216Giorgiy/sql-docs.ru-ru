---
title: "Занятие&#160;5. Создание простого моделирования (глубокое погружение в обработку и анализ данных) | Microsoft Docs"
ms.custom: ""
ms.date: "10/03/2016"
ms.prod: "sql-server-2016"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "r-services"
ms.tgt_pltfrm: ""
ms.topic: "article"
applies_to: 
  - "SQL Server 2016"
dev_langs: 
  - "R"
ms.assetid: f420b816-ddab-4a1a-89b9-c8285a2d33a3
caps.latest.revision: 16
author: "jeannt"
ms.author: "jeannt"
manager: "jhubbard"
caps.handback.revision: 15
---
# Занятие&#160;5. Создание простого моделирования (глубокое погружение в обработку и анализ данных)
До сих пор вы использовали предоставляемые службами SQL Server R Services функции R, которые предназначены специально для передачи данных между [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] и локальным контекстом вычисления. Однако предположим, что вы написали пользовательскую функцию R и хотите выполнить ее в контексте сервера.  
  
Вы можете вызвать произвольную функцию в контексте компьютера [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] с помощью функции *rxExec*. Функцию *rxExec* можно также использовать для явного распределения нагрузки по ядрам в отдельном узле сервера.  
  
На этом занятии вы используете удаленный сервер для создания простого моделирования. Моделирование не требует данных [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. В примере просто демонстрируется разработка пользовательской функции и ее вызов с помощью функции *rxExec*.  
  
Более сложный пример использования функции *rxExec* см. в следующей статье: [http://blog.revolutionanalytics.com/2015/04/coarse-grain-parallelism-with-foreach-and-rxexec.html](http://blog.revolutionanalytics.com/2015/04/coarse-grain-parallelism-with-foreach-and-rxexec.html).  
  
## Создание функции  
Популярная азартная игра заключается в бросании двух кубиков, причем действуют указанные ниже правила.  
  
-   Если при первом броске выпала сумма очков 7 или 11, вы выигрываете.  
  
-   Если выпала сумма очков 2, 3 или 12, вы проигрываете.  
  
-   Если выпала сумма 4, 5, 6, 8, 9 или 10, это число становится "пойнтом", и нужно продолжать бросать кости, пока снова не выпадет "пойнт" (выигрыш) или сумма 7 (проигрыш).  
  
Эту игру легко смоделировать в R, создав пользовательскую функцию, которую затем можно выполнять много раз.  
  
1.  Создайте пользовательскую функцию, используя следующий код R:  
  
    ```R  
    rollDice <- function()   
    {   
        result <- NULL        
        point <- NULL     
        count <- 1   
            while (is.null(result))   
            {   
                roll <- sum(sample(6, 2, replace=TRUE))   
  
                if (is.null(point))   
                { point <- roll }   
                if (count == 1 && (roll == 7 || roll == 11))   
                {  result <- "Win" }   
                else if (count == 1 && (roll == 2 || roll == 3 || roll == 12))    
                { result <- "Loss" }    
                else if (count > 1 && roll == 7 )   
                { result <- "Loss" }    
                else if (count > 1 && point == roll)   
                { result <- "Win" }    
                else { count <- count + 1 }   
            }   
            result   
    }  
  
    ```  
  
2.  Чтобы смоделировать одну игру в кости, выполните эту функцию.  
  
    ```R  
    rollDice()   
    ```  
  
    Выиграли вы или проиграли?  
  
Теперь посмотрим, как можно выполнять функцию многократно, чтобы создать моделирование, позволяющее определить вероятность выигрыша.  
  
## Создание моделирования  
Чтобы выполнить произвольную функцию в контексте компьютера [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], следует вызвать функцию *rxExec*. Хотя функция *rxExec* также поддерживает распределенное выполнение функции в параллельном режиме на разных узлах или ядрах в контексте сервера, здесь вы используете ее просто для запуска своей функции на сервере.  
  
1.  Вызовите эту пользовательскую функцию в качестве аргумента *rxExec* вместе с другими параметрами, которые изменяют симулятор.  
  
    ```R  
    sqlServerExec <- rxExec(rollDice, timesToRun=20, RNGseed="auto")   
    length(sqlServerExec)   
    ```  
  
    -   Аргумент *timesToRun* позволяет указать, сколько раз должна выполняться функция.  В этом случае кости бросаются 20 раз.  
  
    -   Аргументы *RNGseed* и *RNGkind* позволяют управлять генерацией случайных чисел. Если параметр *RNGseed* имеет значение **auto**, в каждом рабочем процессе инициализируется параллельный поток случайных чисел.  
  
2.  Функция *rxExec* создает список с одним элементом для каждого запуска, однако, пока список не заполнится, практически ничего происходить не будет. Когда все итерации будут завершены, строка, начинающаяся с `length`, вернет значение.  
  
    После этого можно перейти к следующему шагу, чтобы получить сводку по выигрышам и проигрышам.  
  
3.  Преобразуйте полученный список в вектор с помощью функции R *unlist* и обобщите результаты с помощью функции *table*.  
  
    ```R  
    table(unlist(sqlServerExec))  
    ```  
  
    Результаты должны выглядеть примерно так:  
  
     *Проигрыш Выигрыш*   
     *12 8*  
  
## Заключение  
В этом учебнике вы научились выполнять следующие задачи:  
  
-   получать данные [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] для использования при анализе;  
  
-   создавать и изменять источники данных в R;  
  
-   передавать модели, данные и диаграммы между рабочей станцией и сервером [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].  
  
>  [!TIP]
> 
> Если вы хотите поупражняться в использовании этих приемов на основе более крупного набора данных (10 миллионов наблюдений), файлы данных можно получить на странице [http://packages.revolutionanalytics.com/datasets](http://packages.revolutionanalytics.com/datasets).  
>   
> Чтобы еще раз использовать это пошаговое руководство с большими файлами данных, просто загрузите данные и измените источники данных следующим образом:   
>  -   Задайте переменные *ccFraudCsv* и *ccScoreCsv* так, чтобы они указывали на новые файлы данных.     
>  -   Измените имя таблицы, указанное в *sqlFraudTable*, на *ccFraud10*    
>  -   Измените имя таблицы, указанное в *sqlScoreTable*, на *ccFraudScore10*   
  
## Предыдущий шаг  
[Перенос данных между SQL Server и файлом XDF (глубокое погружение в обработку и анализ данных)](../../advanced-analytics/r-services/move-data-between-sql-server-and-xdf-file-data-science-deep-dive.md)  
  
  
  
