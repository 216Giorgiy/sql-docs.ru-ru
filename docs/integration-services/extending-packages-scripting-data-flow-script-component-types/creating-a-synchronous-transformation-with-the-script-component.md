---
title: "Создание синхронного преобразования с помощью компонента скрипта | Документы Microsoft"
ms.custom: 
ms.date: 03/17/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology:
- docset-sql-devref
ms.tgt_pltfrm: 
ms.topic: reference
applies_to:
- SQL Server 2016 Preview
dev_langs:
- VB
helpviewer_keywords:
- synchronous outputs [Integration Services]
- transformation components [Integration Services]
- Script component [Integration Services], transformation components
ms.assetid: aa1bee1a-ab06-44d8-9944-4bff03d73016
caps.latest.revision: 64
author: douglaslMS
ms.author: douglasl
manager: jhubbard
ms.workload: On Demand
ms.translationtype: MT
ms.sourcegitcommit: 2edcce51c6822a89151c3c3c76fbaacb5edd54f4
ms.openlocfilehash: 3d4a507c31f77449aba7eb884c39bf68c7c78581
ms.contentlocale: ru-ru
ms.lasthandoff: 09/26/2017

---
# <a name="creating-a-synchronous-transformation-with-the-script-component"></a>Создание синхронного преобразования с помощью компонента скрипта
  Компонент преобразования используется в потоке данных пакета служб [!INCLUDE[ssISnoversion](../../includes/ssisnoversion-md.md)] для изменения и анализа данных, передаваемых из источника в назначение. Преобразование с синхронными выходами обрабатывает каждую входную строку, проходящую через компонент. Преобразование с асинхронными выходами ожидает, пока не получит все входные строки, чтобы завершить обработку. В этом разделе рассматривается синхронное преобразование. Сведения об асинхронных преобразованиях см. в разделе [Создание асинхронного преобразования с помощью компонента скрипта](../../integration-services/extending-packages-scripting-data-flow-script-component-types/creating-an-asynchronous-transformation-with-the-script-component.md). Дополнительные сведения о различиях между синхронными и асинхронными выходами см. в разделе [основные сведения о синхронных и асинхронных преобразованиях](../../integration-services/understanding-synchronous-and-asynchronous-transformations.md).  
  
 Обзор компонента скрипта см. в разделе [расширение потока данных с помощью компонента скрипта](../../integration-services/extending-packages-scripting/data-flow-script-component/extending-the-data-flow-with-the-script-component.md).  
  
 Компонент скрипта и формируемый им код инфраструктуры значительно упрощают процесс создания пользовательских компонентов потока данных. Тем не менее, чтобы понять, как работает компонент скрипта, вам может быть полезно прочитать шаги, которые необходимо выполнить при разработке пользовательского компонента потока данных в разделе на [разработке пользовательского компонента потока данных](../../integration-services/extending-packages-custom-objects/data-flow/developing-a-custom-data-flow-component.md)и в особенности [Разработка пользовательского компонента преобразования с синхронными выходами](../../integration-services/extending-packages-custom-objects-data-flow-types/developing-a-custom-transformation-component-with-synchronous-outputs.md).  
  
## <a name="getting-started-with-a-synchronous-transformation-component"></a>Приступая к работе над компонентом синхронного преобразования  
 При добавлении компонента скрипта в область потока данных [!INCLUDE[ssIS](../../includes/ssis-md.md)] конструкторе **Выбор типа компонента скрипта** диалоговое окно, Выбор типа компонента источника, назначения или преобразования. В этом диалоговом окне выберите **преобразования**.  
  
## <a name="configuring-a-synchronous-transformation-component-in-metadata-design-mode"></a>Настройка компонента синхронного преобразования в режиме конструктора метаданных  
 После выбора параметра для создания компонента преобразования, настроить компонент с помощью **редактор преобразования «скрипт»**. Дополнительные сведения см. в разделе [Настройка компонента скрипта в редакторе компонентов скрипта](../../integration-services/extending-packages-scripting/data-flow-script-component/configuring-the-script-component-in-the-script-component-editor.md).  
  
 Чтобы задать язык скрипта для компонента скрипта, необходимо задать **ScriptLanguage** свойство **сценарий** страница **редактор преобразования «скрипт»**.  
  
> [!NOTE]  
>  Чтобы задать значение по умолчанию языка скрипта для компонента скрипта, используйте **язык сценариев** параметр **Общие** страница **параметры** диалоговое окно. Дополнительные сведения см. в разделе [общий список страницы](https://msdn.microsoft.com/library/ms189436(v=sql.110).aspx).  
  
 Компонент преобразования потока данных имеет один вход и поддерживает один или несколько выходов. Настройка входа и выходов компонента — один из шагов, которые необходимо выполнить в режиме конструктора метаданных с помощью **редактор преобразования «скрипт»**, прежде чем писать пользовательский скрипт.  
  
### <a name="configuring-input-columns"></a>Настройка входных столбцов  
 Компонент преобразования имеет один вход.  
  
 На **входные столбцы** страница **редактор преобразования «скрипт»** список столбцов содержит доступные столбцы из выходных данных вышестоящего компонента потока данных. Выделите столбцы, которые хотите преобразовать или передать. Пометьте все столбцы, участвующие в преобразовании, как доступные для чтения и записи.  
  
 Дополнительные сведения о **входные столбцы** страница **редактор преобразования «скрипт»**, в разделе [редактор преобразования «скрипт» &#40; страницы столбцы входных данных &#41;](../../integration-services/data-flow/transformations/script-transformation-editor-input-columns-page.md).  
  
### <a name="configuring-inputs-outputs-and-output-columns"></a>Настройка входов, выходов и выходных столбцов  
 Компонент преобразования поддерживает один или несколько выходов.  
  
 На **входы и выходы** страница **редактор преобразования «скрипт»**, вы увидите, что был создан один выход, но результат не содержит столбцов. На этой странице редактора может понадобиться настроить следующие элементы.  
  
-   Создайте один или несколько дополнительных выходов, например, имитацию вывода ошибок для строк, содержащих непредвиденные значения. Используйте **Добавить выходные данные** и **удалить Выход** кнопки для управления выходами компонента синхронного преобразования. Все входные строки направляются во все доступные выходы, если не указано, что необходимо перенаправлять каждую строку в тот или иной определенный выход. Можно указать, что необходимо перенаправлять строки, указав ненулевое целочисленное значение для **ExclusionGroup** свойство для выходов. Конкретное целочисленное значение, введенное в **ExclusionGroup** для идентификации выходов не имеет значения, но необходимо использовать то же число постоянно для указанной группы выходных данных.  
  
    > [!NOTE]  
    >  Можно также использовать ненулевое значение **ExclusionGroup** значение свойства с единственным выходом, если не требуется выводить все строки. Однако в этом случае необходимо явно вызвать **DirectRowTo\<outputbuffer >** метод для каждой строки, которую требуется отправить в выход.  
  
-   Присвойте как можно более описательные имена входу и выходам. Компонент скрипта использует эти имена для создания типизированных свойств метода доступа, с помощью которых в скрипте выполняется обращение к входам и выходам.  
  
-   Для синхронных преобразований оставьте столбцы без изменения. Обычно синхронное преобразование не добавляет столбцы в поток данных. Данные изменяются на месте, прямо в буфере, который передается в следующий компонент потока данных. В подобной ситуации нет необходимости добавлять и настраивать выходные столбцы явным образом для выходов преобразования. Выходы отображаются в редакторе без явно определенных столбцов.  
  
-   Добавьте новые столбцы для имитации вывода ошибок для ошибок на уровне строк. Обычно несколько выходов в одной **ExclusionGroup** имеют один и тот же набор выходных столбцов. Однако при создании имитации вывода ошибок может оказаться целесообразным добавление нескольких столбцов, содержащих сведения об ошибках. Сведения о том, как подсистема обработки потока данных обрабатывает ошибочные строки, см. в разделе [с помощью вывода ошибок в компоненте потока данных](../../integration-services/extending-packages-custom-objects/data-flow/using-error-outputs-in-a-data-flow-component.md). Обратите внимание на то, что в компоненте скрипта необходимо написать собственный код для заполнения дополнительных столбцов соответствующими сведениями об ошибках. Дополнительные сведения см. в разделе [имитация вывода ошибок для компонента скрипта](../../integration-services/extending-packages-scripting-data-flow-script-component-examples/simulating-an-error-output-for-the-script-component.md).  
  
 Дополнительные сведения о **входы и выходы** страница **редактор преобразования «скрипт»**, в разделе [редактор преобразования «скрипт» &#40; входов и выходов страницу &#41;](../../integration-services/data-flow/transformations/script-transformation-editor-inputs-and-outputs-page.md).  
  
### <a name="adding-variables"></a>Добавление переменных  
 Если вы хотите использовать существующих переменных в сценарии, можно добавить их в **ReadOnlyVariables** и **ReadWriteVariables** поля свойств на **сценарий** страницы **Редактор преобразования «скрипт»**.  
  
 Если в поле свойства добавляются несколько переменных, их имена нужно разделять запятыми. Можно также выбрать несколько переменных, нажав кнопку с многоточием (**...** ) рядом с **ReadOnlyVariables** и **ReadWriteVariables** поля свойств, а затем выбрав переменные в **Выбор переменных** диалоговое окно.  
  
 Общие сведения об использовании переменных в компоненте скрипта см. в разделе [использование переменных в компоненте скрипта](../../integration-services/extending-packages-scripting/data-flow-script-component/using-variables-in-the-script-component.md).  
  
 Дополнительные сведения о **сценарий** страница **редактор преобразования «скрипт»**, в разделе [редактор преобразования «скрипт» &#40; Страница «скрипт» &#41; ](../../integration-services/data-flow/transformations/script-transformation-editor-script-page.md).  
  
## <a name="scripting-a-synchronous-transformation-component-in-code-design-mode"></a>Создание скрипта компонента синхронного преобразования в режиме конструктора кода  
 После настройки метаданных для компонента можно написать пользовательский скрипт. В **редактор преобразования «скрипт»**на **сценарий** щелкните **изменить скрипт** Открытие [!INCLUDE[msCoName](../../includes/msconame-md.md)] [!INCLUDE[vsprvs](../../includes/vsprvs-md.md)] средств для приложений (VSTA) интегрированной среды разработки где можно добавить пользовательский скрипт. Язык сценариев, который вы используете зависит от того, можно выбрать [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual Basic или [!INCLUDE[msCoName](../../includes/msconame-md.md)] Visual C# как язык скриптов для **ScriptLanguage** свойство **сценария** страница.  
  
 Важные сведения, относящиеся ко всем типам компонентов, созданных с помощью компонента скрипта см. в разделе [кодировании и отладке компонента скрипта](../../integration-services/extending-packages-scripting/data-flow-script-component/coding-and-debugging-the-script-component.md).  
  
### <a name="understanding-the-auto-generated-code"></a>Основные сведения об автоматически создаваемом коде  
 При открытии интегрированной среды разработки VSTA после создания и настройки компонента преобразования, редактируемый **ScriptMain** класс появится в редакторе кода с заглушкой для **ProcessInputRow** метод. **ScriptMain** используется класс будет написания собственного кода, и **ProcessInputRow** является наиболее важным методом в компоненте преобразования.  
  
 При открытии **обозревателя проектов** окна в VSTA, можно увидеть, что компонент скрипта также создал только для чтения **BufferWrapper** и **ComponentWrapper** проекта элементы. **ScriptMain** класс наследует от **UserComponent** класса в **ComponentWrapper** элемент проекта.  
  
 Во время выполнения подсистема обработки потока данных вызывает **ProcessInput** метод в **UserComponent** класс, переопределяющий <xref:Microsoft.SqlServer.Dts.Pipeline.ScriptComponent.ProcessInput%2A> метод <xref:Microsoft.SqlServer.Dts.Pipeline.ScriptComponent> родительского класса. **ProcessInput** метод в свою очередь выполняет цикл по строкам во входном буфере и вызывает **ProcessInputRow** метод один раз для каждой строки.  
  
### <a name="writing-your-custom-code"></a>Написание пользовательского кода  
 Компонент преобразования с синхронными выходами является наиболее простым для написания компонентом потока данных. Например, в образце с единственным выходом, который приведен далее в этом разделе, содержится следующий пользовательский код:  
  
```vb  
Row.City = UCase(Row.City)  
```  
  
```csharp  
Row.City = (Row.City).ToUpper();  
  
```  
  
 Чтобы завершить создание пользовательского компонента синхронного преобразования, используйте переопределенный **ProcessInputRow** метод для преобразования данных в каждой строке входного буфера. Когда этот буфер оказывается заполненным, подсистема обработки потока данных передает его следующему компоненту в потоке данных.  
  
 В зависимости от требований, можно также создать скрипт в **PreExecute** и **PostExecute** методы, доступные в **ScriptMain** классом для выполнения предварительной или окончательной обработки.  
  
### <a name="working-with-multiple-outputs"></a>Работа с несколькими выходами  
 Направление входных строк в один из двух или более возможных выходов не требует большого объема дополнительного пользовательского кода по сравнению со скриптом с единственным выходом, который был рассмотрен выше. Например, в примере с двумя выходами, который приведен далее в этом разделе, содержится следующий пользовательский код:  
  
```vb  
Row.City = UCase(Row.City)  
If Row.City = "REDMOND" Then  
    Row.DirectRowToMyRedmondAddresses()  
Else  
    Row.DirectRowToMyOtherAddresses()  
End If  
```  
  
```csharp  
Row.City = (Row.City).ToUpper();  
  
if (Row.City=="REDMOND")  
{  
    Row.DirectRowToMyRedmondAddresses();  
}  
else  
{  
    Row.DirectRowToMyOtherAddresses();  
}  
```  
  
 В этом примере компонент скрипта создает **DirectRowTo\<OutputBufferX >** методы на основе имен выходных данных, которые вы настроили. Можно использовать аналогичный код для направления строк ошибок в имитированный вывод ошибок.  
  
## <a name="examples"></a>Примеры  
 Приведенные здесь примеры демонстрируют пользовательский код, который является обязательным в **ScriptMain** класса для создания компонента синхронного преобразования.  
  
> [!NOTE]  
>  В этих примерах используются **Person.Address** в таблицу **AdventureWorks** образца базы данных и передается ее первый и четвертый столбец **intAddressID** и  **Город nvarchar (30)** поток данных. Эти же данные используются в образцах источника, преобразования и назначения, приведенных в этом разделе. Для каждого примера приведены необходимые дополнительные условия и принимаемые предположения.  
  
### <a name="single-output-synchronous-transformation-example"></a>Пример синхронного преобразования с единственным выходом  
 В этом примере демонстрируется компонент синхронного преобразования с единственным выходом. Это преобразование передает **AddressID** и преобразует **Город** в верхний регистр.  
  
 Для запуска этого образца кода необходимо настроить пакет и компонент следующим образом.  
  
1.  Добавьте новый компонент скрипта в область конструктора потока данных и настройте его в качестве преобразования.  
  
2.  Соедините выход источника или другого преобразования с новым компонентом преобразования в конструкторе служб [!INCLUDE[ssIS](../../includes/ssis-md.md)]. Этот вывод должен предоставлять данные из **Person.Address** таблицу **AdventureWorks** образца базы данных, содержащий **AddressID** и **Город**  столбцов.  
  
3.  Откройте **редактор преобразования «скрипт»**. На **входные столбцы** выберите **AddressID** и **Город** столбцов. Знак **Город** столбца для чтения и записи.  
  
4.  На **входы и выходы** страницы, измените имя входа и выхода более описательные имена, такие как **MyAddressInput** и **MyAddressOutput**. Обратите внимание, что **SynchronousInputID** выходных данных соответствует **идентификатор** входных данных. Таким образом, нет необходимости добавлять и настраивать выходные столбцы.  
  
5.  На **сценарий** щелкните **изменить скрипт** и введите следующий скрипт. Затем закройте среду разработки скриптов и **редактор преобразования «скрипт»**.  
  
6.  Создайте и настройте компонент назначения, который ожидает, что **AddressID** и **Город** столбцы, такие как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] назначения или образец компонента назначения, показанный в [Создание назначения с помощью компонента скрипта](../../integration-services/extending-packages-scripting-data-flow-script-component-types/creating-a-destination-with-the-script-component.md). Затем соедините выход преобразования с компонентом назначения. Можно создать целевую таблицу, выполнив следующую [!INCLUDE[tsql](../../includes/tsql-md.md)] в **AdventureWorks** базы данных:  
  
    ```sql
    CREATE TABLE [Person].[Address2]([AddressID] [int] NOT NULL,  
        [City] [nvarchar](30) NOT NULL)  
    ```  
  
7.  Запустите образец.  
  
```vb  
Public Class ScriptMain  
    Inherits UserComponent  
  
    Public Overrides Sub MyAddressInput_ProcessInputRow(ByVal Row As MyAddressInputBuffer)  
  
        Row.City = UCase(Row.City)  
  
    End Sub  
  
End Class  
```  
  
```csharp  
public class ScriptMain:  
    UserComponent  
  
{  
    public override void MyAddressInput_ProcessInputRow(MyAddressInputBuffer Row)  
    {  
  
        Row.City = (Row.City).ToUpper();  
  
    }  
  
}  
```  
  
### <a name="two-output-synchronous-transformation-example"></a>Пример синхронного преобразования с двумя выходами  
 В этом примере демонстрируется компонент синхронного преобразования с двумя выходами. Это преобразование передает **AddressID** и преобразует **Город** в верхний регистр. Если названием города является «Redmond», строка направляется в один выход. Все остальные строки направляются в другой выход.  
  
 Для запуска этого образца кода необходимо настроить пакет и компонент следующим образом.  
  
1.  Добавьте новый компонент скрипта в область конструктора потока данных и настройте его в качестве преобразования.  
  
2.  Соедините выход источника или другого преобразования с новым компонентом преобразования в конструкторе служб [!INCLUDE[ssIS](../../includes/ssis-md.md)]. Этот вывод должен предоставлять данные из **Person.Address** таблицу **AdventureWorks** образца базы данных, который содержит по крайней мере **AddressID** и  **Город** столбцов.  
  
3.  Откройте **редактор преобразования «скрипт»**. На **входные столбцы** выберите **AddressID** и **Город** столбцов. Знак **Город** столбца для чтения и записи.  
  
4.  На **входы и выходы** создайте второй выход. После добавления нового выхода убедитесь, что можно задать его **SynchronousInputID** для **идентификатор** входных данных. Это свойство уже задано для первого выхода, создаваемого по умолчанию. Для каждого выхода значение **ExclusionGroup** свойства же ненулевое значение, указывающее, распределение входных строк между двумя взаимоисключающими выходами. Нет необходимости добавлять какие-либо выходные столбцы в выходы.  
  
5.  Переименуйте вход и выходы более описательные имена, такие как **MyAddressInput**, **MyRedmondAddresses**, и **MyOtherAddresses**.  
  
6.  На **сценарий** щелкните **изменить скрипт** и введите следующий скрипт. Затем закройте среду разработки скриптов и **редактор преобразования «скрипт»**.  
  
7.  Создайте и настройте два компонента назначения, которые ожидают **AddressID** и **Город** столбцы, такие как [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] назначения, неструктурированный файл или образец компонента назначения показанные в [Создание назначения с помощью компонента скрипта](../../integration-services/extending-packages-scripting-data-flow-script-component-types/creating-a-destination-with-the-script-component.md). Затем соедините каждый из выходов преобразования с одним из компонентов назначения. Можно создать целевые таблицы, запустив [!INCLUDE[tsql](../../includes/tsql-md.md)] следующую (с уникальными именами таблиц) в **AdventureWorks** базы данных:  
  
    ```sql
    CREATE TABLE [Person].[Address2](  
        [AddressID] [int] NOT NULL,  
        [City] [nvarchar](30) NOT NULL  
    ```  
  
8.  Запустите образец.  
  
```vb  
Public Class ScriptMain  
    Inherits UserComponent  
  
    Public Overrides Sub MyAddressInput_ProcessInputRow(ByVal Row As MyAddressInputBuffer)  
  
        Row.City = UCase(Row.City)  
  
        If Row.City = "REDMOND" Then  
            Row.DirectRowToMyRedmondAddresses()  
        Else  
            Row.DirectRowToMyOtherAddresses()  
        End If  
  
    End Sub  
  
End Class  
```  
  
```csharp  
public class ScriptMain:  
    UserComponent  
  
public override void MyAddressInput_ProcessInputRow(MyAddressInputBuffer Row)  
    {  
  
        Row.City = (Row.City).ToUpper();  
  
        if (Row.City == "REDMOND")  
        {  
            Row.DirectRowToMyRedmondAddresses();  
        }  
        else  
        {  
            Row.DirectRowToMyOtherAddresses();  
        }  
  
    }  
}  
```  
  
## <a name="see-also"></a>См. также:  
 [Основные сведения о синхронных и асинхронных преобразованиях] (~/integration-services/understanding-synchronous-and-asynchronous-transformations.md   
 [Создание асинхронного преобразования с помощью компонента скрипта] (~/integration-services/extending-packages-scripting-data-flow-script-component-types/creating-an-asynchronous-transformation-with-the-script-component.md   
 [Разработка пользовательского компонента преобразования с синхронными выходами] (~/integration-services/extending-packages-custom-objects-data-flow-types/developing-a-custom-transformation-component-with-synchronous-outputs.md  
  
  



