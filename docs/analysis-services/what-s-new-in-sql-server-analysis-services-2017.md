---
title: "Какой &#39; новые возможности служб Analysis Services SQL Server 2017 г. | Документы Microsoft"
ms.custom: 
ms.date: 07/27/2017
ms.prod: sql-server-2017
ms.reviewer: 
ms.suite: 
ms.technology:
- analysis-services
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 1eb6afc9-76ed-45a2-a188-374a4fc23224
caps.latest.revision: 17
author: Minewiskan
ms.author: owend
manager: erikre
ms.translationtype: MT
ms.sourcegitcommit: a6aeda8e785fcaabef253a8256b5f6f7a842a324
ms.openlocfilehash: eb98483d6237f2db2fdb0cb9aa444dd938a431f0
ms.contentlocale: ru-ru
ms.lasthandoff: 09/21/2017

---
# <a name="what39s-new-in-sql-server-2017-analysis-services"></a>Какой &#39; новые возможности служб Analysis Services SQL Server 2017 г.
[!INCLUDE[tsql-appliesto-ssvNxt-xxxx-xxxx-xxx](../includes/tsql-appliesto-ssvnxt-xxxx-xxxx-xxx.md)]


## <a name="sql-server-2017-analysis-services-rc2"></a>Analysis Services SQL Server 2017 г. RC2
В этом выпуске нет новых функций. В этом выпуске можно отнести исправления ошибок и производительности.

## <a name="sql-server-2017-analysis-services-rc1"></a>SQL Server 2017 г Analysis Services RC1
В этом выпуске нет новых компонентов, однако этот выпуск включает дополнительные улучшения для [динамические административные представления](https://docs.microsoft.com/sql/analysis-services/instances/use-dynamic-management-views-dmvs-to-monitor-analysis-services) (DMV) для табличных моделей на уровне совместимости 1200 и 1400.

DISCOVER_CALC_DEPENDENCY теперь работает с табличными моделями 1200 и 1400. Табличные модели 1400 Показать зависимости между M секций, выражения M и структурированными источниками данных. Дополнительные сведения см. в разделе [блога службы Analysis Services](https://blogs.msdn.microsoft.com/analysisservices/).

Для этого динамического административного Представления, которое используется для отображения мер размерности различных клиентских средств включены улучшения MDSCHEMA_MEASUREGROUP_DIMENSIONS. Например функция Просмотр в сводных таблицах Excel позволяет пользователю кросс детализацию измерения, связанные с выбранной меры. Этот выпуск исправляет столбцы количества элементов, которые ранее отображение неправильные значения.

## <a name="sql-server-analysis-services-ctp-21"></a>SQL Server Analysis Services CTP-версии 2.1
В этом выпуске нет новых функций. В этом выпуске можно отнести исправления ошибок и производительности и улучшения [динамические административные представления](https://docs.microsoft.com/sql/analysis-services/instances/use-dynamic-management-views-dmvs-to-monitor-analysis-services) (DMV). Динамические административные представления являются запросами в SQL Server Profiler, которые возвращают сведения о локальных операциях сервера и работоспособности сервера. Дополнительные сведения см. в разделе [блога службы Analysis Services](https://blogs.msdn.microsoft.com/analysisservices/).

## <a name="sql-server-analysis-services-ctp-20"></a>SQL Server Analysis Services CTP 2.0
Этот выпуск содержит множество усовершенствований для табличной модели, включая:

* Безопасность на уровне объектов для защиты метаданных табличных моделей.
* Улучшения производительности транзакций для отклика опыт разработки.
* Динамическое административное представление улучшения для 1200 и 1400 моделей отчетов и Включение анализа зависимостей.
* Улучшения возможности разработки для подробных выражений строк.
* Иерархии и столбец повторно использовать подключаться в важнее местах в списке полей Power BI.
* Дата отношения для простого создания связи измерения даты, на основе полей даты.
* Вариант установки по умолчанию для служб Analysis Services теперь находится в табличном режиме.
* Новые источники данных для получения данных (Power Qery).
* Редактор DAX для SSDT.
* Для запросов M поддерживают существующими источниками данных DirectQuery.
* Усовершенствования SSMS, такие как просмотр, редактирование и сценарии для структурированными источниками данных.

Чтобы получить дополнительные сведения об этом выпуске CTP 2.0, в разделе [блога службы Analysis Services](https://blogs.msdn.microsoft.com/analysisservices/).

## <a name="sql-server-analysis-services-on-windows-ctp-14"></a>SQL Server Analysis Services в Windows CTP-версии 1.4
[SQL Server Data Tools (SSDT)](https://docs.microsoft.com/sql/ssdt/sql-server-data-tools-ssdt-release-candidate) и [SQL Server Management Studio (SSMS)](https://docs.microsoft.com/sql/ssms/sql-server-management-studio-ssms-release-candidate) предварительных выпусков совпадают с предварительных выпусков 2017 г. SQL Server. Убедитесь, что позволяет получить новые возможности последней версии. Дополнительные сведения см. в разделе [блога службы Analysis Services](https://blogs.msdn.microsoft.com/analysisservices/).



## <a name="sql-server-analysis-services-on-windows-ctp-13"></a>SQL Server Analysis Services в Windows CTP-версии 1.3

### <a name="encoding-hints"></a>Кодирование подсказки

Этой версии появилась кодирования подсказки — дополнительная возможность, используемый для оптимизации обработки (обновления данных) для больших табличных моделей в памяти. Для лучшего понимания кодировка, в разделе [производительности СУБД из табличных моделей в SQL Server 2012 Analysis Services](https://msdn.microsoft.com/library/dn393915.aspx) Технический документ, чтобы лучше понять кодировки. Описанный здесь процесс кодирования применяется в CTP-версии 1.3.

* Значение кодировки обеспечивает более высокую производительность запросов, для столбцов, которые обычно используются только для агрегатов.

* Кодирование хэш является предпочтительным для группирования столбцы (часто значения, таблица измерения) и внешние ключи. Строковые столбцы всегда являются хэш в кодировке.

Числовые столбцы можно использовать любой из этих методов кодирования. Когда службы Analysis Services начинает обработку таблицы, если любой из таблиц пуст (с или без секций) или выполняемой операции обработки всей таблицы, для каждого числового столбца определить, следует ли применять значение или кодировка хэш взяты образцы значений . По умолчанию значение кодировки выбирается при образца различающихся значений в столбце является достаточно большим, — в противном случае кодировка хэша будет обычно обеспечивают более высокую степень сжатия. Существует возможность для служб Analysis Services для изменения метода шифрования после столбца частично обработки в зависимости от получения дополнительных сведений о распределении данных и перезапустить процесс кодирования. Конечно, это приводит к увеличению времени обработки и неэффективно. Техническая документация настройки производительности рассматривается более подробно повторно кодировка и описывает, как сделать это с помощью приложения SQL Server Profiler.

Указания кодировки в CTP-версии 1.3 позволяют разработчику модели, указав предпочтение, метод шифрования, заданный знания из профилирование данных и/или в ответ на повторная кодировка события трассировки. Так как вычисление агрегата для хэш кодировке столбцы медленнее, чем для столбцов, значение в кодировке, кодирование может быть указан как подсказку для таких столбцов. Не гарантируется, что будет применяться предпочтений; Поэтому это указание, в отличие от параметра. Чтобы задать указание для кодировки, присвойте свойству EncodingHint для столбца. Возможные значения: «Default», «Значение» и «Хэш». На момент написания статьи свойство еще недоступно в SSDT, поэтому необходимо задать метаданные на основе JSON, табличных языка скриптов модели (TMSL) или табличной модели объектов (TOM). Следующий фрагмент JSON на основе метаданных из файла Model.bim указывает значение для столбца Sales Amount кодировку.

```
{
    "name": "Sales Amount",
    "dataType": "decimal",
    "sourceColumn": "SalesAmount",
    "formatString": "\\$#,0.00;(\\$#,0.00);\\$#,0.00",
    "sourceProviderType": "Currency",
    "encodingHint": "Value"
}
```

### <a name="extended-events-not-working-in-ctp-13"></a>Расширенные события, не работает в CTP-версии 1.3
Расширенные события SSAS не работают в CTP-версии 1.3. Исправление планируется в следующей CTP-версии.

## <a name="sql-server-analysis-services-on-windows-ctp-12"></a>Службы SQL Server Analysis Services в Windows CTP 1.2

В этом выпуске нет новых функций. В число улучшений входят исправления ошибок и повышение производительности.

Улучшает работу последнего предварительного выпуска для SQL Server данных Tools (SSDT), которой совпадает с 2017 г CTP-версия SQL Server 1.2, новый современный интерфейс получение данных появилась в CTP-версии 1.1 в новое меню редактора запросов и функциональные возможности быстрого доступа. 

## <a name="sql-server-analysis-services-on-windows-ctp-11"></a>Службы SQL Server Analysis Services в Windows CTP 1.1 

В этом выпуске представлены улучшения для табличных моделей. 

### <a name="1400-compatibility-level-for-tabular-models"></a>Уровень совместимости 1400 для табличных моделей
  Для использования возможностей и функций, описываемых в этом разделе, для новых или существующих табличных моделей необходимо задать уровень совместимости 1400. Модели с уровнем совместимости 1400 нельзя развертывать в SQL Server 2016 с пакетом обновления 1 (SP1) или более ранней версии либо переводить на более низкий уровень совместимости.
  
  Чтобы создать новый проект табличной модели с уровнем совместимости 1400 или перевести существующий проект на этот уровень, скачайте и установите **предварительный выпуск** [SQL Server Data Tools (SSDT) 17.0 RC2](https://go.microsoft.com/fwlink?LinkId=837939). 
  
В SSDT можно выбрать новый уровень совместимости 1400 при создании проектов табличной модели. 

![AS_NewTabular1400Project](../analysis-services/media/as-newtabular1400project.png)

>[!NOTE]
> Интегрированная рабочая область в декабрьском выпуске SQL Server Data Tools (SSDT) поддерживает уровень совместимости 1400. При создании проектов табличной модели в экземпляре сервера рабочей области этот экземпляр или любой экземпляр, в котором производится развертывание, должен иметь версию [!INCLUDE[ssSQLv14_md](../includes/sssqlv14-md.md)] CTP 1.1. 

Для обновления существующей табличной модели в SSDT, в обозревателе решений щелкните правой кнопкой мыши **Model.bim**, а затем в **свойства**, задайте **уровень совместимости** свойства ** SQL Server 2017 г. (1400)**. 

![AS_Model_Properties](../analysis-services/media/as-model-properties.png)

### <a name="modern-get-data-experience"></a>Современный интерфейс получения данных
В последнем предварительном выпуске SQL Server Data Tools (SSDT), который соответствует выпуску [!INCLUDE[ssSQLv14_md](../includes/sssqlv14-md.md)] CTP 1.1, появился современный интерфейс **получения данных** для табличных моделей с уровнем совместимости 1400. Он основан на аналогичном интерфейсе в Power BI Desktop и Microsoft Excel 2016.

![AS_Get_Data_in_SSDT](../analysis-services/media/as-get-data-in-ssdt.png)

>[!NOTE]
> В этом выпуске поддерживается ограниченный набор источников данных. В будущих обновлениях будут поддерживаться дополнительные источники данных и возможности.

Дополнительные сведения о современном интерфейсе получения данных см. в [блоге команды разработчиков служб Analysis Services](https://blogs.msdn.microsoft.com/analysisservices/2016/12/16/introducing-a-modern-get-data-experience-for-sql-server-2017-on-windows-ctp-1-1-for-analysis-services/).

## <a name="ragged-hierarchies"></a>Неоднородные иерархии
В табличных моделях можно моделировать иерархии типа "родители-потомки". Иерархии с разным количеством уровней часто называют неоднородными. По умолчанию неоднородные иерархии отображаются с пустыми полями для уровней ниже последнего дочернего уровня. Вот пример неоднородной иерархии на организационной диаграмме:

![AS_Ragged_Hierarchy](../analysis-services/media/as-ragged-hierarchy.png)

В этом выпуске появилось свойство **Скрыть члены** . Свойству **Скрыть члены** иерархии можно присвоить значение **Скрыть пустые члены**.

![AS_Hide_Blank_Members](../analysis-services/media/as-hide-blank-members.png)

 >[!NOTE]
 > Пустые члены в модели представлены пустым значением DAX, а не пустой строкой.

Если задано значение **Скрыть пустые члены**и модель развернута, более удобную для восприятия версию иерархии можно просмотреть в таких клиентских средствах создания отчетов, как Excel.

![AS_Non_Ragged_Hierarchy](../analysis-services/media/as-non-ragged-hierarchy.png)

### <a name="detail-rows"></a>Строки детализации
Теперь можно определить настраиваемый набор строк, на основе которого формируется значение меры. Строки детализации похожи на действие детализации по умолчанию в многомерных моделях. Это позволяет конечным пользователям просматривать более подробные данные, чем на агрегированном уровне. 

На приведенной ниже сводной таблице представлен объем продаж в Интернете по годам из образца табличной модели Adventure Works. Вы можете щелкнуть правой кнопкой мыши ячейку с агрегированным значением меры, а затем выбрать пункт **Показать подробности** , чтобы просмотреть строки детализации.

![AS_Show_Details](../analysis-services/media/as-show-details.png)

По умолчанию отображаются связанные данные из таблицы продаж в Интернете. Такие ограниченные возможности зачастую бесполезны для пользователя, так как таблица может не содержать столбцы, включающие нужную информацию, например имя клиента и сведения о заказе. С помощью строк детализации можно указать свойство **Выражение свойств детализации** для мер.

#### <a name="detail-rows-expression-property-for-measures"></a>Свойство "Выражение строк детализации" для мер
Свойство **Выражение свойств детализации** для мер позволяет создателям моделей настраивать столбцы и строки, возвращаемые конечным пользователям.

![AS_Detail_Rows_Expression_Property](../analysis-services/media/as-detail-rows-expression-property.png)

Функция DAX [SELECTCOLUMNS](https://msdn.microsoft.com/library/mt761759.aspx) часто используется в выражении строк детализации. В приведенном ниже примере определяются столбцы, возвращаемые для строк в таблице продаж в Интернете в образце табличной модели Adventure Works.

```
SELECTCOLUMNS(
    'Internet Sales',
    "Customer First Name", RELATED( Customer[Last Name]),
    "Customer Last Name", RELATED( Customer[First Name]),
    "Order Date", 'Internet Sales'[Order Date],
    "Internet Total Sales", [Internet Total Sales]
)
```

Когда свойство определено и модель развернута, настраиваемый набор строк возвращается при выборе пользователем команды **Показать подробности**. Контекст фильтра выбранной ячейки учитывается автоматически. В этом примере отображаются только строки для значения 2010.

![AS_Detail_Rows](../analysis-services/media/as-detail-rows.png)

#### <a name="default-detail-rows-expression-property-for-tables"></a>Свойство "Выражение строк детализации по умолчанию" для таблиц
Так же как и меры, таблицы имеют свойство для определения выражения строк детализации. Свойство **Выражение строк детализации по умолчанию** используется по умолчанию для всех мер в таблице. Меры, для которых не определено собственное выражение, наследуют выражение от таблицы и отображают набор строк, определенный для таблицы. Это позволяет повторно использовать выражения, а новые меры, добавляемые в таблицу позднее, автоматически наследуют выражение.

![AS_Default_Detail_Rows_Expression](../analysis-services/media/as-default-detail-rows-expression.png)
 
#### <a name="detailrows-dax-function"></a>Функция DAX DETAILROWS
В этом выпуске появилась функция DAX `DETAILROWS` , которая возвращает набор строк, определяемый выражением строк детализации. Она действует аналогично инструкции `DRILLTHROUGH` в MDX, которая также совместима с выражениями строк детализации, определенными в табличных моделях.

Приведенный ниже запрос DAX возвращает набор строк, определенный выражением строк детализации для меры или ее таблицы. Если выражение не определено, возвращаются данные таблицы продаж в Интернете, так как она содержит меру.

```
EVALUATE DETAILROWS([Internet Total Sales])
```

## <a name="dax-enhancements"></a>Улучшения DAX
В этот выпуск входит оператор `IN` для выражений DAX. Она аналогична оператору [`TSQL IN`](/sql-docs/docs/t-sql/language-elements/in-transact-sql), обычно используемому для указания нескольких значений в предложении `WHERE`.

Ранее многозначные фильтры обычно задавались с помощью логического оператора `OR` , как в следующем выражении меры:

```
Filtered Sales:=CALCULATE (
        [Internet Total Sales],
                 'Product'[Color] = "Red"
            || 'Product'[Color] = "Blue"
            || 'Product'[Color] = "Black"
    )
```

С помощью оператора `IN` это стало проще:
```
Filtered Sales:=CALCULATE (
        [Internet Total Sales], 'Product'[Color] IN { "Red", "Blue", "Black" }
    )
```

В этом случае оператор `IN` ссылается на таблицу с одним столбцом и тремя строками — по одному из каждых указанных цветов. Обратите внимание на то, что синтаксис конструктора таблицы предусматривает использование фигурных скобок.

Оператор `IN` функционально эквивалентен функции `CONTAINSROW` .
```
Filtered Sales:=CALCULATE (
        [Internet Total Sales], CONTAINSROW({ "Red", "Blue", "Black" }, 'Product'[Color])
    )
```

Оператор `IN` также можно эффективно использовать с конструкторами таблиц. Например, следующая мера выполняет фильтрацию по сочетанию цвета и категории продукта:
```
Filtered Sales:=CALCULATE (
        [Internet Total Sales],
        FILTER( ALL('Product'),
              ( 'Product'[Color] = "Red"   && Product[Product Category Name] = "Accessories" )
         || ( 'Product'[Color] = "Blue"  && Product[Product Category Name] = "Bikes" )
         || ( 'Product'[Color] = "Black" && Product[Product Category Name] = "Clothing" )
        )
    )
```

Благодаря новому оператору `IN` приведенное выше выражение меры эквивалентно следующему:
```
Filtered Sales:=CALCULATE (
        [Internet Total Sales],
        FILTER( ALL('Product'),
            ('Product'[Color], Product[Product Category Name]) IN
            { ( "Red", "Accessories" ), ( "Blue", "Bikes" ), ( "Black", "Clothing" ) }
        )
    )
```


## <a name="table-level-security"></a>Безопасность на уровне таблицы
В этом выпуске реализована безопасность на уровне таблицы. Помимо ограничения доступа к данным таблиц, можно защищать имена конфиденциальных таблиц. Благодаря этому злоумышленник не сможет узнать о существовании этих таблиц.

Безопасность на уровне таблиц настраивается с помощью метаданных на основе JSON, языка TMSL или табличной модели объектов (TOM). 

Например, приведенный ниже код позволяет защитить таблицу Product в образце табличной модели Adventure Works путем присвоения свойству **MetadataPermission** класса **TablePermission** значения **None**.

```
//Find the Users role in Adventure Works and secure the Product table
ModelRole role = db.Model.Roles.Find("Users");
Table productTable = db.Model.Tables.Find("Product");
if (role != null && productTable != null)
{
    TablePermission tablePermission;
    if (role.TablePermissions.Contains(productTable.Name))
    {
        tablePermission = role.TablePermissions[productTable.Name];
    }
    else
    {
        tablePermission = new TablePermission();
        role.TablePermissions.Add(tablePermission);
        tablePermission.Table = productTable;
    }
    tablePermission.MetadataPermission = MetadataPermission.None;
}
db.Update(UpdateOptions.ExpandFull);
```


