---
title: Использование функции Always Encrypted с драйвером ODBC для SQL Server | Документы Майкрософт
ms.custom: ''
ms.date: 09/01/2018
ms.prod: sql
ms.technology: connectivity
ms.topic: conceptual
ms.assetid: 02e306b8-9dde-4846-8d64-c528e2ffe479
ms.author: v-chojas
manager: craigg
author: MightyPen
ms.openlocfilehash: dd6037cbc40c9cf422c38827d5c96115db33db73
ms.sourcegitcommit: 2ab79765e51913f1df6410f0cd56bf2a13221f37
ms.translationtype: MTE75
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2019
ms.locfileid: "56956065"
---
# <a name="using-always-encrypted-with-the-odbc-driver-for-sql-server"></a>Использование функции Always Encrypted с драйвером ODBC для SQL Server
[!INCLUDE[Driver_ODBC_Download](../../includes/driver_odbc_download.md)]

### <a name="applicable-to"></a>Применимо к

- ODBC Driver 13.1 for SQL Server
- ODBC Driver 17 for SQL Server

### <a name="introduction"></a>Введение

Статья содержит сведения о том, как разрабатывать приложения ODBC, с помощью [Always Encrypted (ядро СУБД)](../../relational-databases/security/encryption/always-encrypted-database-engine.md) и [драйвер ODBC для SQL Server](../../connect/odbc/microsoft-odbc-driver-for-sql-server.md).

Функция Always Encrypted позволяет шифровать конфиденциальные данные в клиентских приложениях, не раскрывая данные или ключи шифрования для SQL Server или Базы данных SQL Azure. Драйвер с поддержкой Always Encrypted, такой как драйвер OLE DB для SQL Server, реализует это за счет прозрачного шифрования и расшифровки конфиденциальных данных в клиентском приложении. Драйвер автоматически определяет, какие параметры запроса соответствуют важным столбцам базы данных (защищенным с помощью Always Encrypted), и шифрует значения этих параметров перед передачей данных в SQL Server или Базу данных SQL Azure. Аналогичным образом драйвер прозрачно расшифровывает данные, полученные из зашифрованных столбцов базы в результатах запроса. Дополнительные сведения см. в разделе [Always Encrypted (ядро СУБД)](../../relational-databases/security/encryption/always-encrypted-database-engine.md).

### <a name="prerequisites"></a>предварительные требования

Настройте функцию постоянного шифрования в базе данных. В процесс настройки входят действия по подготовке ключей постоянного шифрования и настройке шифрования для выбранных столбцов базы данных. Если в базе данных постоянное шифрование еще не настроено, следуйте инструкциям в разделе [Приступая к работе с постоянным шифрованием](../../relational-databases/security/encryption/always-encrypted-database-engine.md#getting-started-with-always-encrypted). В частности база данных должна содержать определения метаданных для главного ключа столбца (CMK), ключ шифрования столбца (CEK) и таблицу, содержащую один или несколько столбцов, зашифрованных с помощью этого ключа CEK.

### <a name="enabling-always-encrypted-in-an-odbc-application"></a>Для включения постоянного шифрования в приложении ODBC

Самым простым способом, чтобы включить параметр шифрования и расшифровки столбца результирующего набора шифрования является, задав значение `ColumnEncryption` ключевое слово строки подключения для **включено**. Ниже приведен пример строки подключения, включающей Always Encrypted.

```
SQLWCHAR *connString = L"Driver={ODBC Driver 13 for SQL Server};Server={myServer};Trusted_Connection=yes;ColumnEncryption=Enabled;";
```

Always Encrypted также можно включить в конфигурации источника данных, используя тот же ключ и значение (которое будет переопределить, задав строку соединения, при его наличии), или программно с помощью `SQL_COPT_SS_COLUMN_ENCRYPTION` атрибута предварительного соединения. Задание значения таким образом переопределяет значение, заданное в строке подключения или имя DSN:

```
 SQLSetConnectAttr(hdbc, SQL_COPT_SS_COLUMN_ENCRYPTION, (SQLPOINTER)SQL_COLUMN_ENCRYPTION_ENABLE, 0);
```

После включения для соединения, поведением постоянного шифрования могут быть изменены для отдельных запросов. См. в разделе [контроля производительности влияние из постоянного](#controlling-the-performance-impact-of-always-encrypted) ниже дополнительные сведения.

Обратите внимание, что включение постоянного шифрования недостаточно для шифрования или расшифровки для успешного выполнения; необходимо также убедиться, что:

- Приложение имеет разрешения *VIEW ANY COLUMN MASTER KEY DEFINITION* и *VIEW ANY COLUMN ENCRYPTION KEY DEFINITION* для базы данных, необходимые для доступа к метаданным о ключах постоянного шифрования в базе данных. Дополнительные сведения см. в разделе [разрешения базы данных](../../relational-databases/security/encryption/always-encrypted-database-engine.md#database-permissions).

- Приложение может получить доступ к CMK, который защищает ключей CEK для запрашиваемых зашифрованных столбцов. Это зависит от поставщика хранилища ключей, который хранит CMK. См. в разделе [работа с хранилищами главных ключей столбцов](#working-with-column-master-key-stores) Дополнительные сведения.

### <a name="retrieving-and-modifying-data-in-encrypted-columns"></a>Получение и изменение данных в зашифрованных столбцах

После включения постоянного шифрования для подключения, вы можете использовать стандартные API-интерфейсы ODBC (см. в разделе [пример кода ODBC](https://code.msdn.microsoft.com/windowsapps/ODBC-sample-191624ae/sourcecode?fileId=51137&pathId=1980325953) или [Справочник по программированию ODBC](https://msdn.microsoft.com/library/ms714177(v=vs.85).aspx)) для извлечения или изменения данных в зашифрованных столбцах базы данных. При условии, что приложение имеет необходимые разрешения базы данных и может получить доступ к главному ключу столбца, драйвер будет шифровать все параметры запроса, предназначенные для зашифрованных столбцов и расшифровывать данные, полученные из зашифрованных столбцов, поведение прозрачно для приложения, как если столбцы не были зашифрованы.

Если функция Always Encrypted не включена, выполнение запросов с параметрами, предназначенными для зашифрованных столбцов, завершается ошибкой. Данные по-прежнему могут извлекаться из зашифрованных столбцов, пока для них не будут указаны параметры, предназначенные для зашифрованных столбцов. Тем не менее драйвер не будет любой расшифровки, и приложение будет получать двоичные зашифрованные данные (в виде массивов байтов).

В приведенной ниже таблице описывается поведение запросов в зависимости от того, включена функция Always Encrypted или нет.

|Характеристика запроса | Постоянное шифрование включено, и приложение может получать доступ к ключам и метаданным ключей|Постоянное шифрование включено, и приложение не может получать доступ к ключам и метаданным ключей | Постоянное шифрование отключено|
|:---|:---|:---|:---|
| Параметры, предназначенные для зашифрованных столбцов. | Значения параметров прозрачно шифруются. | Ошибка | Ошибка|
| Извлечение данных из зашифрованных столбцов без параметров, предназначенных для зашифрованных столбцов.| Результаты из зашифрованных столбцов прозрачно расшифровываются. Приложение получает значения столбца в виде обычного текста. | Ошибка | Результаты из зашифрованных столбцов не расшифровываются. Приложение получает зашифрованные значения в виде массивов байтов.

В следующих примерах показано получение и изменение данных в зашифрованных столбцах. В примерах предполагается таблицу со следующей схемой. Обратите внимание, что столбцы SSN и BirthDate зашифрованы.

```
CREATE TABLE [dbo].[Patients](
 [PatientId] [int] IDENTITY(1,1),
 [SSN] [char](11) COLLATE Latin1_General_BIN2
 ENCRYPTED WITH (ENCRYPTION_TYPE = DETERMINISTIC,
 ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256',
 COLUMN_ENCRYPTION_KEY = CEK1) NOT NULL,
 [FirstName] [nvarchar](50) NULL,
 [LastName] [nvarchar](50) NULL,
 [BirthDate] [date]
 ENCRYPTED WITH (ENCRYPTION_TYPE = RANDOMIZED,
 ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256',
 COLUMN_ENCRYPTION_KEY = CEK1) NOT NULL
 PRIMARY KEY CLUSTERED ([PatientId] ASC) ON [PRIMARY] )
 GO
```

#### <a name="data-insertion-example"></a>Пример вставки данных

В этом примере показана вставка строки в таблицу Patients. Следует отметить следующее.

- В образце кода нет ничего, связанного с шифрованием. Драйвер автоматически обнаруживает и шифрует значения параметров SSN и даты, которые предназначенные для зашифрованных столбцов. В этом случае шифрование является прозрачным для приложения.

- Данные, вставленные в столбцы базы данных (в том числе в зашифрованные) передаются в качестве привязанных параметров (см. [Функция SQLBindParameter](https://msdn.microsoft.com/library/ms710963(v=vs.85).aspx)). Несмотря на то, что при отправке значений в незашифрованные столбцы использовать параметры необязательно (но настоятельно рекомендуется, так как это помогает предотвратить внедрение кода SQL), они требуются для значений, предназначенных для зашифрованных столбцов. Если значения, вставленные в столбцы SSN или BirthDate были переданы в качестве литералов, внедренных в инструкции запроса, выполнение запроса завершится ошибкой, так как драйвер не будет пытаться шифрования или другим образом обработать литералы в запросах. В результате сервер отклонит их как несовместимые с зашифрованными столбцами.

- Тип параметра, вставляемого в столбец SSN SQL присваивается SQL_CHAR, который сопоставляет **char** тип данных SQL Server (`rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 11, 0, (SQLPOINTER)SSN, 0, &cbSSN);`). Если тип параметра было присвоено SQL_WCHAR, который сопоставляет **nchar**, выполнение запроса завершится ошибкой, так как постоянное шифрование не поддерживает преобразование на стороне сервера с nchar зашифрованные значения в зашифрованный char. См. в разделе [Справочник по программированию ODBC — типы данных приложение D:](https://msdn.microsoft.com/library/ms713607.aspx) сведения о сопоставлении типов данных.

```
    SQL_DATE_STRUCT date;
    SQLLEN cbdate;   // size of date structure  

    SQLCHAR SSN[12];
    strcpy_s((char*)SSN, _countof(SSN), "795-73-9838");

    SQLWCHAR* firstName = L"Catherine";
    SQLWCHAR* lastName = L"Abel";
    SQLINTEGER cbSSN = SQL_NTS, cbFirstName = SQL_NTS, cbLastName = SQL_NTS;

    // Initialize the date structure  
    date.day = 10;
    date.month = 9;
    date.year = 1996;

    // Size of structures   
    cbdate = sizeof(SQL_DATE_STRUCT);

    SQLRETURN rc = 0;

    string queryText = "INSERT INTO [dbo].[Patients] ([SSN], [FirstName], [LastName], [BirthDate]) VALUES (?, ?, ?, ?) ";

    rc = SQLPrepare(hstmt, (SQLCHAR *)queryText.c_str(), SQL_NTS);

    //SSN
    rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 11, 0, (SQLPOINTER)SSN, 0, &cbSSN);
    //FirstName
    rc = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_WCHAR, SQL_WCHAR, 50, 0, (SQLPOINTER)firstName, 0, &cbFirstName);
    //LastName
    rc = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_WCHAR, SQL_WCHAR, 50, 0, (SQLPOINTER)lastName, 0, &cbLastName);
    //BirthDate
    rc = SQLBindParameter(hstmt, 4, SQL_PARAM_INPUT, SQL_C_TYPE_DATE, SQL_TYPE_DATE, 10, 0, (SQLPOINTER)&date, 0, &cbdate);

    rc = SQLExecute(hstmt);
```

#### <a name="plaintext-data-retrieval-example"></a>Пример извлечения данных открытым текстом

В следующем примере показана фильтрация данных на основе зашифрованных значений и получение данных в виде открытого текста из зашифрованных столбцов. Следует отметить следующее.

- Значение, используемое в предложении WHERE для фильтрации по столбцу SSN, необходимо передавать, используя SQLBindParameter, чтобы перед отправкой на сервер драйвер мог его прозрачно зашифровать.

- Все значения, выводимые программой, будут представлены в виде обычного текста, так как драйвер прозрачно расшифрует данные, полученные из столбцов SSN и BirthDate.

> [!NOTE]
> Запросы могут выполнять сравнения на равенство по зашифрованным столбцам, только в том случае, если шифрование является детерминированным. Дополнительные сведения см. в разделе [Выбор детерминированного или случайного шифрования](../../relational-databases/security/encryption/always-encrypted-database-engine.md#selecting--deterministic-or-randomized-encryption).

```
SQLCHAR SSN[12];
strcpy_s((char*)SSN, _countof(SSN), "795-73-9838");

SQLWCHAR* firstName = L"Catherine";
SQLWCHAR* lastName = L"Abel";
SQLINTEGER cbSSN = SQL_NTS, cbFirstName = SQL_NTS, cbLastName = SQL_NTS;

SQLRETURN rc = 0;
string empty = "";
string queryText = "SELECT [SSN], [FirstName], [LastName], [BirthDate] " + empty +
    "FROM  [dbo].[Patients]" +
    "WHERE " +
    "[SSN] = ? ";

rc = SQLPrepare(hstmt, (SQLCHAR *)queryText.c_str(), SQL_NTS);

//SSN
rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 11, 0, (SQLPOINTER)SSN, 0, &cbSSN);

rc = SQLExecute(hstmt);
HandleDiagnosticRecord(hstmt, SQL_HANDLE_STMT, rc);

SQL_DATE_STRUCT dateVal;
SQLWCHAR firstNameVal[50];
SQLWCHAR lastNameVal[50];
SQLCHAR SSNVal[12];
SQLLEN cbdate;   // size of date structure  

int rowcount = 0;
while (SQL_SUCCEEDED(SQLFetch(hstmt)))
{
    rowcount++;
    SQLGetData(hstmt, 1, SQL_C_CHAR, &SSNVal, 11, &cbSSN);
    SQLGetData(hstmt, 2, SQL_C_WCHAR, &firstNameVal, 50, &cbFirstName);
    SQLGetData(hstmt, 3, SQL_C_WCHAR, &lastNameVal, 50, &cbLastName);
    SQLGetData(hstmt, 4, SQL_C_TYPE_DATE, &dateVal, 10, &cbdate);        
}
```

#### <a name="ciphertext-data-retrieval-example"></a>Пример извлечения данных зашифрованного текста

Если постоянное шифрование не включено, запрос может получать данные из зашифрованных столбцов, пока для него не будут указаны параметры, предназначенные для зашифрованных столбцов.

В приведенном ниже примере показано извлечение двоичных зашифрованных данных из зашифрованных столбцов. Следует отметить следующее.

- Так как постоянное шифрование не включено в строке подключения, запрос будет возвращать зашифрованные значения SSN и BirthD в виде байтовых массивов (программа преобразует значения в строки).
- Запрос, получающий данные из зашифрованных столбцов с отключенным постоянным шифрованием, может иметь параметры при условии, что ни один из параметров не предназначен для зашифрованного столбца. Приведенный выше запрос выполняет фильтрацию по LastName, который не зашифрован в базе данных. Запрос, отфильтрованный по SSN или BirthDate, завершится ошибкой.


```
SQLCHAR SSN[12];
strcpy_s((char*)SSN, _countof(SSN), "795-73-9838");

SQLWCHAR* firstName = L"Catherine";
SQLWCHAR* lastName = L"Abel";
SQLINTEGER cbSSN = SQL_NTS, cbFirstName = SQL_NTS, cbLastName = SQL_NTS;

SQLRETURN rc = 0;
string empty = "";
string queryText = "SELECT [SSN], [FirstName], [LastName], [BirthDate] " + empty +
    "FROM  [dbo].[Patients]" +
    "WHERE " +
    "[LastName] = ?";

rc = SQLPrepare(hstmt, (SQLCHAR *)queryText.c_str(), SQL_NTS);

//LastName
rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_WCHAR, SQL_WCHAR, 50, 0, (SQLPOINTER)lastName, 0, &cbLastName);

rc = SQLExecute(hstmt);
HandleDiagnosticRecord(hstmt, SQL_HANDLE_STMT, rc);

SQL_DATE_STRUCT dateVal;
SQLWCHAR firstNameVal[50];
SQLWCHAR lastNameVal[50];
SQLCHAR SSNVal[12];
SQLLEN cbdate;   // size of date structure  

int rowcount = 0;
while (SQL_SUCCEEDED(SQLFetch(hstmt)))
{
    rowcount++;
    SQLGetData(hstmt, 1, SQL_C_CHAR, &SSNVal, 11, &cbSSN);
    SQLGetData(hstmt, 2, SQL_C_WCHAR, &firstNameVal, 50, &cbFirstName);
    SQLGetData(hstmt, 3, SQL_C_WCHAR, &lastNameVal, 50, &cbLastName);
    SQLGetData(hstmt, 4, SQL_C_TYPE_DATE, &dateVal, 10, &cbdate);        
}
```

#### <a name="avoiding-common-problems-when-querying-encrypted-columns"></a>Как избежать распространенных проблем при запросе зашифрованных столбцов

В этом разделе описываются общие категории ошибок, возникающих при выполнении запросов к зашифрованным столбцам из приложений ODBC, и приводятся рекомендации о том, как их избежать.

##### <a name="unsupported-data-type-conversion-errors"></a>Ошибки преобразования неподдерживаемых типов данных

Постоянное шифрование поддерживает несколько преобразований для зашифрованных типов данных. Подробный список поддерживаемых преобразований типов см. в статье [Always Encrypted (ядро СУБД)](../../relational-databases/security/encryption/always-encrypted-database-engine.md). Во избежание ошибок преобразования типов данных, убедитесь, что наблюдаться следующие моменты при использовании SQLBindParameter с параметрами, предназначенных для зашифрованных столбцов.

- Тип SQL параметра либо точно совпадает с типом целевого столбца, или поддерживается преобразование из типа SQL в тип столбца.

- Точность и масштаб параметров, предназначенных для столбцов типов данных SQL Server `decimal` и `numeric`, соответствуют точности и масштабу, настроенным для конечного столбца.

- В запросах, которые изменяют конечный столбец, точность параметров, предназначенных для столбцов типов данных SQL Server `datetime2`, `datetimeoffset` или `time`, не превышает точность для конечного столбца.  

##### <a name="errors-due-to-passing-plaintext-instead-of-encrypted-values"></a>Ошибки, возникающие из-за передачи значений в виде открытого текста, а не в зашифрованном виде

Любое значение, предназначенное для зашифрованного столбца должен быть зашифрован перед отправкой на сервер. Попытка вставки, изменения или фильтрации по значению в виде открытого текста в зашифрованном столбце приведет к возникновению ошибки. Чтобы избежать таких ошибок, убедитесь в том, что:

- Постоянное шифрование включено (в имени DSN, строку подключения, прежде чем соединении `SQL_COPT_SS_COLUMN_ENCRYPTION` атрибут соединения для определенного подключения, или `SQL_SOPT_SS_COLUMN_ENCRYPTION` атрибут инструкции для конкретного отчета).

- для отправки данных, предназначенных для зашифрованных столбцов, используется параметр SQLBindParameter. В примере ниже показан запрос, который вместо передачи литерала как аргумента объекта SQLBindParameter неправильно выполняет фильтрацию по литералу или константе в зашифрованном столбце (SSN).

```
string queryText = "SELECT [SSN], [FirstName], [LastName], [BirthDate] FROM [dbo].[Patients] WHERE SSN='795-73-9838'";
```

### <a name="precautions-when-using-sqlsetpos-and-sqlmoreresults"></a>Меры предосторожности при использовании функции SQLSetPos и SQLMoreResults

#### <a name="sqlsetpos"></a>функция SQLSetPos;

`SQLSetPos` API позволяет приложению обновлять строки в результирующий набор с помощью буферов, были привязаны с SQLBindCol и в какую из строк данных, которые были ранее выбраны. Из-за заполнения асимметричного поведение зашифрованных типов фиксированной длины существует возможность неожиданно изменять данные из этих столбцов во время выполнения обновлений на другие столбцы в строке. С AE будут добавлены значения символов фиксированной длины, если оно меньше размера буфера.

Чтобы устранить это поведение, используйте `SQL_COLUMN_IGNORE` флаг, чтобы пропустить столбцы, которые не будут обновляться как часть `SQLBulkOperations` и при использовании `SQLSetPos` для курсора на основе обновлений.  Все столбцы, которые не изменяются непосредственно приложением следует игнорировать, как для производительности и избежать усечения значений столбцов, привязанных к буфер *меньшего размера* от их фактического размера (DB). Дополнительные сведения см. в разделе [Справочник по функциям SQLSetPos](https://msdn.microsoft.com/library/ms713507(v=vs.85).aspx).

#### <a name="sqlmoreresults--sqldescribecol"></a>SQLMoreResults и SQLDescribeCol

Приложения могут вызывать [SQLDescribeCol](https://msdn.microsoft.com/library/ms716289(v=vs.85).aspx) возвращать метаданные о столбцах в подготовленных инструкций.  Если постоянное шифрование включено, вызвав `SQLMoreResults` *перед* вызова `SQLDescribeCol` вызывает [sp_describe_first_result_set](../../relational-databases/system-stored-procedures/sp-describe-first-result-set-transact-sql.md) для вызова, который не возвращает правильно открытый текст метаданные для зашифрованных столбцов. Чтобы избежать этой проблемы, вызовите `SQLDescribeCol` на подготовленных инструкций *перед* вызова `SQLMoreResults`.

## <a name="controlling-the-performance-impact-of-always-encrypted"></a>Управление влиянием Always Encrypted на производительность

Так как Always Encrypted является технологией шифрования на стороне клиента, значительное влияние на производительность происходит на стороне клиента, а не в базе данных. Помимо затрат на операции шифрования и расшифровки существуют и другие источники снижения производительности на стороне клиента:

- Дополнительные обращения к базе данных для получения метаданных для параметров запроса.

- Вызовы хранилища главных ключей столбцов для доступа к главному ключу столбца.

В этом разделе описываются процессы оптимизации производительности, встроенные в ODBC Driver for SQL Server, и способы управления влиянием двух указанных выше факторов на производительность.

### <a name="controlling-round-trips-to-retrieve-metadata-for-query-parameters"></a>Управление обращениями для получения метаданных для параметров запроса

Если для соединения включена функция Always Encrypted, по умолчанию драйвер будет вызывать [sys.sp_describe_parameter_encryption](../../relational-databases/system-stored-procedures/sp-describe-parameter-encryption-transact-sql.md) для каждого параметризованного запроса, передавая инструкцию запроса (без значений параметров) в SQL Server. Эта хранимая процедура анализирует инструкцию запроса, чтобы узнать, должен быть зашифрован и если да, возвращает связанные с шифрованием сведения для каждого параметра Разрешить драйверу шифровать их. Описанное выше поведение обеспечивает высокий уровень прозрачности для клиентского приложения: приложение (и разработчику приложений) не обязательно должно знать, какие запросы получают доступ к зашифрованным столбцам, до тех пор, пока будут переданы значения, предназначенные для зашифрованных столбцов драйвер в параметрах.

### <a name="per-statement-always-encrypted-behavior"></a>-Оператор Always Encrypted поведение

Чтобы контролировать влияние на производительность процесса получения метаданных шифрования для параметризованных запросов, могут изменить поведение Always Encrypted для отдельных запросов, если этот метод включен в соединении. Таким образом, можно обеспечить `sys.sp_describe_parameter_encryption` вызывается только для запросов, которые точно имеют параметры, предназначенные для зашифрованных столбцов. Обратите внимание, что в этом случае снижается прозрачность шифрования: при шифровании дополнительных столбцов в базе данных может потребоваться изменить код приложения в соответствии с изменениями схемы.

Для управления поведением постоянного шифрования инструкции, вызовите SQLSetStmtAttr, чтобы задать `SQL_SOPT_SS_COLUMN_ENCRYPTION` атрибут инструкции к одному из следующих значений:

|Значение|Описание|
|-|-|
|`SQL_CE_DISABLED` (0)|Постоянное шифрование отключено для оператора|
|`SQL_CE_RESULTSETONLY` (1)|Только для расшифровки. Расшифровываются результирующих наборов и возвращаемые значения и параметры не шифруются.|
|`SQL_CE_ENABLED` (3) | Всегда включен и используется для параметров и результатов Encrypted|

Новый дескрипторов инструкций, созданный из соединения с Always Encrypted включена по умолчанию для SQL_CE_ENABLED. Созданный из соединения с ним отключена по умолчанию для SQL_CE_DISABLED (и его уже не сможете включить функцию Always Encrypted на них.)

Если большинство запросов от имени клиентского приложения получить доступ к зашифрованным столбцам, рекомендуется следующее:

- Присвойте ключевому слову `ColumnEncryption` строки подключения значение `Enabled`.

- Задайте `SQL_SOPT_SS_COLUMN_ENCRYPTION` атрибут `SQL_CE_DISABLED` на операторы, которые не обращаются к зашифрованным столбцам. Это приведет к отключению оба вызова `sys.sp_describe_parameter_encryption` а также пытается расшифровать все значения, в результате значение.
    
- Задайте `SQL_SOPT_SS_COLUMN_ENCRYPTION` атрибут `SQL_CE_RESULTSETONLY` на операторы, которые не имеют параметров, требующих шифрования, но получают данные из зашифрованных столбцов. Это приведет к отключению вызова `sys.sp_describe_parameter_encryption` и шифрования параметров. Результаты, содержащие зашифрованные столбцы будут продолжать расшифровать.

## <a name="always-encrypted-security-settings"></a>Always Encrypted параметры безопасности

### <a name="force-column-encryption"></a>Принудительное шифрование столбца

Чтобы применить шифрование параметра, задайте `SQL_CA_SS_FORCE_ENCRYPT` поле дескриптора параметра реализации (IPD) посредством вызова функция SQLSetDescField. Ненулевое значение приводит к драйверу, будут возвращать ошибку, когда возвращаются без метаданных шифрования для связанного параметра.

```
SQLHDESC ipd;
SQLGetStmtAttr(hStmt, SQL_ATTR_IMP_PARAM_DESC, &ipd, 0, 0);
SQLSetDescField(ipd, paramNum, SQL_CA_SS_FORCE_ENCRYPT, (SQLPOINTER)TRUE, SQL_IS_SMALLINT);   
```

Если SQL Server сообщает драйверу, что параметр не должен быть зашифрован, запросы, использующие этот параметр, завершатся ошибкой. Это обеспечивает дополнительную защиту от атак на систему безопасности, включающих предоставление клиенту скомпрометированным сервером SQL Server неверных метаданных шифрования, что может привести к раскрытию данных.

### <a name="column-encryption-key-caching"></a>Кэширование ключа шифрования столбца

Чтобы уменьшить количество вызовов хранилища главных ключей столбцов для расшифровки ключей шифрования столбцов, драйвер кэширует ключей CEK открытый текст в памяти. Кэш CEK глобальными по отношению к драйверу и не связаны с любой одно подключение. После получения ECEK из метаданных базы данных, драйвер сначала пытается найти соответствующий ключ CEK открытого текста зашифрованного значения ключа в кэше. Драйвер обращается к хранилищу ключей, содержащее CMK только в том случае, если не удается найти соответствующий открытый текст ключа шифрования Столбца в кэше.

> [!NOTE]
> В драйвере ODBC для SQL Server записей в кэше вытесняются по истечении времени ожидания два часа. Это означает, что для данного ECEK, драйвер обращается к хранилищу ключей только один раз в течение времени существования приложения или каждые два часа, какое значение меньше.

Начиная с версии 17.1 драйвер ODBC для SQL Server, тайм-аут кэша ключа шифрования Столбца можно изменить с помощью `SQL_COPT_SS_CEKCACHETTL` атрибут соединения, который указывает количество секунд, ключ CEK будет оставаться в кэше. Из-за природы глобальный кэш этот атрибут может регулироваться из любого дескриптора соединения, допустимый для драйвера. Если также вытесняются кэша, который TTL уменьшается, существующих ключей CEK, которые приведут к превышению новый срок ЖИЗНИ. Если задано значение 0, не ключей CEK кэшируются.

### <a name="trusted-key-paths"></a>Доверенных путей

Начиная с версии 17.1 драйвер ODBC для SQL Server, `SQL_COPT_SS_TRUSTEDCMKPATHS` атрибут соединения позволяет приложению только использовать указанный список ключей CMK, идентифицируемый их пути к ключам Always Encrypted операций. По умолчанию этот атрибут имеет значение NULL, это означает, что драйвер принимает любой путь к ключу. Чтобы использовать эту функцию, задайте `SQL_COPT_SS_TRUSTEDCMKPATHS` указывает разделенных нулями, завершающаяся символом null строку расширенных символов, которой перечислены допустимые пути ключа. Памяти, на которую этим атрибутом должны оставаться допустимыми во время шифрования или расшифровки операций, с помощью дескриптора соединения, в которой она задана---которого драйвер будет проверять, если пути CMK, как указано в метаданных сервера является регистр не учитывается в этом список. Если пути CMK отсутствует в списке, операция завершится ошибкой. Приложение может изменять содержимое памяти, которую этот атрибут указывает, изменить свой список доверенных ключей CMK, без установки атрибута еще раз.

## <a name="working-with-column-master-key-stores"></a>Работа с хранилищами главных ключей столбцов

Для шифрования или расшифровки данных, драйвер должен получить ключ CEK, настроенный для целевого столбца. Ключей CEK, хранятся в зашифрованном виде (ECEKs) в метаданных базы данных. Каждого ключа шифрования Столбца имеет соответствующий CMK, который использовался для его шифрования. [Метаданных базы данных](../../t-sql/statements/create-column-master-key-transact-sql.md) не хранит CMK; он содержит только имя хранилища ключей и информацию, которую можно использовать хранилище ключей для поиска CMK.

Чтобы получить значение открытого текста ECEK, драйвер сначала получает метаданные о его соответствующий CMK и CEK, и затем использует эти сведения для связи хранилища ключей, содержащее CMK и запрашивает его расшифровать ECEK. Драйвер взаимодействует с помощью хранилища ключей, с помощью поставщика хранилища ключей.

### <a name="built-in-keystore-providers"></a>Поставщики встроенных хранилища ключей

Драйвер ODBC для SQL Server поставляется со следующими поставщиками встроенные хранилища ключей:

| Имя | Описание | Имя поставщика (метаданные) |Доступность|
|:---|:---|:---|:---|
|Хранилище ключей Azure |Ключей CMK хранилища в Azure Key Vault | `AZURE_KEY_VAULT` |Windows, macOS, Linux|
|Хранилище сертификатов Windows|Хранит ключей CMK локально в хранилище ключей Windows| `MSSQL_CERTIFICATE_STORE`|Windows|

- Вы (или ваш администратор баз данных) должны проверить правильность имени поставщика, настроенного в метаданных главного ключа столбца, и убедиться в том, что путь к ключу главного ключа столбца соответствует формату пути к ключу для данного поставщика. Для настройки ключей рекомендуется использовать средство, такое как среда SQL Server Management Studio, которое при выполнении инструкции [CREATE COLUMN MASTER KEY (Transact-SQL)](../../t-sql/statements/create-column-master-key-transact-sql.md) автоматически создает допустимые имена поставщиков и пути к ключам.

- Необходимо убедиться в том, что приложение может получать доступ к ключам в хранилище ключей. Для этого может потребоваться предоставить приложению доступ к ключу или хранилищу ключей (в зависимости от хранилища ключей) либо выполнить другие действия по настройке конкретного хранилища ключей. Например для доступа к Azure Key Vault, необходимо предоставить правильные учетные данные в хранилище ключей.

### <a name="using-the-azure-key-vault-provider"></a>Использование поставщика Azure Key Vault

Хранилище ключей Azure удобно для хранения главных ключей столбцов для постоянного шифрования, особенно в том случае, если приложения размещены в Azure. Драйвер ODBC для SQL Server в Linux, macOS и Windows включает в себя встроенный столбец поставщика хранилища главных ключей для хранилища ключей Azure. См. в разделе [Azure Key Vault - шаг за шагом](https://blogs.technet.microsoft.com/kv/2015/06/02/azure-key-vault-step-by-step/), [Приступая к работе с хранилищем ключей](https://azure.microsoft.com/documentation/articles/key-vault-get-started/), и [Создание главных ключей столбцов в хранилище ключей Azure](https://msdn.microsoft.com/library/mt723359.aspx#Anchor_2) Дополнительные сведения о настройке ключ Azure Хранилище для постоянного шифрования.

> [!NOTE]
> В Linux и macOS, для драйвера версии 17.2 и более поздних версий `libcurl` необходим для использования этого поставщика, но не явных зависимостей, так как она не нужна другие операции с драйвером. Если вы столкнулись с ошибкой в отношении `libcurl`, установить его.

Драйвер поддерживает проверку подлинности в хранилище ключей Azure, используя следующие типы учетных данных:

- Имя пользователя и пароль — с помощью этого метода указаны учетные данные имени пользователя Azure Active Directory и его пароль.

- Идентификатор и секрет клиента — с помощью этого метода указаны учетные данные идентификатора клиента приложения и секрет приложения.

- Управляемое удостоверение службы - в этом случае учетные данные, присвоенным системой идентификатором или назначаемого пользователем удостоверения. Для назначаемого пользователем удостоверения UID присваивается идентификатор объекта удостоверения пользователя.

Чтобы разрешить драйвер на использование ключей CMK, хранящимся в AKV для шифрования столбца, используйте следующие ключевые слова только на строку подключения:

|Тип учетных данных| `KeyStoreAuthentication` |`KeyStorePrincipalId`| `KeyStoreSecret` |
|-|-|-|-|
|Имя пользователя и пароль| `KeyVaultPassword`|Имя участника-пользователя|Пароль|
|Идентификатор и секрет клиента| `KeyVaultClientSecret`|Идентификатор клиента|Секрет|

#### <a name="example-connection-strings"></a>Примеры строк подключения

В следующей строке подключения показано выполнение проверки подлинности в хранилище ключей Azure с двумя типами учетных данных:

**ClientID или секрет**:

```
DRIVER=ODBC Driver 13 for SQL Server;SERVER=myServer;Trusted_Connection=Yes;DATABASE=myDB;ColumnEncryption=Enabled;KeyStoreAuthentication=KeyVaultClientSecret;KeyStorePrincipalId=<clientId>;KeyStoreSecret=<secret>
```

**Имя пользователя и пароль**:

```
DRIVER=ODBC Driver 13 for SQL Server;SERVER=myServer;Trusted_Connection=Yes;DATABASE=myDB;ColumnEncryption=Enabled;KeyStoreAuthentication=KeyVaultPassword;KeyStorePrincipalId=<username>;KeyStoreSecret=<password>
```

Другие изменения приложения ODBC необходимы для использования хранилищем ключей AZURE для хранения CMK.

### <a name="using-the-windows-certificate-store-provider"></a>Использование поставщика хранилища сертификатов Windows

Драйвер ODBC для SQL Server в Windows включает в себя встроенный столбец поставщика хранилища главного ключа для сертификата Windows Store, с именем `MSSQL_CERTIFICATE_STORE`. (Этот поставщик доступен не в macOS или Linux.) С этим поставщиком CMK хранится локально на клиентском компьютере, и никаких дополнительных настроек для приложения необходима для использования его с помощью драйвера. Тем не менее в приложении необходим доступ к сертификат и его закрытый ключ в хранилище. Дополнительные сведения см. в статье [Создание и хранение главных ключей столбцов (постоянное шифрование)](https://docs.microsoft.com/sql/relational-databases/security/encryption/create-and-store-column-master-keys-always-encrypted).

### <a name="using-custom-keystore-providers"></a>Использование настраиваемых поставщиков хранилища ключей

Драйвер ODBC для SQL Server также поддерживает пользовательские хранилища ключей сторонних поставщиков, с помощью интерфейса CEKeystoreProvider. Это позволяет приложению загружать, запрашивать и настройте поставщики хранилища ключей, таким образом, чтобы они могут использоваться драйвером для доступа к зашифрованным столбцам. Приложения могут напрямую взаимодействовать с поставщик хранилища ключей для шифрования ключей CEK для хранения в SQL Server и выполнять задачи, кроме доступа к зашифрованным столбцам, в ODBC. Дополнительные сведения см. в разделе [настраиваемые поставщики хранилища ключей](../../connect/odbc/custom-keystore-providers.md).

Два атрибута соединения используются для взаимодействия с поставщиками пользовательского хранилища ключей. Подробные сведения.

- `SQL_COPT_SS_CEKEYSTOREPROVIDER`

- `SQL_COPT_SS_CEKEYSTOREDATA`

Первое из них используется для загрузки и перечисления поставщиков хранилища ключей загрузки, пока второй позволяет communications поставщика приложения. Эти атрибуты соединения можно включить в любое время до или после установки соединения, так как взаимодействие поставщиков приложений не подразумевает обмена данными с SQL Server. Тем не менее поскольку драйвер еще не загружена, установку и получение этих атрибутов перед подключением приведет к их для обработки диспетчером драйверов и может не дает ожидаемых результатов.

#### <a name="loading-a-keystore-provider"></a>Загрузка поставщика хранилища ключей

Параметр `SQL_COPT_SS_CEKEYSTOREPROVIDER` атрибут соединения позволяет клиентскому приложению загрузить библиотеку поставщика, делая доступными для использования поставщиков хранилища ключей, содержащихся в них.

```
SQLRETURN SQLSetConnectAttr( SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER ValuePtr, SQLINTEGER StringLength);
```

| Аргумент | Описание |
|:---|:---|
|`ConnectionHandle`|[Вход] Дескриптор соединения. Должен быть дескриптором допустимое соединение, но загружаются через одно подключение дескриптор поставщиков доступны из любой другой, в том же процессе.|
|`Attribute`|[Вход] Атрибут для задания: `SQL_COPT_SS_CEKEYSTOREPROVIDER` константы.|
|`ValuePtr`|[Вход] Указатель на строку нуль-символом, указав имя файла библиотеки поставщика. Для SQLSetConnectAttrA это строка ANSI (многобайтовые). Для SQLSetConnectAttrW это строки Юникода (wchar_t).|
|`StringLength`|[Вход] Длина строки ValuePtr или SQL_NTS.|

Драйвер пытается загрузить библиотеку, идентифицируемый параметром ValuePtr, с помощью определяемого платформой динамической библиотеки механизм загрузки (`dlopen()` в Linux и macOS, `LoadLibrary()` в Windows), и добавляет все доступные поставщики, определенные в этой последовательности в список Поставщики, известные для драйвера. Могут возникать следующие ошибки:

| Ошибка | Описание |
|:--|:--|
|`CE203`|Динамическая библиотека не может быть загружен.|
|`CE203`|Символ «CEKeyStoreProvider» экспортировать не найден в библиотеке.|
|`CE203`|Один или несколько поставщиков в библиотеке, уже загружены.|

`SQLSetConnectAttr` Возвращает обычные ошибки или значений успешного завершения и Дополнительные сведения доступна для любой ошибки, которые была произведена через стандартный механизм диагностики ODBC.

> [!NOTE]
> Программисты приложений необходимо убедиться, что любым пользовательским поставщикам загружены, прежде чем любой запрос, требуя их отправляется через любое подключение. Несоблюдение этого правила приведет к ошибке.

| Ошибка | Описание |
|:--|:--|
|`CE200`|Поставщик хранилища ключей %1 не найден. Убедитесь, загрузку библиотеки поставщика соответствующего хранилища ключей.|

> [!NOTE]
> Средства реализации поставщика хранилища ключей следует избегать использования `MSSQL` имя свои настраиваемые поставщики. Этот термин зарезервирован исключительно для использования в корпорации Майкрософт и может привести к конфликту с будущих встроенные поставщики. Использование этого термина имя пользовательского поставщика может привести предупреждение об ODBC.

#### <a name="getting-the-list-of-loaded-providers"></a>Получение списка загруженных поставщиков

Начало этот атрибут подключения позволяет клиентскому приложению для определения поставщиков хранилища ключей, загруженных в драйвере (включая встроенные). Это может выполняться только после подключения.

```
SQLRETURN SQLGetConnectAttr( SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER ValuePtr, SQLINTEGER BufferLength, SQLINTEGER * StringLengthPtr);
```

| Аргумент | Описание |
|:---|:---|
|`ConnectionHandle`|[Вход] Дескриптор соединения. Должен быть дескриптором допустимое соединение, но загружаются через одно подключение дескриптор поставщиков доступны из любой другой, в том же процессе.|
|`Attribute`|[Вход] Извлекаемого атрибута: `SQL_COPT_SS_CEKEYSTOREPROVIDER` константы.|
|`ValuePtr`|[Выход] Указатель на область памяти, в которую будет возвращено следующее имя загруженного поставщика.|
|`BufferLength`|[Вход] Длина буфера ValuePtr.|
|`StringLengthPtr`|[Выход] Указатель на буфер, в которую будет возвращено общее число байтов (за исключением знака завершения null) для возврата в \*ValuePtr. Если ValuePtr является указателем null, длина не возвращается. Если значение атрибута — строка символов, а также количество байтов, доступных для возврата больше, чем BufferLength минус длина конечное значение null символов, данные в \*ValuePtr усекается до BufferLength минус длина символ завершения NULL и заканчивается нулевым байтом драйвером.|

Чтобы можно было получить весь список, каждая операция Get возвращает имя текущего поставщика и увеличивает внутренний счетчик на следующее. Когда этот счетчик достигнет конца списка, пустая строка ("») возвращается, и счетчик сбрасывается; последовательные операции Get перейдите снова в начале списка.

### <a name="communicating-with-keystore-providers"></a>Взаимодействие с поставщиками хранилища ключей

`SQL_COPT_SS_CEKEYSTOREDATA` Атрибут соединения позволяет клиентскому приложению связаться с поставщиками хранилища ключей загрузки для настройки дополнительных параметров для материала и т. д. Взаимодействие между клиентским приложением и поставщик следует протокол, простой запрос ответ, основанный на Get и набор запросов, с помощью этого атрибута соединения. Связь устанавливается только клиентским приложением.

> [!NOTE]
> Из-за природы ODBC вызывает CEKeyStoreProvider его реагирование на (SQLGet/SetConnectAttr) поддерживает только интерфейс ODBC задание данных в разрешении контекст соединения.

Приложение взаимодействует с поставщиками хранилища ключей посредством драйвера с помощью структуры CEKeystoreData:

```
typedef struct CEKeystoreData {
wchar_t *name;
unsigned int dataSize;
char data[];
} CEKEYSTOREDATA;
```

| Аргумент | Описание |
|:---|:---|
|`name`|[Вход] После набора, имя поставщика для отправки данных. Учитывается при Get. Строка расширенных символов, завершающаяся символом NULL.|
|`dataSize`|[Вход] Размер массива данных в соответствии со структурой.|
|`data`|[Вход] После набора данных для отправки поставщику. Это может быть произвольные данные; драйвер не пытается ее интерпретировать. После получения буфер для получения данных чтения из поставщика.|

#### <a name="writing-data-to-a-provider"></a>Запись данных в поставщик

Объект `SQLSetConnectAttr` вызов с использованием `SQL_COPT_SS_CEKEYSTOREDATA` записывает атрибут «пакет» данных указанный поставщик хранилища ключей.
```
SQLRETURN SQLSetConnectAttr( SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER ValuePtr, SQLINTEGER StringLength);
```

| Аргумент | Описание |
|:---|:---|
|`ConnectionHandle`| [Вход] Дескриптор соединения. Должен быть дескриптором допустимое соединение, но загружаются через одно подключение дескриптор поставщиков доступны из любой другой, в том же процессе.|
|`Attribute`|[Вход] Атрибут для задания: `SQL_COPT_SS_CEKEYSTOREDATA` константы.|
|`ValuePtr`|[Вход] Указатель на структуру CEKeystoreData. Поле имени структуры идентифицирует поставщика, для которого предназначен данные.|
|`StringLength`|[Вход] Константа SQL_IS_POINTER|

Дополнительные подробные сведения об ошибке можно получить с помощью [SQLGetDiacRec](https://msdn.microsoft.com/library/ms710921(v=vs.85).aspx).

> [!NOTE]
> Поставщик может использовать дескриптор подключения для связи с конкретным соединением, записанные данные, если это требуется. Это полезно для реализации конфигурации подключения. Он также может игнорировать контекст соединения и рассматривать данные одинаково независимо от соединения, используемого для отправки данных. См. в разделе [контекст ассоциации](../../connect/odbc/custom-keystore-providers.md#context-association) Дополнительные сведения.

#### <a name="reading-data-from-a-provider"></a>Чтение данных от поставщика

Вызов `SQLGetConnectAttr` с помощью `SQL_COPT_SS_CEKEYSTOREDATA` атрибут считывает «пакет» данных из *последнего записанных to* поставщика. Если такового не было, возникает ошибка последовательности функций. При реализации поставщиков хранилища ключей, рекомендуется для поддержки «фиктивного модуля записи» 0 байт как способ выбора поставщика для операций чтения без возникновения других побочные эффекты, если это имеет смысл для этого.

```
SQLRETURN SQLGetConnectAttr( SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER ValuePtr, SQLINTEGER BufferLength, SQLINTEGER * StringLengthPtr);
```

| Аргумент | Описание |
|:---|:---|
|`ConnectionHandle`|[Вход] Дескриптор соединения. Должен быть дескриптором допустимое соединение, но загружаются через одно подключение дескриптор поставщиков доступны из любой другой, в том же процессе.|
|`Attribute`|[Вход] Извлекаемого атрибута: `SQL_COPT_SS_CEKEYSTOREDATA` константы.|
|`ValuePtr`|[Выход] Указатель на структуру CEKeystoreData, в котором размещается данные, считанные из поставщика.|
|`BufferLength`|[Вход] Константа SQL_IS_POINTER|
|`StringLengthPtr`|[Выход] Указатель на буфер, в которую будет возвращен BufferLength. Если * ValuePtr является указателем null, длина не возвращается.|

Вызывающий объект должен убедиться, что для поставщика для записи в выделяется буфер надлежащей длины в соответствии со структурой CEKEYSTOREDATA. По возвращении его dataSize обновляется фактическую длину данных, считанных из поставщика. Дополнительные подробные сведения об ошибке можно получить с помощью [SQLGetDiacRec](https://msdn.microsoft.com/library/ms710921(v=vs.85).aspx).

Этот интерфейс накладывает Дополнительные требования к отсутствуют на формат данных, передаваемых между приложением и поставщик хранилища ключей. Каждый поставщик можно определить свой собственный формат данных и протоколов, в зависимости от его потребностей.

Пример реализации поставщика хранилища ключей, см. в разделе [настраиваемые поставщики хранилища ключей](../../connect/odbc/custom-keystore-providers.md)

## <a name="limitations-of-the-odbc-driver-when-using-always-encrypted"></a>Ограничения при использовании Always Encrypted драйвера ODBC

### <a name="asynchronous-operations"></a>Асинхронные операции
Хотя разрешает использование драйвера ODBC [асинхронных операций](../../relational-databases/native-client/odbc/creating-a-driver-application-asynchronous-mode-and-sqlcancel.md) с постоянным шифрованием при повлиять на производительность операций постоянное шифрование включено. Вызов `sys.sp_describe_parameter_encryption` для определения метаданных шифрования, инструкция блокирует и драйвер ожидания для сервера для возвращения метаданных перед возвратом `SQL_STILL_EXECUTING`.

### <a name="retrieve-data-in-parts-with-sqlgetdata"></a>Получение данных в части с SQLGetData
Перед шифрованием ODBC Driver 17 for SQL Server, символьных и двоичных столбцов не удалось получить в частях с SQLGetData. Можно сделать только один вызов SQLGetData, с буфером достаточной длины для хранения данных всего столбца.

### <a name="send-data-in-parts-with-sqlputdata"></a>Отправлять данные в частях с SQLPutData
Перед 17.3 драйвер ODBC для SQL Server в частях с SQLPutData невозможно отправить данные для вставки или сравнения. Можно сделать только один вызов SQLPutData, с помощью буфер, содержащий все данные. Для вставки данных long в зашифрованных столбцах, используйте интерфейс API массового копирования, описанных в следующем разделе, с помощью файла входных данных.

### <a name="encrypted-money-and-smallmoney"></a>Зашифрованные money и smallmoney
Шифрование **деньги** или **smallmoney** столбцов нельзя указать с помощью параметров, так как нет конкретного не эти типы, приводит к пересекаться операнд типа ошибки какие сопоставляется с типом данных ODBC.

## <a name="bulk-copy-of-encrypted-columns"></a>Массовое копирование зашифрованных столбцов

Использование [функции массового копирования SQL](../../relational-databases/native-client-odbc-bulk-copy-operations/performing-bulk-copy-operations-odbc.md) и **bcp** служебной программы поддерживается с постоянным шифрованием, начиная с ODBC Driver 17 for SQL Server. Обычный текст (зашифрованный для вставки и расшифрованные на извлечение) и зашифрованного текста (передаются открытым текстом) могут быть вставлены и получить с помощью операции массового копирования (bcp_&#42;) API-интерфейсы и **bcp** служебной программы.

- Для получения зашифрованного текста в виде varbinary(max) (например, для массовой загрузки в другой базе данных), подключение без `ColumnEncryption` параметр (или установить его на `Disabled`) и выполнять операции BCP OUT.

- Для вставки и извлечения открытого текста и разрешить драйверу прозрачно выполнять шифрование и расшифровка как обязательный, параметр `ColumnEncryption` для `Enabled` достаточно. Функции BCP API остается неизменным.

- Чтобы вставить зашифрованные данные в виде varbinary(max), (например что полученный выше), установите `BCPMODIFYENCRYPTED` равным TRUE и выполнять операции BCP IN. Чтобы быть расшифровываемой результирующих данных убедитесь, что назначение столбца ключа шифрования Столбца, из которого был изначально получен зашифрованный текст.

При использовании **bcp** служебной программы: элемент управления `ColumnEncryption` , используйте параметр -D и укажите имя источника данных, содержащий необходимое значение. Чтобы вставить зашифрованных данных, убедитесь, `ALLOW_ENCRYPTED_VALUE_MODIFICATIONS` пользователя включен.

Следующая таблица содержит краткое описание действий при работе в зашифрованном столбце:

|`ColumnEncryption`|Направление BCP|Описание|
|----------------|-------------|-----------|
|`Disabled`|OUT (клиенту)|Получает зашифрованный текст. Наблюдаемые типом данных **varbinary(max)**.|
|`Enabled`|OUT (клиенту)|Возвращает значение открытого текста. Драйвер расшифрует данные столбца.|
|`Disabled`|IN (на сервер)|Вставляет зашифрованного текста. Предназначен для неявным образом, перемещение зашифрованных данных без необходимости его для расшифровки. Операция завершится ошибкой, если `ALLOW_ENCRYPTED_VALUE_MODIFICATIONS` параметр не установлен на пользователя или BCPMODIFYENCRYPTED не задано на дескриптор соединения. Дополнительную информацию см. ниже.|
|`Enabled`|IN (на сервер)|Вставляет в виде обычного текста. Драйвер будет шифрования данных столбца.|

### <a name="the-bcpmodifyencrypted-option"></a>Параметр BCPMODIFYENCRYPTED

Чтобы предотвратить повреждение данных, сервер обычно не разрешить вставку зашифрованных данных непосредственно в зашифрованном столбце, и таким образом завершится ошибкой при попытке сделать; Тем не менее для массовой загрузки зашифрованных данных, с помощью API BCP, установка `BCPMODIFYENCRYPTED` [bcp_control](../../relational-databases/native-client-odbc-extensions-bulk-copy-functions/bcp-control.md) значение TRUE для параметра позволит зашифрованного текста, вставляемый непосредственно и снижает риск повреждения зашифрованные данные через параметр `ALLOW_ENCRYPTED_VALUE_MODIFICATIONS` параметр учетной записи пользователя. Тем не менее ключи должны соответствовать данным, и рекомендуется для выполнения некоторых проверок только для чтения, вставляемых данных после массовой вставки и перед дальнейшего использования.

Дополнительные сведения см. в разделе [Перенос конфиденциальных данных с помощью функции постоянного шифрования](../../relational-databases/security/encryption/migrate-sensitive-data-protected-by-always-encrypted.md).

## <a name="always-encrypted-api-summary"></a>Always Encrypted сводные данные API

### <a name="connection-string-keywords"></a>Ключевые слова в строке подключения

|Имя|Описание|  
|----------|-----------------|  
|`ColumnEncryption`|Принимаются значения `Enabled` / `Disabled`.<br>`Enabled` — включает функцию Always Encrypted для подключения.<br>`Disabled` — отключает для подключения функцию Always Encrypted. <br><br>Значение по умолчанию — `Disabled`.|  
|`KeyStoreAuthentication` | Допустимые значения: `KeyVaultPassword`, `KeyVaultClientSecret` |
|`KeyStorePrincipalId` | Когда `KeyStoreAuthentication`  =  `KeyVaultPassword`, это значение на допустимое имя участника-пользователя Active Directory Azure. <br>Когда `KeyStoreAuthetication`  =  `KeyVaultClientSecret` это значение равно допустимый Azure Active Directory приложения идентификатор клиента |
|`KeyStoreSecret` | Когда `KeyStoreAuthentication`  =  `KeyVaultPassword` это значение равно пароль, соответствующий имени пользователя. <br>Когда `KeyStoreAuthentication`  =  `KeyVaultClientSecret` это значение равно секрет приложения, связанный с допустимым Azure Active Directory идентификатор клиента приложения |


### <a name="connection-attributes"></a>Атрибуты соединения

|Имя|Тип|Описание|  
|----------|-------|----------|  
|`SQL_COPT_SS_COLUMN_ENCRYPTION`|Перед подключением|`SQL_COLUMN_ENCRYPTION_DISABLE` (0) — отключить Always Encrypted <br>`SQL_COLUMN_ENCRYPTION_ENABLE` (1) — Включение функции Always Encrypted|
|`SQL_COPT_SS_CEKEYSTOREPROVIDER`|После подключения|[Значение] Попытка загрузить CEKeystoreProvider<br>[Get] Возвращает имя CEKeystoreProvider|
|`SQL_COPT_SS_CEKEYSTOREDATA`|После подключения|[Значение] Запись данных CEKeystoreProvider<br>[Get] Считывание данных из CEKeystoreProvider|
|`SQL_COPT_SS_CEKCACHETTL`|После подключения|[Значение] Задать срок ЖИЗНИ кэша CEK<br>[Get] Получить текущий кэш CEK TTL|
|`SQL_COPT_SS_TRUSTEDCMKPATHS`|После подключения|[Значение] Задать указатель доверенных путей CMK<br>[Get] Получение текущего указателя доверенных путей CMK|

### <a name="statement-attributes"></a>Атрибуты инструкции

|Имя|Описание|  
|----------|-----------------|  
|`SQL_SOPT_SS_COLUMN_ENCRYPTION`|`SQL_CE_DISABLED` (0) — постоянное шифрование отключено для оператора <br>`SQL_CE_RESULTSETONLY` (1) — только для расшифровки. Расшифровываются результирующих наборов и возвращаемые значения и параметры не шифруются. <br>`SQL_CE_ENABLED` (3) — always Encrypted включена и используется для параметров и результатов|

### <a name="descriptor-fields"></a>Поля дескриптора

|IPD-поле|Размера и типа|Значение по умолчанию|Описание|
|-|-|-|-|  
|`SQL_CA_SS_FORCE_ENCRYPT` (1236)|WORD (2 байта)|0|При 0 (по умолчанию): решение для шифрования этого параметра определяется доступность метаданных шифрования.<br><br>Если ненулевое значение: Если для этого параметра метаданные шифрования, он зашифрован. В противном случае запрос завершается сбоем с ошибкой [CE300] для параметра указано обязательное шифрование [Microsoft] [ODBC Driver 13 for SQL Server], но без метаданных шифрования был предоставлен на сервере.|

### <a name="bcpcontrol-options"></a>Параметры bcp_control

|Имя параметра|Значение по умолчанию|Описание|
|-|-|-|
|`BCPMODIFYENCRYPTED` (21)|FALSE|Если значение равно TRUE, позволяет вставлять в зашифрованный столбец varbinary(max) значения. Если задано значение FALSE, предотвращает вставки, если указан правильный тип и шифрования метаданных.|

## <a name="see-also"></a>См. также:

- [Always Encrypted (ядро СУБД)](../../relational-databases/security/encryption/always-encrypted-database-engine.md)
- [Блог о постоянном шифровании](https://blogs.msdn.com/b/sqlsecurity/archive/tags/always-encrypted/)

