---
title: "Использование постоянного шифрования с ODBC Driver 13.1 for SQL Server | Документы Microsoft"
ms.custom: 
ms.date: 07/12/2017
ms.prod: sql-non-specified
ms.reviewer: 
ms.suite: 
ms.technology:
- drivers
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 02e306b8-9dde-4846-8d64-c528e2ffe479
caps.latest.revision: 3
ms.author: v-chojas
manager: jhubbard
author: MightyPen
ms.translationtype: MT
ms.sourcegitcommit: 96ec352784f060f444b8adcae6005dd454b3b460
ms.openlocfilehash: d28b647de71c5064dfbe0d49f399119f6a9ac283
ms.contentlocale: ru-ru
ms.lasthandoff: 09/27/2017

---
# <a name="using-always-encrypted-with-the-odbc-driver-131-for-sql-server"></a>Использование постоянного шифрования с ODBC Driver 13.1 for SQL Server
[!INCLUDE[Driver_ODBC_Download](../../includes/driver_odbc_download.md)]

Этой статье содержатся сведения о том, как разрабатывать приложения ODBC, с использованием [Always Encrypted (ядро СУБД)](../../relational-databases/security/encryption/always-encrypted-database-engine.md) и [ODBC Driver 13.1 for SQL Server](../../connect/odbc/microsoft-odbc-driver-for-sql-server.md).

Функция Always Encrypted позволяет шифровать конфиденциальные данные в клиентских приложениях, не раскрывая данные или ключи шифрования для SQL Server или Базы данных SQL Azure. Always Encrypted драйвер с поддержкой, таких как ODBC Driver 13.1 for SQL Server, реализует это за счет прозрачного шифрования и расшифровки конфиденциальных данных в клиентском приложении. Драйвер автоматически определяет, какие параметры запроса соответствуют важным столбцам базы данных (защищенным с помощью Always Encrypted), и шифрует значения этих параметров перед передачей данных в SQL Server или Базу данных SQL Azure. Аналогичным образом драйвер прозрачно расшифровывает данные, полученные из зашифрованных столбцов базы в результатах запроса. Дополнительные сведения см. в разделе [Always Encrypted (ядро СУБД)](../../relational-databases/security/encryption/always-encrypted-database-engine.md).

### <a name="prerequisites"></a>Предварительные требования

Настройте функцию постоянного шифрования в базе данных. В процесс настройки входят действия по подготовке ключей постоянного шифрования и настройке шифрования для выбранных столбцов базы данных. Если в базе данных постоянное шифрование еще не настроено, следуйте инструкциям в разделе [Приступая к работе с постоянным шифрованием](../../relational-databases/security/encryption/always-encrypted-database-engine.md#getting-started-with-always-encrypted). В частности база данных должна содержать определения метаданных для главного ключа столбца (CMK), ключ шифрования столбца (CEK) и таблицу, содержащую один или несколько столбцов, зашифрованных с помощью этого CEK.

### <a name="enabling-always-encrypted-in-an-odbc-application"></a>Включение постоянного шифрования в приложении ODBC

Самым простым способом, чтобы включить параметр шифрования и расшифровки столбца результирующего набора шифрования является, задав значение `ColumnEncryption` ключевое слово строки подключения для **включено**. Ниже приведен пример строки подключения, которое включает постоянное шифрование:

```
SQLWCHAR *connString = L"Driver={ODBC Driver 13 for SQL Server};Server={myServer};Trusted_Connection=yes;ColumnEncryption=Enabled;";
```

Всегда Encrypted также можно включить в конфигурации источника данных, используя тот же ключ и значение (которое будут переопределены, задав строку соединения, если он имеется) или программным путем с `SQL_COPT_SS_COLUMN_ENCRYPTION` атрибута предварительного соединения. Установка его таким образом переопределяет значение, заданное в строку соединения или имя источника данных:

```
 SQLSetConnectAttr(hdbc, SQL_COPT_SS_COLUMN_ENCRYPTION, (SQLPOINTER)SQL_COLUMN_ENCRYPTION_ENABLE, 0);
```

После включения для соединения, можно менять поведением постоянного шифрования для отдельных запросов. В разделе [контроля производительности влияние из постоянного шифрования](#controlling-the-performance-impact-of-always-encrypted) ниже для получения дополнительной информации.

Обратите внимание, что включение постоянного шифрования недостаточно для шифрования или расшифровки для успешного выполнения; также необходимо убедиться, что:

- Приложение имеет разрешения *VIEW ANY COLUMN MASTER KEY DEFINITION* и *VIEW ANY COLUMN ENCRYPTION KEY DEFINITION* для базы данных, необходимые для доступа к метаданным о ключах постоянного шифрования в базе данных. Дополнительные сведения см. в разделе [разрешения базы данных](../../relational-databases/security/encryption/always-encrypted-database-engine.md#database-permissions).

- Приложение может получить доступ к CMK, который защищает столбца для запрашиваемых зашифрованных столбцов. Это зависит от поставщика хранилища ключей, который хранит CMK. В разделе [работа с хранилищами главных ключей столбцов](#working-with-column-master-key-stores) для получения дополнительной информации.

### <a name="retrieving-and-modifying-data-in-encrypted-columns"></a>Получение и изменение данных в зашифрованных столбцах

После включения постоянного шифрования для подключения, можно использовать стандартные интерфейсы ODBC API (в разделе [пример кода ODBC](https://code.msdn.microsoft.com/windowsapps/ODBC-sample-191624ae/sourcecode?fileId=51137&pathId=1980325953) или [справочнике программиста ODBC](https://msdn.microsoft.com/library/ms714177(v=vs.85).aspx)) для получения или изменения данных в столбцах зашифрованной базы данных. При условии, что приложение имеет необходимые разрешения базы данных и может получить доступ к главному ключу столбца, драйвер будет шифровать все параметры запроса, предназначенные для зашифрованных столбцов и расшифровать данные, полученные из зашифрованных столбцов прозрачно работает на приложения, как если бы столбцы не были зашифрованы.

Если постоянное шифрование не включено, произойдет сбой запросы с параметрами, которые предназначенные для зашифрованных столбцов. Можно по-прежнему получить данные из зашифрованных столбцов, при условии, что запрос не имеет параметров предназначенные для зашифрованных столбцов. Тем не менее драйвер не будет любой расшифровки и приложение будет получать двоичные зашифрованные данные (в виде массивов байтов).

В следующей таблице перечислены поведение запросов в зависимости от того, является ли постоянное шифрование включено или нет.

|Характеристика запроса | Постоянное шифрование включено, и приложение может получать доступ к ключам и метаданным ключей|Постоянное шифрование включено, и приложение не может получать доступ к ключам и метаданным ключей | Постоянное шифрование отключено|
|:---|:---|:---|:---|
| Параметры, предназначенные для зашифрованных столбцов. | Значения параметров прозрачно шифруются. | Ошибка | Ошибка|
| Извлечение данных из зашифрованных столбцов без параметров, предназначенных для зашифрованных столбцов.| Результаты из зашифрованных столбцов прозрачно расшифровываются. Приложение получает значения столбца в открытом тексте. | Ошибка | Результаты из зашифрованных столбцов не расшифровываются. Приложение получает зашифрованные значения в виде байтовых массивов.

В следующих примерах показано получение и изменение данных в зашифрованных столбцах. В этих примерах таблицу со следующей схемой. Обратите внимание, что столбцы SSN и BirthDate зашифрованы.

```
CREATE TABLE [dbo].[Patients](
 [PatientId] [int] IDENTITY(1,1),
 [SSN] [char](11) COLLATE Latin1_General_BIN2
 ENCRYPTED WITH (ENCRYPTION_TYPE = DETERMINISTIC,
 ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256',
 COLUMN_ENCRYPTION_KEY = CEK1) NOT NULL,
 [FirstName] [nvarchar](50) NULL,
 [LastName] [nvarchar](50) NULL,
 [BirthDate] [date]
 ENCRYPTED WITH (ENCRYPTION_TYPE = RANDOMIZED,
 ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256',
 COLUMN_ENCRYPTION_KEY = CEK1) NOT NULL
 PRIMARY KEY CLUSTERED ([PatientId] ASC) ON [PRIMARY] )
 GO
```

#### <a name="data-insertion-example"></a>Пример вставки данных

В этом примере показана вставка строки в таблицу Patients. Следует отметить следующее.

- В образце кода нет ничего, связанного с шифрованием. Драйвер автоматически обнаруживает и шифрует значения параметров SSN и даты, которые предназначенные для зашифрованных столбцов. В этом случае шифрование является прозрачным для приложения.

- Как связанные параметры передаются значениях, вставляемых в столбцы базы данных, включая зашифрованные столбцы (в разделе [SQLBindParameter, функция](https://msdn.microsoft.com/library/ms710963(v=vs.85).aspx)). Хотя с помощью параметров является необязательным при отправке значений в незашифрованные столбцы (хотя настоятельно рекомендуется, так как он помогает предотвратить атаки SQL injection), он необходим для значений, предназначенных для зашифрованных столбцов. При значениях, вставляемых в столбцы SSN или BirthDate были переданы в качестве литералов, внедренных в инструкции запроса, запрос завершится ошибкой, так как драйвер не будет пытаться шифрования, либо иначе обработать литералы в запросах. В результате сервер отклонит их как несовместимые с зашифрованными столбцами.

- Тип параметра, вставляемого в столбец SSN SQL имеет значение SQL_CHAR, которая сопоставляется **char** тип данных SQL Server (`rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 11, 0, (SQLPOINTER)SSN, 0, &cbSSN);`). Если тип параметра было задано значение SQL_WCHAR, которая сопоставляется **nchar**, запрос завершится ошибкой, как постоянное шифрование не поддерживает преобразование серверные с nchar зашифрованные значения в зашифрованные char. В разделе [справочнике программиста ODBC — типы данных приложение D:](https://msdn.microsoft.com/library/ms713607.aspx) сведения о сопоставлении типов данных.

```
    SQL_DATE_STRUCT date;
    SQLLEN cbdate;   // size of date structure  

    SQLCHAR SSN[12];
    strcpy_s((char*)SSN, _countof(SSN), "795-73-9838");

    SQLWCHAR* firstName = L"Catherine";
    SQLWCHAR* lastName = L"Abel";
    SQLINTEGER cbSSN = SQL_NTS, cbFirstName = SQL_NTS, cbLastName = SQL_NTS;

    // Initialize the date structure  
    date.day = 10;
    date.month = 9;
    date.year = 1996;

    // Size of structures   
    cbdate = sizeof(SQL_DATE_STRUCT);

    SQLRETURN rc = 0;

    string queryText = "INSERT INTO [dbo].[Patients] ([SSN], [FirstName], [LastName], [BirthDate]) VALUES (?, ?, ?, ?) ";

    rc = SQLPrepare(hstmt, (SQLCHAR *)queryText.c_str(), SQL_NTS);

    //SSN
    rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 11, 0, (SQLPOINTER)SSN, 0, &cbSSN);
    //FirstName
    rc = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_WCHAR, SQL_WCHAR, 50, 0, (SQLPOINTER)firstName, 0, &cbFirstName);
    //LastName
    rc = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_WCHAR, SQL_WCHAR, 50, 0, (SQLPOINTER)lastName, 0, &cbLastName);
    //BirthDate
    rc = SQLBindParameter(hstmt, 4, SQL_PARAM_INPUT, SQL_C_TYPE_DATE, SQL_TYPE_DATE, 10, 0, (SQLPOINTER)&date, 0, &cbdate);

    rc = SQLExecute(hstmt);
```

#### <a name="plaintext-data-retrieval-example"></a>Пример извлечения данных открытым текстом

В следующем примере показана фильтрация данных на основе зашифрованных значений и получение данных в виде открытого текста из зашифрованных столбцов. Следует отметить следующее.

- Значение, используемое в предложении WHERE для фильтрации по столбцу SSN должен передать с помощью SQLBindParameter, чтобы драйвер мог его прозрачно зашифровать перед отправкой на сервер.

- Все значения, выводимые программой будет в виде обычного текста, поскольку драйвер прозрачно расшифровывает данные, полученные из столбцов SSN и BirthDate.

> [!NOTE]
> Запросы могут выполнять сравнение на равенство по зашифрованным столбцам только в том случае, если шифрование является детерминированным. Дополнительные сведения см. в разделе [Выбор детерминированного или случайного шифрования](../../relational-databases/security/encryption/always-encrypted-database-engine.md#selecting--deterministic-or-randomized-encryption).

```
SQLCHAR SSN[12];
strcpy_s((char*)SSN, _countof(SSN), "795-73-9838");

SQLWCHAR* firstName = L"Catherine";
SQLWCHAR* lastName = L"Abel";
SQLINTEGER cbSSN = SQL_NTS, cbFirstName = SQL_NTS, cbLastName = SQL_NTS;

SQLRETURN rc = 0;
string empty = "";
string queryText = "SELECT [SSN], [FirstName], [LastName], [BirthDate] " + empty +
    "FROM  [dbo].[Patients]" +
    "WHERE " +
    "[SSN] = ? ";

rc = SQLPrepare(hstmt, (SQLCHAR *)queryText.c_str(), SQL_NTS);

//SSN
rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, 11, 0, (SQLPOINTER)SSN, 0, &cbSSN);

rc = SQLExecute(hstmt);
HandleDiagnosticRecord(hstmt, SQL_HANDLE_STMT, rc);

SQL_DATE_STRUCT dateVal;
SQLWCHAR firstNameVal[50];
SQLWCHAR lastNameVal[50];
SQLCHAR SSNVal[12];
SQLLEN cbdate;   // size of date structure  

int rowcount = 0;
while (SQL_SUCCEEDED(SQLFetch(hstmt)))
{
    rowcount++;
    SQLGetData(hstmt, 1, SQL_C_CHAR, &SSNVal, 11, &cbSSN);
    SQLGetData(hstmt, 2, SQL_C_WCHAR, &firstNameVal, 50, &cbFirstName);
    SQLGetData(hstmt, 3, SQL_C_WCHAR, &lastNameVal, 50, &cbLastName);
    SQLGetData(hstmt, 4, SQL_C_TYPE_DATE, &dateVal, 10, &cbdate);        
}
```

#### <a name="ciphertext-data-retrieval-example"></a>Пример извлечения данных зашифрованного текста

Если постоянное шифрование не включено, запрос может получать данные из зашифрованных столбцов, пока для него не будут указаны параметры, предназначенные для зашифрованных столбцов.

В следующем примере показано извлечение двоичных зашифрованных данных из зашифрованных столбцов. Следует отметить следующее.

- Так как постоянное шифрование не включено в строке подключения, запрос будет возвращать зашифрованные значения SSN и BirthD в виде байтовых массивов (программа преобразует значения в строки).
- Запрос, получающий данные из зашифрованных столбцов с отключенным постоянным шифрованием, может иметь параметры при условии, что ни один из параметров не предназначен для зашифрованного столбца. Приведенный выше запрос выполняет фильтрацию по LastName, который не зашифрован в базе данных. Запрос, отфильтрованный по SSN или BirthDate, завершится ошибкой.


```
SQLCHAR SSN[12];
strcpy_s((char*)SSN, _countof(SSN), "795-73-9838");

SQLWCHAR* firstName = L"Catherine";
SQLWCHAR* lastName = L"Abel";
SQLINTEGER cbSSN = SQL_NTS, cbFirstName = SQL_NTS, cbLastName = SQL_NTS;

SQLRETURN rc = 0;
string empty = "";
string queryText = "SELECT [SSN], [FirstName], [LastName], [BirthDate] " + empty +
    "FROM  [dbo].[Patients]" +
    "WHERE " +
    "[LastName] = ?";

rc = SQLPrepare(hstmt, (SQLCHAR *)queryText.c_str(), SQL_NTS);

//LastName
rc = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_WCHAR, SQL_WCHAR, 50, 0, (SQLPOINTER)lastName, 0, &cbLastName);

rc = SQLExecute(hstmt);
HandleDiagnosticRecord(hstmt, SQL_HANDLE_STMT, rc);

SQL_DATE_STRUCT dateVal;
SQLWCHAR firstNameVal[50];
SQLWCHAR lastNameVal[50];
SQLCHAR SSNVal[12];
SQLLEN cbdate;   // size of date structure  

int rowcount = 0;
while (SQL_SUCCEEDED(SQLFetch(hstmt)))
{
    rowcount++;
    SQLGetData(hstmt, 1, SQL_C_CHAR, &SSNVal, 11, &cbSSN);
    SQLGetData(hstmt, 2, SQL_C_WCHAR, &firstNameVal, 50, &cbFirstName);
    SQLGetData(hstmt, 3, SQL_C_WCHAR, &lastNameVal, 50, &cbLastName);
    SQLGetData(hstmt, 4, SQL_C_TYPE_DATE, &dateVal, 10, &cbdate);        
}
```

#### <a name="avoiding-common-problems-when-querying-encrypted-columns"></a>Как избежать распространенных проблем при запросе зашифрованных столбцов

В этом разделе описываются общие категории ошибок, при запросе зашифрованных столбцов из приложения ODBC и приводятся рекомендации о том, как их избежать.

##### <a name="unsupported-data-type-conversion-errors"></a>Ошибки преобразования неподдерживаемых типов данных

Постоянное шифрование поддерживает несколько преобразований для зашифрованных типов данных. В разделе [Always Encrypted (ядро СУБД)](../../relational-databases/security/encryption/always-encrypted-database-engine.md) подробный список поддерживаемых преобразований типов. Чтобы избежать ошибки преобразования типов данных, убедитесь, что наблюдать следующие моменты при использовании SQLBindParameter с параметрами, предназначенные для зашифрованных столбцов:

- SQL тип параметра — либо точно совпадает с типом целевого столбца или поддерживается преобразование из типа SQL для типа столбца.

- Точность и масштаб параметров, предназначенных для столбцов `decimal` и `numeric` типов данных SQL Server совпадает с точностью и масштабом, настроенной для целевого столбца.

- Точность параметров, предназначенных для столбцов `datetime2`, `datetimeoffset`, или `time` типов данных SQL Server не превышает точность для целевого столбца, в запросах, которые изменяют целевого столбца.  

##### <a name="errors-due-to-passing-plaintext-instead-of-encrypted-values"></a>Ошибки, возникающие из-за передачи значений в виде открытого текста, а не в зашифрованном виде

Любое значение, предназначенное для зашифрованного столбца должен быть зашифрованы перед отправкой на сервер. Попытка вставить, изменить или фильтровать по значение открытого текста в зашифрованном столбце приведет к ошибке. Чтобы избежать таких ошибок, проверьте следующее.

- Постоянное шифрование включено (источника данных, строку соединения, перед соединении `SQL_COPT_SS_COLUMN_ENCRYPTION` атрибута соединения для конкретного подключения или `SQL_SOPT_SS_COLUMN_ENCRYPTION` атрибут инструкции для конкретного отчета).

- SQLBindParameter использовать для отправки данных, предназначенных для зашифрованных столбцов. В приведенном ниже примере показан запрос, который неправильно фильтрует по литералу или константе в зашифрованном столбце (SSN), вместо того чтобы передавать литерал в качестве аргумента функции SQLBindParameter.

```
string queryText = "SELECT [SSN], [FirstName], [LastName], [BirthDate] FROM [dbo].[Patients] WHERE SSN='795-73-9838'";
```

### <a name="precautions-when-using-sqlsetpos-and-sqlmoreresults"></a>Меры предосторожности при использовании SQLSetPos и SQLMoreResults

#### <a name="sqlsetpos"></a>функция SQLSetPos;

`SQLSetPos` API позволяет приложению обновлять строки в результирующий набор с помощью буферы, связанные с SQLBindCol и в котором строка данных, которые были ранее выбраны. Из-за заполнения асимметричного поведение зашифрованных типов фиксированной длины имеется возможность неожиданно alter данных этих столбцов во время выполнения обновления на других столбцов в строке. С AE будут добавлены значения символов фиксированной длины, если значение меньше, чем размер буфера.

Чтобы предотвратить такое поведение, используйте `SQL_COLUMN_IGNORE` флаг, чтобы пропустить столбцы, которые не будут обновляться в рамках `SQLBulkOperations` и при использовании `SQLSetPos` для курсора на основе обновлений.  Все столбцы, которые не изменяются непосредственно в приложении следует игнорировать, и для производительности и избежать усечения значений столбцов, привязанных к буфера *меньше* от их фактического размера (DB). Дополнительные сведения см. в разделе [Справочник по функциям SQLSetPos](https://msdn.microsoft.com/library/ms713507(v=vs.85).aspx).

#### <a name="sqlmoreresults--sqldescribecol"></a>SQLMoreResults & SQLDescribeCol

Приложения могут вызывать [SQLDescribeCol](https://msdn.microsoft.com/library/ms716289(v=vs.85).aspx) для возвращения метаданных о столбцах в подготовленной инструкции.  При включенном постоянном шифровании вызов `SQLMoreResults` *перед* вызов `SQLDescribeCol` вызывает [sp_describe_first_result_set](../../relational-databases/system-stored-procedures/sp-describe-first-result-set-transact-sql.md) для вызова, который не возвращает правильно открытый текст метаданные для зашифрованных столбцов. Чтобы избежать этой проблемы, вызовите `SQLDescribeCol` на подготовленных инструкций *перед* вызов `SQLMoreResults`.

## <a name="controlling-the-performance-impact-of-always-encrypted"></a>Управление влияние на производительность постоянного шифрования

Так как постоянное шифрование — это технология шифрования на стороне клиента, большую нагрузку на производительность отражается на стороне клиента, а не в базе данных. Помимо затрат на операции шифрования и дешифрования являются другие источники нагрузки на стороне клиента:

- Дополнительные обращения к базе данных для получения метаданных для параметров запроса.

- Вызовы хранилища главных ключей столбцов для доступа к главному ключу столбца.

В этом разделе описываются оптимизации производительности, встроенные в ODBC Driver 13.1 для SQL Server и как можно контролировать влияние двух указанных выше факторов на производительность.

### <a name="controlling-round-trips-to-retrieve-metadata-for-query-parameters"></a>Управление приемов-передач для извлечения метаданных для параметров запроса

Если для соединения включено постоянное шифрование, ODBC Driver 13.1 для SQL Server будет по умолчанию, вызовите [sys.sp_describe_parameter_encryption](../../relational-databases/system-stored-procedures/sp-describe-parameter-encryption-transact-sql.md) для каждого параметризованного запроса, передавая инструкцию запроса (без какого-либо параметра значения) для SQL Server. Эта хранимая процедура анализирует инструкцию запроса, чтобы узнать, если любой из параметров должен быть зашифрован и если да, возвращает связанные с шифрованием сведения для каждого параметра, чтобы драйвер мог зашифровывать их. Описанное выше поведение обеспечивает высокий уровень прозрачности для клиентского приложения: приложение (и разработчику приложений) требуется знать, какие запросы получают доступ к зашифрованным столбцам, при условии, что значения, предназначенные для зашифрованных столбцов, передаются в драйвер в параметрах.

### <a name="per-statement-always-encrypted-behavior"></a>-Оператор постоянное шифрование поведение

Для управления воздействием получения метаданных шифрования для параметризованных запросов, могут изменять поведением постоянного шифрования для отдельных запросов, если она была включена для соединения. Таким образом, вы можете убедиться, что `sys.sp_describe_parameter_encryption` вызывается только для запросов, которые точно имеют параметры, предназначенные для зашифрованных столбцов. Обратите внимание, что таким образом, уменьшить прозрачность шифрования: Если шифрование дополнительные столбцы в базе данных, может потребоваться изменить код вашего приложения в соответствии с изменениями схемы.

Для управления поведением постоянного шифрования инструкции, вызовите SQLSetStmtAttr, чтобы задать `SQL_SOPT_SS_COLUMN_ENCRYPTION` атрибут инструкции в одно из следующих значений:

|Значение|Description|
|-|-|
|`SQL_CE_DISABLED` (0)|Постоянное шифрование отключено для оператора|
|`SQL_CE_RESULTSETONLY` (1)|Расшифровка. Результирующие наборы и возвращаемые значения, расшифровываются и параметры не шифруются.|
|`SQL_CE_ENABLED` (3) | Всегда включен и используется для параметров и результатов шифрование|

Новый дескриптора инструкции, созданные на основе соединения с постоянным шифрованием включена по умолчанию для SQL_CE_ENABLED. Созданный из соединения с ним отключена по умолчанию для SQL_CE_DISABLED (и не удается включить постоянное шифрование на них.)

Если большинство запросов клиентского приложения получить доступ к зашифрованным столбцам, рекомендуется следующее:

- Задать `ColumnEncryption` ключевое слово строки подключения для `Enabled`.

- Задать `SQL_SOPT_SS_COLUMN_ENCRYPTION` атрибут `SQL_CE_DISABLED` на операторы, которые не получить доступ к зашифрованным столбцам. Таким образом вы отключите оба вызова `sys.sp_describe_parameter_encryption` а также пытается расшифровать все значения в результирующий набор.
    
- Задать `SQL_SOPT_SS_COLUMN_ENCRYPTION` атрибут `SQL_CE_RESULTSETONLY` на операторы, которые не имеют параметров, требующих шифрования, но получают данные из зашифрованных столбцов. Это отключит вызова `sys.sp_describe_parameter_encryption` и шифрования параметров. Результаты, содержащие зашифрованные столбцы будут продолжать расшифровать.

## <a name="always-encrypted-security-settings"></a>Постоянное шифрование параметры безопасности

### <a name="force-column-encryption"></a>Принудительное шифрование столбца

Чтобы применить шифрование параметра, задайте `SQL_CA_SS_FORCE_ENCRYPT` поля дескриптора параметра реализации (IPD) путем вызова функции SQLSetDescField. Ненулевое значение заставляет драйвер возвращает ошибку при возврате без метаданных шифрования для связанного параметра.

```
SQLHDESC ipd;
SQLGetStmtAttr(hStmt, SQL_ATTR_IMP_PARAM_DESC, &ipd, 0, 0);
SQLSetDescField(ipd, paramNum, SQL_CA_SS_FORCE_ENCRYPT, (SQLPOINTER)TRUE, SQL_IS_SMALLINT);   
```

Если SQL Server сообщает драйверу, что параметр не должен быть зашифрован, произойдет сбой запросов с помощью этого параметра. Это обеспечивает дополнительную защиту от атак на систему безопасности, связанных с скомпрометированным SQL Server, предоставляя неверных метаданных шифрования клиенту, что может привести к раскрытию данных.

### <a name="column-encryption-key-caching"></a>Кэширование ключа шифрования столбца

Чтобы уменьшить количество вызовов к хранилищу главных ключей столбцов для расшифровки ключей шифрования столбцов, драйвер кэширует столбца открытым текстом в памяти. После получения ECEK из метаданных базы данных, драйвер сначала пытается найти соответствующий ключ CEK открытого текста зашифрованного значения ключа в кэше. Драйвер вызывает хранилищу ключей, содержащему CMK только в том случае, если не удается найти соответствующий ключ CEK открытого текста в кэше.

> [!NOTE]
> В ODBC Driver 13.1 for SQL Server после истечения времени ожидания двухчасовая вытесняются записей в кэше. Это означает, что для данного ECEK, драйвер обращается к хранилищу ключей только один раз в течение времени существования приложения или каждые два часа, какое значение меньше.

## <a name="working-with-column-master-key-stores"></a>Работа с хранилищами главных ключей столбцов

Для шифрования или расшифровки данных, драйвер должен получить CEK, настроенной для целевого столбца. Столбца хранятся в зашифрованном виде в метаданных базы данных (ECEKs). Каждый ключ CEK имеет соответствующий CMK, который был использован для его шифрования. [Метаданных базы данных](../../t-sql/statements/create-column-master-key-transact-sql.md) не хранит CMK; содержит только имя хранилища ключей и сведения о хранилище ключей можно использовать для поиска CMK.

Чтобы получить значение открытого текста ECEK, драйвер сначала получает метаданные о CEK и его соответствующие CMK и затем использует эти сведения для обратитесь в службу хранилища ключей, содержащее CMK и требует, чтобы расшифровать ECEK. Драйвер взаимодействует с хранилища ключей с помощью поставщика хранилища ключей.

### <a name="built-in-keystore-providers"></a>Поставщики встроенного хранилища ключей

ODBC Driver 13.1 for SQL Server содержит следующие поставщики встроенного хранилища ключей.

| Имя | Description | Имя поставщика (метаданные) |Доступность|
|:---|:---|:---|:---|
|Хранилище ключей Azure |Хранилищ ключей CMK в хранилище ключей Azure | `AZURE_KEY_VAULT` |Windows, macOS Linux|
|Хранилище сертификатов Windows|Хранит ключей CMK локально в хранилище ключей Windows| `MSSQL_CERTIFICATE_STORE`|Windows|

- Вы (или ваш администратор баз данных) необходимо убедиться, что имя поставщика в метаданных главного ключа столбца, настроены правильно, и путь к главному ключу столбца соответствует формату пути к ключу для данного поставщика. Для настройки ключей рекомендуется использовать средство, такое как среда SQL Server Management Studio, которое при выполнении инструкции [CREATE COLUMN MASTER KEY (Transact-SQL)](../../t-sql/statements/create-column-master-key-transact-sql.md) автоматически создает допустимые имена поставщиков и пути к ключам.

- Необходимо убедиться, что приложение может получить доступ к ключа в хранилище ключей. Для этого может потребоваться предоставить приложению доступ к ключу или хранилище ключей, в зависимости от того, хранилище ключей или выполнения других действий конфигурации, относящиеся к хранилищу ключей. Например чтобы открыть хранилище ключей Azure, необходимо указать правильные учетные данные в хранилище ключей.

### <a name="using-the-azure-key-vault-provider"></a>С помощью поставщика хранилища ключей Azure

Хранилище ключей Azure удобно для хранения главных ключей столбцов для постоянного шифрования, особенно в том случае, если приложения размещены в Azure. ODBC Driver 13.1 for SQL Server в Linux, macOS и Windows включает встроенный столбец поставщик хранилища главных ключей для хранилища ключей Azure. В разделе [хранилище ключей Azure — шаг за шагом](https://blogs.technet.microsoft.com/kv/2015/06/02/azure-key-vault-step-by-step/), [Приступая к работе с хранилищем ключей](https://azure.microsoft.com/documentation/articles/key-vault-get-started/), и [создании главных ключей столбцов в хранилище ключей Azure](https://msdn.microsoft.com/library/mt723359.aspx#Anchor_2) Дополнительные сведения о настройке ключ Azure Хранилище для постоянного шифрования.

Драйвер поддерживает проверку подлинности в хранилище ключей Azure, используя следующие типы учетных данных:

- Имя пользователя и пароль — с помощью этого метода учетные данные — это имя пользователя Azure Active Directory и ее пароль.

- Идентификатор и секрет клиента — с помощью этого метода учетные данные — это идентификатор клиента приложения и секрет приложения.

Чтобы разрешить использование ключей CMK, хранимых в AKV для шифрования столбцов драйвером, используйте следующие ключевые слова только на строки подключения:

|Тип учетных данных| `KeyStoreAuthentication` |`KeyStorePrincipalId`| `KeyStoreSecret` |
|-|-|-|-|
|Имя пользователя и пароль| `KeyVaultPassword`|Имя участника-пользователя|Пароль|
|Идентификатор и секрет клиента| `KeyVaultClientSecret`|Идентификатор клиента|Секрет|

#### <a name="example-connection-strings"></a>Примеры строк подключения

В следующей строке соединения показывают, как проходить проверку подлинности в хранилище ключей Azure с двумя типами учетных данных:

**ClientID/секрет**:

```
DRIVER=ODBC Driver 13 for SQL Server;SERVER=myServer;Trusted_Connection=Yes;DATABASE=myDB;ColumnEncryption=Enabled;KeyStoreAuthentication=KeyVaultClientSecret;KeyStorePrincipalId=<clientId>;KeyStoreSecret=<secret>
```

**Имя пользователя и пароль**

```
DRIVER=ODBC Driver 13 for SQL Server;SERVER=myServer;Trusted_Connection=Yes;DATABASE=myDB;ColumnEncryption=Enabled;KeyStoreAuthentication=KeyVaultPassword;KeyStorePrincipalId=<username>;KeyStoreSecret=<password>
```

Другие изменения приложения ODBC, необходимых для использования хранилищем ключей AZURE для хранилища CMK.

### <a name="using-the-windows-certificate-store-provider"></a>С помощью поставщика хранилища сертификатов Windows

ODBC Driver 13.1 for SQL Server в Windows включает встроенный столбец поставщик хранилища главных ключей для хранилища сертификатов Windows, с именем `MSSQL_CERTIFICATE_STORE`. (Этот поставщик доступен не на macOS или Linux.) С этим поставщиком CMK хранится локально на клиентском компьютере и без дополнительной настройки в приложении не требуется для использования с драйвером. Тем не менее приложение должно иметь доступ к сертификат и его закрытый ключ в хранилище. В разделе [Создание и главные ключи хранилища столбцов (постоянное шифрование)](https://docs.microsoft.com/en-us/sql/relational-databases/security/encryption/create-and-store-column-master-keys-always-encrypted) для получения дополнительной информации.

### <a name="using-custom-keystore-providers"></a>Использование поставщиков пользовательского хранилища ключей

ODBC Driver 13.1 for SQL Server также поддерживает пользовательские хранилища ключей сторонних поставщиков, с помощью интерфейса CEKeystoreProvider. Это позволяет приложению загружать, запрашивать и настройка поставщиков хранилища ключей, чтобы ими можно с помощью драйвера для доступа к зашифрованным столбцам. Приложения могут непосредственно взаимодействовать с поставщик хранилища ключей для шифрования столбца для хранения данных в SQL Server и выполнять задачи, кроме доступе к зашифрованным столбцам с ODBC. Дополнительные сведения см. в разделе [настраиваемых поставщиков хранилища ключей](../../connect/odbc/custom-keystore-providers.md).

Два атрибута соединения используются для взаимодействия с поставщиками пользовательского хранилища ключей. Подробные сведения.

- `SQL_COPT_SS_CEKEYSTOREPROVIDER`

- `SQL_COPT_SS_CEKEYSTOREDATA`

Первый из них используется для загрузки и перечисления поставщиков хранилища ключей загрузить хотя последний позволяет связи поставщика приложения. Эти атрибуты соединения может использоваться в любое время до или после установки соединения, поскольку взаимодействие поставщиков приложений не подразумевает обмена данными с SQL Server. Тем не менее поскольку драйвер еще не загружена, установку и получение этих атрибутов перед соединением приведет к их для обработки диспетчером драйверов и может не дает ожидаемых результатов.

#### <a name="loading-a-keystore-provider"></a>Загрузка поставщика хранилища ключей

Параметр `SQL_COPT_SS_CEKEYSTOREPROVIDER` атрибут соединения позволяет клиентскому приложению загрузить библиотеку поставщика, чтобы сделать доступными для использования поставщиков хранилища ключей, содержащийся в ней.

```
SQLRETURN SQLSetConnectAttr( SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER ValuePtr, SQLINTEGER StringLength);
```
| Аргумент | Description |
|:---|:---|
|`ConnectionHandle`|[Вход] Дескриптор соединения. Должен быть дескриптором допустимое соединение, но доступны из любой другой, в том же процессе поставщиков, загруженного с помощью дескриптора одного соединения.|
|`Attribute`|[Вход] Атрибут, задаваемый: `SQL_COPT_SS_CEKEYSTOREPROVIDER` константой.|
|`ValuePtr`|[Вход] Указатель на строку символом null, указав имя файла библиотеки поставщика. Для SQLSetConnectAttrA это строку ANSI (многобайтовые). Для SQLSetConnectAttrW это строка в Юникоде (wchar_t).|
|`StringLength`|[Вход] Длина строки ValuePtr или SQL_NTS.|

Драйвер пытается загрузить библиотеку, определенный параметром ValuePtr использование определяемого платформой динамической библиотеки механизм загрузки (`dlopen()` в Linux и macOS, `LoadLibrary()` в Windows), и добавляет все поставщики, определенные в ней в список Поставщики, известные к драйверу. Возможны следующие ошибки:

| Ошибка | Description |
|:--|:--|
|`CE203`|Не удалось загрузить библиотеку динамической.|
|`CE203`|Символ «CEKeyStoreProvider» экспорта не найден в библиотеке.|
|`CE203`|Один или несколько поставщиков в библиотеке уже загружены.|

`SQLSetConnectAttr`Возвращает обычные ошибки или значений успешного завершения и Дополнительные сведения можно найти на наличие ошибок, произошедших через стандартный механизм диагностики ODBC.

> [!NOTE]
> Программисты приложений необходимо убедиться, загружены все пользовательские поставщики перед отправкой любой запрос, требуя их через любое подключение. Невыполнение этого требования приведет к ошибке:

| Ошибка | Description |
|:--|:--|
|`CE200`|Поставщик хранилища ключей %1 не найден. Убедитесь, загрузку библиотеки поставщика соответствующих ключей.|

> [!NOTE]
> Средства реализации поставщика хранилища ключей следует избегать использования `MSSQL` имени их настраиваемых поставщиков. Этот термин зарезервировано исключительно для использования в корпорации Майкрософт и может вызвать конфликт с будущих встроенных поставщиков. Использование этого термина имя пользовательского поставщика может привести к предупреждение об ODBC.

#### <a name="getting-the-list-of-loaded-providers"></a>Получение списка поставщиков загружен

Получение этот атрибут подключения позволяет клиентскому приложению определить поставщиков хранилища ключей, загруженных в данный момент в драйвере (включая встроенные.) Это может быть выполнена только после подключения.

```
SQLRETURN SQLGetConnectAttr( SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER ValuePtr, SQLINTEGER BufferLength, SQLINTEGER * StringLengthPtr);
```
| Аргумент | Description |
|:---|:---|
|`ConnectionHandle`|[Вход] Дескриптор соединения. Должен быть дескриптором допустимое соединение, но доступны из любой другой, в том же процессе поставщиков, загруженного с помощью дескриптора одного соединения.|
|`Attribute`|[Вход] Чтобы получить: `SQL_COPT_SS_CEKEYSTOREPROVIDER` константой.|
|`ValuePtr`|[Выход] Указатель на область памяти, в которую будет возвращено следующее имя загруженного поставщика.|
|`BufferLength`|[Вход] Длина буфера ValuePtr.|
|`StringLengthPtr`|[Выход] Указатель на буфер, в который возвращается общее количество байтов (за исключением знака завершения null) для возврата в \*ValuePtr. Если ValuePtr является указателем null, длина не возвращается. Если значение атрибута представляет собой строку символов, а также количество байтов, доступных для возврата больше, чем BufferLength за вычетом длины конечное значение null символов, данные в \*ValuePtr усекается до BufferLength за вычетом длины знак завершения NULL и нули драйвером.|

Чтобы разрешить получение списка в целом, каждая операция Get возвращает имя текущего поставщика и увеличивает внутренний счетчик, на следующее. Этот счетчик по достижении конца списка, пустая строка ("») возвращается, и счетчик будет сброшен; последовательные операции Get перейдите снова от начала списка.

### <a name="communicating-with-keystore-providers"></a>Взаимодействие с помощью поставщиков хранилища ключей

`SQL_COPT_SS_CEKEYSTOREDATA` Атрибут соединения позволяет клиентскому приложению для взаимодействия с поставщиками загрузить хранилища ключей для настройки дополнительных параметров, создание ключа материалы и т. д. Взаимодействие между клиентским приложением и поставщик следует протокола простого запроса ответа, в зависимости от Get и набор запросов с помощью этого атрибута соединения. Связи инициируется только клиентским приложением.

> [!NOTE]
> Из-за особенностей ODBC вызывает CEKeyStoreProvider в ответ на (SQLGet/SetConnectAttr) поддерживает только интерфейс ODBC задание данных в разрешении контекст соединения.

Приложение взаимодействует с поставщиков хранилища ключей через драйвер через CEKeystoreData структуры:

```
typedef struct CEKeystoreData {
wchar_t *name;
unsigned int dataSize;
char data[];
} CEKEYSTOREDATA;
```
| Аргумент | Description |
|:---|:---|
|`name`|[Вход] При наборе, имя поставщика, по которому отправляется данные. Не обрабатывается при Get. Строка, оканчивающаяся нулем, расширенных символов.|
|`dataSize`|[Вход] Размер массива данных в соответствии со структурой.|
|`data`|[Вход] После набора данных для отправки поставщику. Это может быть произвольных данных; драйвер не пытается ее интерпретировать. После получения буфер для получения данных, считанных из поставщика.|

#### <a name="writing-data-to-a-provider"></a>При записи данных в поставщике

Объект `SQLSetConnectAttr` вызовы с использованием `SQL_COPT_SS_CEKEYSTOREDATA` атрибут «пакет» данных записывает в указанный поставщик хранилища ключей.
```
SQLRETURN SQLSetConnectAttr( SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER ValuePtr, SQLINTEGER StringLength);
```
| Аргумент | Description |
|:---|:---|
|`ConnectionHandle`| [Вход] Дескриптор соединения. Должен быть дескриптором допустимое соединение, но доступны из любой другой, в том же процессе поставщиков, загруженного с помощью дескриптора одного соединения.|
|`Attribute`|[Вход] Атрибут, задаваемый: `SQL_COPT_SS_CEKEYSTOREDATA` константой.|
|`ValuePtr`|[Вход] Указатель на структуру CEKeystoreData. Имя поля структуры идентифицирует поставщика, для которого предназначен данные.|
|`StringLength`|[Вход] Константа SQL_IS_POINTER|

Дополнительные подробные сведения об ошибке можно получить через [SQLGetDiacRec](https://msdn.microsoft.com/library/ms710921(v=vs.85).aspx).

> [!NOTE]
> Поставщик может использовать дескриптор подключения для связи с конкретным соединением записанные данные, при желании таким образом. Это полезно для применения конфигурации на уровне подключения. Он также игнорировать контекст соединения и обрабатывают данные одинаково независимо от того, соединение, используемое для отправки данных. В разделе [ассоциации контекст](../../connect/odbc/custom-keystore-providers.md#context-association) для получения дополнительной информации.

#### <a name="reading-data-from-a-provider"></a>Чтение данных от поставщика

Вызов `SQLGetConnectAttr` с помощью `SQL_COPT_SS_CEKEYSTOREDATA` атрибут считывает «пакет» данных из *последнего записаны to* поставщика. Если нет, возникает ошибка последовательности функций. При реализации поставщиков хранилища ключей, рекомендуется для поддержки «записывает фиктивное «0 байт образом, при выборе поставщика для операций чтения без риска побочные эффекты, если он имеет смысл для этого.

```
SQLRETURN SQLGetConnectAttr( SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER ValuePtr, SQLINTEGER BufferLength, SQLINTEGER * StringLengthPtr);
```
| Аргумент | Description |
|:---|:---|
|`ConnectionHandle`|[Вход] Дескриптор соединения. Должен быть дескриптором допустимое соединение, но доступны из любой другой, в том же процессе поставщиков, загруженного с помощью дескриптора одного соединения.|
|`Attribute`|[Вход] Чтобы получить: `SQL_COPT_SS_CEKEYSTOREDATA` константой.|
|`ValuePtr`|[Выход] Указатель на структуру CEKeystoreData, в котором размещена данные, считанные из поставщика.|
|`BufferLength`|[Вход] Константа SQL_IS_POINTER|
|`StringLengthPtr`|[Выход] Указатель на буфер, в который возвращается BufferLength. Если * ValuePtr является указателем null, длина не возвращается.|

Вызывающий объект должен гарантировать, что для поставщика для записи в выделяется буфер надлежащей длины в соответствии со структурой CEKEYSTOREDATA. При возврате его dataSize обновляется фактическую длину данных, считанных из поставщика. Дополнительные подробные сведения об ошибке можно получить через [SQLGetDiacRec](https://msdn.microsoft.com/library/ms710921(v=vs.85).aspx).

Этот интерфейс накладывает Дополнительные требования к на формат данных, передаваемых между приложением и поставщик хранилища ключей. Каждый поставщик можно определить свой собственный формат данных и протоколов, в зависимости от своих потребностей.

Пример реализации поставщика хранилища ключей см. в разделе [настраиваемых поставщиков хранилища ключей](../../connect/odbc/custom-keystore-providers.md)

## <a name="limitations-of-the-odbc-driver-when-using-always-encrypted"></a>Ограничения драйвера ODBC при использовании постоянного шифрования

### <a name="bulk-copy-function-usage"></a>Использование функций массового копирования
Использование [функции массового копирования SQL](../../relational-databases/native-client-odbc-bulk-copy-operations/performing-bulk-copy-operations-odbc.md) не поддерживается при использовании драйвера ODBC с помощью постоянного шифрования. В зашифрованных столбцах, которые используются с функциями массового копирования SQL будет выполняться без прозрачного шифрования и расшифровки.

### <a name="asynchronous-operations"></a>Асинхронные операции
Пока драйвер ODBC разрешает использование [асинхронных операций](../../relational-databases/native-client/odbc/creating-a-driver-application-asynchronous-mode-and-sqlcancel.md) с постоянным шифрованием, повлиять на производительность операций при есть постоянное шифрование включено. Вызов `sys.sp_describe_parameter_encryption` для определения метаданных шифрования для инструкции блокируется и драйвер ожидания сервер для возврата метаданных перед возвратом `SQL_STILL_EXECUTING`.

## <a name="always-encrypted-api-summary"></a>Сводка по API постоянного шифрования

### <a name="connection-string-keywords"></a>Ключевые слова в строке подключения

|Имя|Description|  
|----------|-----------------|  
|`ColumnEncryption`|Допустимые значения: `Enabled` / `Disabled`.<br>`Enabled`— включает постоянное шифрование для подключения.<br>`Disabled`--отключить функцию Always Encrypted для подключения. <br><br>Значение по умолчанию — `Disabled`.|  
|`KeyStoreAuthentication` | Допустимые значения: `KeyVaultPassword`,`KeyVaultClientSecret` |
|`KeyStorePrincipalId` | Когда `KeyStoreAuthentication`  =  `KeyVaultPassword`, это значение на допустимое имя участника-пользователя Active Directory Azure. <br>Когда `KeyStoreAuthetication`  =  `KeyVaultClientSecret` это значение равно допустимый Azure Active Directory приложения идентификатор клиента |
|`KeyStoreSecret` | Когда `KeyStoreAuthentication`  =  `KeyVaultPassword` это значение равно пароль, соответствующий имени пользователя. <br>Когда `KeyStoreAuthentication`  =  `KeyVaultClientSecret` это значение равно секрет приложения, связанные с допустимый Azure Active Directory приложения идентификатор клиента|

### <a name="connection-attributes"></a>Атрибуты соединения

|Имя|Тип|Description|  
|----------|-------|----------|  
|`SQL_COPT_SS_COLUMN_ENCRYPTION`|Перед подключением|`SQL_COLUMN_ENCRYPTION_DISABLE`(0) — отключить постоянного шифрования <br>`SQL_COLUMN_ENCRYPTION_ENABLE`(1) — Включение постоянного шифрования|
|`SQL_COPT_SS_CEKEYSTOREPROVIDER`|После подключения|[Набор символов] Попытка загрузить CEKeystoreProvider<br>[Get] Возвращает имя CEKeystoreProvider|
|`SQL_COPT_SS_CEKEYSTOREDATA`|После подключения|[Набор символов] Запись данных в CEKeystoreProvider<br>[Get] Чтение данных из CEKeystoreProvider|

### <a name="statement-attributes"></a>Атрибуты инструкции

|Имя|Description|  
|----------|-----------------|  
|`SQL_SOPT_SS_COLUMN_ENCRYPTION`|`SQL_CE_DISABLED`(0) — постоянное шифрование отключено для оператора <br>`SQL_CE_RESULTSETONLY`(1) — только для расшифровки. Результирующие наборы и возвращаемые значения, расшифровываются и параметры не шифруются. <br>`SQL_CE_ENABLED`(3) — всегда включен и используется для параметров и результатов шифрование|

### <a name="descriptor-fields"></a>Поля дескриптора

|IPD-поле|Размер или тип|Значение по умолчанию|Description|
|-|-|-|-|  
|`SQL_CA_SS_FORCE_ENCRYPT` (1236)|WORD (2 байта)|0|При 0 (по умолчанию): решение для шифрования этого параметра определяется доступность метаданных шифрования.<br><br>Если ненулевое значение: Если этот параметр метаданных шифрования, он зашифрован. В противном случае — запрос отклоняется с ошибкой [CE300] [Microsoft] [ODBC Driver 13 for SQL Server] обязательный шифрования был указан для параметра, но метаданные шифрования не был предоставлен сервером.|

## <a name="see-also"></a>См. также:

- [Always Encrypted (ядро СУБД)](../../relational-databases/security/encryption/always-encrypted-database-engine.md)
- [Блог о постоянном шифровании](http://blogs.msdn.com/b/sqlsecurity/archive/tags/always-encrypted/)


