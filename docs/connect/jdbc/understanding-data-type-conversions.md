---
title: Преобразование типов данных понимание | Документы Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: jdbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 98fa7488-aac3-45b4-8aa4-83ed6ab638b4
caps.latest.revision: 34
author: MightyPen
ms.author: genemi
manager: craigg
ms.workload: Inactive
ms.openlocfilehash: e18bd56e110cccab17488de752ba5ab4c8666fa9
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="understanding-data-type-conversions"></a>Общие сведения о преобразованиях типов данных
[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

  Чтобы упростить преобразование типов данных языка программирования Java [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] типы данных [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)] предоставляет преобразование типа данных в соответствии с требованиями спецификации JDBC. Для повышения все типы могут быть преобразованы в и из **объекта**, **строка**, и **byte []** типов данных.  
  
## <a name="getter-method-conversions"></a>Преобразование метода считывания  
 На основе [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] типов данных, в следующей таблице содержится схема преобразования для драйвера JDBC для get\<тип > () методы [SQLServerResultSet](../../connect/jdbc/reference/sqlserverresultset-class.md) класса, а также поддерживаемое преобразование для get\< Тип > методы [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) класса.  
  
 ![JDBCGetterConversions](../../connect/jdbc/media/jdbcgetterconversions.gif "JDBCGetterConversions")  
  
 Преобразования, поддерживаемые методами считывания драйвера JDBC, делятся на три категории.  
  
-   **Без потерь (x)**: преобразования для случаев, когда тип метода считывания является таким же или меньшим, чем базовый тип сервера. Например при вызове метода getBigDecimal для базового десятичного столбца сервера, то преобразование не требуется.  
  
-   **Преобразованием (y)**: преобразования из сервера числовых типов в типы языка Java, когда преобразование осуществляется стандартным образом и отвечает правилам преобразования языка Java. Для этих видов преобразования точность всегда усекается (никогда не округляется), а переполнение обрабатывается как остаток от деления на целевой тип, который меньше по размеру. Например, вызов getInt для базового **десятичное** столбец, содержащий «1,9999» возвращает «1», или, если базовый **десятичное** значение равно «3000000000» то **int** значение выходит за результат будет равен «1294967296».  
  
-   **Зависимости от данных (z)**: преобразования из базовых символьных типов в числовые типы требуется, символьные типы содержали значения, которые могут быть преобразованы в тип. Никакие другие преобразования не выполняются. Если значение слишком велико для метода считывания, то оно является недопустимым. Например, если getInt вызывается относительно столбца varchar(50), который содержит «53», значение возвращается как **int**; но если базовое значение ― «xyz» или «3000000000», выводится сообщение об ошибке.  
  
 Если getString вызывается для **двоичных**, **varbinary**, **varbinary(max)**, или **изображения** тип данных столбца, возвращаемое значение равно шестнадцатеричное значение строки.  
  
## <a name="updater-method-conversions"></a>Преобразование метода обновления  
 Для данных, передаваемых обновления на языке Java\<тип > () методы [SQLServerResultSet](../../connect/jdbc/reference/sqlserverresultset-class.md) , применяются следующие виды преобразования.  
  
 ![JDBCUpdaterConversions](../../connect/jdbc/media/jdbc_jdbcupdatterconversions.gif "JDBCUpdaterConversions")  
  
 Преобразования, поддерживаемые методами обновления драйвера JDBC, делятся на три категории.  
  
-   **Без потерь (x)**: преобразования для случаев, когда тип обновления является таким же или меньшим, чем базовый тип сервера. Например, при вызове метода updateBidDecimal для базового десятичного столбца сервера преобразование не потребуется.  
  
-   **Преобразованием (y)**: преобразования из сервера числовых типов в типы языка Java, когда преобразование осуществляется стандартным образом и отвечает правилам преобразования языка Java. Для этих видов преобразования точные значения всегда усекаются (и никогда не округляются), а при переполнении значение сокращается по модулю размера типа назначения (меньшего). Например, вызов updateDecimal для базового **int** столбец, содержащий «1,9999» возвращает «1», или, если базовый **десятичное** значение равно «3000000000» то **int**превышает максимальное значение, результат будет равен «1294967296».  
  
-   **Зависимости от данных (z)**: преобразования из типов данных базового источника в целевые типы данных требуется, что содержащиеся значения могли быть преобразованы в типы назначения. Никакие другие преобразования не выполняются. Если значение слишком велико для метода считывания, то оно является недопустимым. Например, если вызывается метод updateString с аргументом «53» относительно столбца int, обновление завершается успешно; однако если базовое значение строки ― «foo» или «3000000000», возникает ошибка.  
  
 При вызове updateString на **двоичных**, **varbinary**, **varbinary(max)**, или **изображения** тип данных столбца, обрабатывает строковое значение как шестнадцатеричное значение строки.  
  
 Когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] столбец имеет тип данных **XML**, значение должно быть допустимым **XML**. При вызове методов updateBlob, updateBinaryStream или updateBytes, значение данных должно быть шестнадцатеричным представлением для строки XML-символов. Например:  
  
```  
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E   
```  
  
 Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.  
  
## <a name="setter-method-conversions"></a>Преобразование метода задания  
 Для данных, передаваемых в набор на языке Java\<тип > () методы [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) класса и [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) , применяются следующие виды преобразования.  
  
 ![JDBCSetterConversions](../../connect/jdbc/media/jdbc_jdbcsetterconversions_v2.gif "JDBCSetterConversions")  
  
 Сервер проверяет любые виды преобразования и возвращает ошибку при неудачном завершении.  
  
 В случае использования **строка** тип данных, если значение превышает длину **VARCHAR**, он был сопоставлен **LONGVARCHAR**. Аналогичным образом **NVARCHAR** сопоставляется **LONGNVARCHAR** Если значение превышает поддерживаемую длину **NVARCHAR**. То же самое справедливо для **byte []**. Значения длиннее **VARBINARY** становятся **LONGVARBINARY**.  
  
 Преобразования, поддерживаемые методами задания драйвера JDBC, делятся на три категории.  
  
-   **Без потерь (x)**: преобразования для числовых случаев, когда тип задания является таким же или меньшим, чем базовый тип сервера. Например, при вызове для базового серверного setBigDecimal **десятичное** столбца, то преобразование не требуется. Для числовых данных в случаях символ Java **числовое** тип данных преобразуется в **строка**. Например вызов setDouble со значением «53» относительно столбца varchar(50) формирует символьное значение «53» в столбце назначения.  
  
-   **Преобразованием (y)**: преобразования из типа Java **числовое** типа для базового серверного **числовое** типа, меньший по размеру. Это преобразование выполняется обычным образом и [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] соглашениям о преобразованиях. Точные значения всегда усекаются (никогда не округляются), а переполнение выводит ошибку неподдерживаемого преобразования. Например с помощью updateDecimal со значением «1,9999» на базовый результат столбца целое число со знаком в значение «1» в целевом столбце; Однако если передается значение «3000000000», драйвер выдает ошибку.  
  
-   **Зависимости от данных (z)**: преобразования из типа Java **строка** типа для базового [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] тип данных зависит от следующих условий: драйвер отправляет **строка** значение [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] и [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет преобразования, при необходимости. Если свойство sendStringParametersAsUnicode имеет значение true, а базовый [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] имеет тип данных **изображения**, [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] не выполняет преобразование **nvarchar** для **изображения** и вызывает исключение SQLServerException. Если параметр sendStringParametersAsUnicode установлен в значение false и базовый [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] имеет тип данных **изображения**, [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет преобразование **varchar** для **изображение**и не вызывает исключение.  
  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет преобразования и передает ошибки обратно драйверу JDBC, если возникают проблемы.  
  
 Когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] столбец имеет тип данных **XML**, значение должно быть допустимым **XML**. При вызове методов updateBlob, updateBinaryStream или updateBytes, значение данных должно быть шестнадцатеричным представлением для строки XML-символов. Например:  
  
```  
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E   
```  
  
 Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.  
  
## <a name="conversions-on-setobject"></a>Преобразование относительно setObject  
  
> [!NOTE]  
>  Драйверы Microsoft JDBC 4.2 (и более поздние версии) для SQL Server поддерживает JDBC 4.1 и 4.2. Дополнительные сведения о версии 4.1 и 4.2 сопоставлениях типов данных и преобразования в разделе [соответствие JDBC 4.1 для JDBC Driver](../../connect/jdbc/jdbc-4-1-compliance-for-the-jdbc-driver.md) и [соответствие JDBC 4.2 для JDBC Driver](../../connect/jdbc/jdbc-4-2-compliance-for-the-jdbc-driver.md), помимо приведенные ниже сведения.  
  
 Для данных, переданный на setObject на языке Java (\<тип >) методы [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) , применяются следующие виды преобразования.  
  
 ![JDBCSetObjectConversions](../../connect/jdbc/media/jdbc_jdbcsetobjectconversions.gif "JDBCSetObjectConversions")  
  
 Метод setObject с неуказанным целевым типом использует сопоставление по умолчанию. В случае использования **строка** тип данных, если значение превышает длину **VARCHAR**, он был сопоставлен **LONGVARCHAR**. Аналогичным образом **NVARCHAR** сопоставляется **LONGNVARCHAR** Если значение превышает поддерживаемую длину **NVARCHAR**. То же самое справедливо для **byte []**. Значения длиннее **VARBINARY** становятся **LONGVARBINARY**.  
  
 Преобразования, поддерживаемые методами setObject драйвера JDBC, делятся на три категории.  
  
-   **Без потерь (x)**: преобразования для числовых случаев, когда тип задания является таким же или меньшим, чем базовый тип сервера. Например, при вызове для базового серверного setBigDecimal **десятичное** столбца, то преобразование не требуется. Для числовых данных в случаях символ Java **числовое** тип данных преобразуется в **строка**. Например вызов setDouble со значением «53» относительно столбца varchar(50) сформирует символьное значение «53» в столбце назначения.  
  
-   **Преобразованием (y)**: преобразования из типа Java **числовое** типа для базового серверного **числовое** типа, меньший по размеру. Это преобразование выполняется обычным образом и [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] соглашениям о преобразованиях. Точные значения всегда усекаются и никогда не округляются, а при переполнении возникает ошибка неподдерживаемого преобразования. Например с помощью updateDecimal со значением «1,9999» на базовый результат столбца целое число со знаком в значение «1» в целевом столбце; Однако если передается значение «3000000000», драйвер выдает ошибку.  
  
-   **Зависимости от данных (z)**: преобразования из типа Java **строка** типа для базового [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] тип данных зависит от следующих условий: драйвер отправляет **строка** значение [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] и [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет преобразования, при необходимости. Если свойство подключения sendStringParametersAsUnicode имеет значение true, а базовым [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] имеет тип данных **изображения**, [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] не выполняет преобразование **nvarchar** для **изображения** и вызовет исключение SQLServerException. Если параметр sendStringParametersAsUnicode установлен в значение false и базовый [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] имеет тип данных **изображения**, [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет преобразование **varchar** для **изображение**и не вызывает исключение.  
  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] выполняет ряд заданных преобразований и передает ошибки обратно драйверу JDBC, если возникают проблемы. Преобразование на стороне клиента является исключением и выполняется только в случае использования **даты**, **время**, **timestamp**, **логическое**и  **Строка** значения.  
  
 Когда [!INCLUDE[ssNoVersion](../../includes/ssnoversion_md.md)] столбец имеет тип данных **XML**, значение должно быть допустимым **XML**. При вызове методов setObject(byte[], SQLXML), setObject(inputStream, SQLXML) или setObject(Blob, SQLXML) значение данных должно быть шестнадцатеричным представлением для строки XML-символов. Например:  
  
```  
<hello>world</hello> = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E   
```  
  
 Обратите внимание, что метка следования байтов (BOM) является обязательной, если XML-символы имеют определенную кодировку.  
  
## <a name="see-also"></a>См. также  
 [Основные сведения о типах данных драйвера JDBC](../../connect/jdbc/understanding-the-jdbc-driver-data-types.md)  
  
  
